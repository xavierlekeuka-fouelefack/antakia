{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#our-idea","title":"Our idea","text":"<p>Our Python library combines all the steps of our regional approach for your model:</p> <ul> <li>Simultaneous \"dyadic\" exploration of the value and explanation spaces of your model to be explained,</li> <li>Automatic recommendation of dyadic segmentation (regions that are both homogeneous in the 2 spaces) or manual selection</li> <li>For each region, expression of the selection made by the input or explained variables (cf. \"Skope rules\")</li> <li>Possibility of refining the definition of regions for each attribute (see \"flows\")</li> <li>For each region, a surrogate model is proposed from a library (including PiML and iModels)</li> <li>Performance, continuity and completeness testing of the final model</li> </ul>"},{"location":"about/","title":"About page ?","text":""},{"location":"about/#about-our-project","title":"About our project","text":"<p>AI-vidence !</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation-with-pip","title":"Installation with pip","text":"<p>Install using <code>pip</code></p> <pre><code>pip install antakia\n</code></pre>"},{"location":"getting-started/#local-installation","title":"Local installation","text":"<p>Clone the repo and create a virtual environment!</p> <pre><code>git clone https://github.com/AI-vidence/antakia.git\ncd antakia\npython3.10 -m venv .\nsource bin/activate\npip install -e .\n</code></pre>"},{"location":"getting-started/#installation-with-docker","title":"Installation with docker","text":"<p>Be sure to have a Docker engine running on your computer.</p> <pre><code>docker build -t antakia .\ndocker run -p 8888:8888 antakia\n</code></pre>"},{"location":"usage/","title":"User guide","text":"<p>Here is a simple use case of the AntakIA package.</p> <p>(find more examples in the this folder)</p> <p>AntakIA is made to be used in a notebook. You can either:</p> <ul> <li> <p>open a notebook in your IDE if supported (e.g. VSCode). Just open a <code>.ipynb</code> file directly from here !</p> </li> <li> <p>open a notebook using JupyterLab (recommended). To do so, open a terminal and type: <pre><code>pip install jupyterlab #if not already installed\nipython kernel install --name \"local-venv\" --user #to add your virtual environment to the list of kernels\njupyter lab\n</code></pre></p> </li> </ul> <p>Tip</p> <p>Using jupyterlab, you might want to manage your kernels. The following commands are useful:</p> <p>To access to the list of kernels:  <code>jupyter kernelspec list</code></p> <p>To remove a kernel: <code>jupyter kernelspec remove old_kernel</code></p>"},{"location":"usage/#using-the-gui","title":"Using the GUI","text":""},{"location":"usage/#launch-the-gui","title":"Launch the GUI","text":"<p>After installing the package (see here), you can use the package in a notebook:</p> <pre><code>import pandas as pd\ndf = pd.read_csv('data/california_housing.csv')\nX = df.iloc[:,0:8]\nY = df.iloc[:,9]\nSHAP = pd.read_csv('data/pre_computed_SHAP_values.csv')\n</code></pre> <pre><code>from sklearn.ensemble import GradientBoostingRegressor\nmodel = GradientBoostingRegressor(random_state = 9)\nmodel.fit(X, Y)\n</code></pre> <pre><code>import antakia\ndataset = antakia.Dataset(X, model = model, y=Y)\natk = antakia.AntakIA(dataset, explain = SHAP)\natk.startGUI()\n</code></pre> <p></p>"},{"location":"usage/#modify-the-explainability-method-and-the-projections","title":"Modify the explainability method and the projections","text":"<p>We can first modify the explainability method </p> <p></p> <p>and then the projections, by choosing between the different projections available or by modifying the parameters of the projection!</p> <p></p>"},{"location":"usage/#create-our-first-potato","title":"Create our first Potato","text":"<p>We can now create our first Potato. Select the region of interest on one or the other space, and visualize the points selected in the other one.</p> <p></p>"},{"location":"usage/#apply-skope-rules","title":"Apply Skope-Rules","text":"<p>We can now apply Skope Rules on the selected region, in order to define it with a set of rules on the features.</p> <p></p>"},{"location":"usage/#modify-the-rules","title":"Modify the rules","text":"<p>We can now modify the rules, by changing the parameters of the rules, or by adding or removing rules. This feature come with interesting data-visualization tools!</p> <p></p>"},{"location":"usage/#apply-sub-model","title":"Apply sub-model","text":"<p>We can now apply a sub-model on the selected region. The sub-models are to be choosen in the list of the available models. To import your own modles, please refer to the documentation.</p> <p></p>"},{"location":"usage/#validate-the-region","title":"Validate the region","text":"<p>We can now validate the region, and add it to the list of the validated regions.</p> <p></p>"},{"location":"usage/#have-everything-done-for-you-the-magic-button","title":"Have everything done for you : the magic button !","text":"<p>Click the button on the very bottom of the GUI, and let the magic happen ! The potatoes are created automatically using our dyadic-clusterign algorithm, skope-rules are found, the best submodel is chosen and the region is added to the list ! For more information about the dyadic-clustering, see utils.</p> <p></p>"},{"location":"usage/#in-command-lines","title":"In command lines","text":""},{"location":"documentation/","title":"Documentation","text":"<p>This reference manual details functions, modules, and objects included in AntakIA, describing what they are and what they do.</p> <p>AntakIA has several objects, each with its own set of functions and methods. The main objects are:</p> <ul> <li>AntakIA, the main AntakIA object</li> <li>GUI, the graphical user interface</li> <li>Dataset, a dataset object</li> <li>Potato, a potato object</li> </ul> <p>Other modules are:</p> <ul> <li>Utils, a set of useful functions</li> <li>LongTask, a class to run long tasks, often in a separate thread</li> </ul>"},{"location":"documentation/antakia/","title":"<code>AntakIA</code> (Class)","text":"<p>AntakIA object. This main class of the antakia package. It contains all the data and variables needed to run the interface (see antakia.GUI).</p> <p>Attributes:</p> Name Type Description <code>dataset</code> <code>Dataset object</code> <p>The Dataset object containing the data to explain. For more information, please see the documentation of the class Dataset.</p> <code>explain</code> <code>dict</code> <p>The dictionary containing the explanations. The keys are the names of the explanations (for example \"SHAP\" or \"LIME\"). The explanations are pandas dataframes. You can import your own explanations using <code>import_explanation</code>.</p> <code>regions</code> <code>list</code> <p>The list of the regions computed by the user. A region is an AntakIA object, named Potato. For more information, please see the documentation of the class Potato.</p> <code>saves</code> <code>list</code> <p>The list of the saves. A save is a list of regions.</p> <code>gui</code> <code>GUI object</code> <p>The GUI object is in charge of the interface. For more information, please see the documentation of the class GUI.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset object</code> <p>The Dataset object containing the data to explain.</p> required <code>import_explanation</code> <code>pandas dataframe</code> <p>The dataframe containing the explanations. The dataframe must have the same number of rows as the dataset. The GUI can compute other types of explanations using different methods.</p> <code>None</code> Source code in <code>antakia/antakia.py</code> <pre><code>def __init__(self, dataset: Dataset, import_explanation: pd.DataFrame = None, saves: dict = None, saves_path: str = None):\n\"\"\"\n    Constructor of the class AntakIA.\n    Parameters\n    ---------\n    dataset : Dataset object\n        The Dataset object containing the data to explain.\n    import_explanation : pandas dataframe\n        The dataframe containing the explanations. The dataframe must have the same number of rows as the dataset.\n        The GUI can compute other types of explanations using different methods.\n    \"\"\"\nself.dataset = dataset\nself.regions = []\nself.gui = None\nself.explain = dict()\nif import_explanation is not None:\nself.explain[\"Imported\"] = import_explanation.iloc[dataset.frac_indexes].reset_index(drop=True)\nelse:\nself.explain[\"Imported\"] = None\nself.explain[\"SHAP\"] = None\nself.explain[\"LIME\"] = None\nif saves is not None:\nself.saves = saves\nelif saves_path is not None:\nself.saves = utils.load_save(self, saves_path)\nelse:\nself.saves = []\nself.widget = None\nself.gui = GUI(self)\n</code></pre>"},{"location":"documentation/antakia/#antakia.AntakIA.computeDyadicClustering","title":"<code>computeDyadicClustering(explanation='Imported', min_clusters=3, automatic=True, sub_models=False)</code>","text":"<p>Function that computes the dyadic-clustering. Our dyadic-clustering (sometimes found as co-clusetring or bi-clustering), uses <code>mvlearn</code> and <code>skope-rules</code> to compute the clusters.</p> <p>Parameters:</p> Name Type Description Default <code>explanation</code> <code>str</code> <p>The type of explanation to use. The possible values are \"Imported\", \"SHAP\" and \"LIME\".</p> <code>'Imported'</code> <code>min_clusters</code> <code>int</code> <p>The minimum number of clusters to compute.</p> <code>3</code> <code>automatic</code> <code>bool</code> <p>If True, the number of clusters is computed automatically, respecting the minimum number of clusters.</p> <code>True</code> <code>sub_models</code> <code>bool</code> <p>If True, the best model for each region is computed. The possible models are the ones in the list sub_models.</p> <code>False</code> Source code in <code>antakia/antakia.py</code> <pre><code>def computeDyadicClustering(self, explanation:str = \"Imported\", min_clusters:int = 3, automatic:bool = True, sub_models:bool = False):\n\"\"\"\n    Function that computes the dyadic-clustering.\n    Our dyadic-clustering (sometimes found as co-clusetring or bi-clustering), uses `mvlearn` and `skope-rules` to compute the clusters.\n    Parameters\n    ---------\n    explanation : str\n        The type of explanation to use.\n        The possible values are \"Imported\", \"SHAP\" and \"LIME\".\n    min_clusters : int\n        The minimum number of clusters to compute.\n    automatic : bool\n        If True, the number of clusters is computed automatically, respecting the minimum number of clusters.\n    sub_models : bool\n        If True, the best model for each region is computed. The possible models are the ones in the list sub_models.\n    \"\"\"\nif self.explain[explanation] is None:\nraise ValueError(\"You must compute the explanations before computing the dyadic-clustering!\")\nif min_clusters &lt;2 or min_clusters &gt; len(self.dataset.X):\nraise ValueError(\"The minimum number of clusters must be between 2 and the number of observations!\")\nclusters, clusters_axis = function_auto_clustering(self.dataset.X, self.explain[explanation], min_clusters, automatic)\nself.regions = []\nfor i in range(len(clusters)):\nself.regions.append(Potato(self, clusters[i]))\nif sub_models:\nself.regions[i].sub_model[\"model\"], self.regions[i].sub_model[\"score\"] = self.__find_best_model(self.regions[i].data, self.regions[i].y, self.gui.sub_models)\n</code></pre>"},{"location":"documentation/antakia/#antakia.AntakIA.computeLIME","title":"<code>computeLIME(verbose=True)</code>","text":"<p>Computes the LIME values of the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, a progress bar is displayed.</p> <code>True</code>"},{"location":"documentation/antakia/#antakia.AntakIA.computeLIME--see-also","title":"See also:","text":"<p>The Lime library on GitHub : https://github.com/marcotcr/lime/tree/master</p> Source code in <code>antakia/antakia.py</code> <pre><code>def computeLIME(self, verbose:bool = True):\n\"\"\"\n    Computes the LIME values of the dataset.\n    Parameters\n    ---------\n    verbose : bool\n        If True, a progress bar is displayed.\n    See also:\n    ---------\n    The Lime library on GitHub : https://github.com/marcotcr/lime/tree/master\n    \"\"\"\nlime = compute.computationSHAP(self.dataset.X, self.dataset.X_all, self.dataset.model)\nif verbose:\nself.verbose = self.__create_progress(\"LIME\")\nwidgets.jslink((self.widget.children[1], \"v_model\"), (lime.progress_widget, \"v_model\"))\nwidgets.jslink((self.widget.children[2], \"v_model\"), (lime.text_widget, \"v_model\"))\ndisplay(self.widget)\nself.explain[\"LIME\"] = lime.compute()\n</code></pre>"},{"location":"documentation/antakia/#antakia.AntakIA.computeSHAP","title":"<code>computeSHAP(verbose=True)</code>","text":"<p>Computes the SHAP values of the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, a progress bar is displayed.</p> <code>True</code>"},{"location":"documentation/antakia/#antakia.AntakIA.computeSHAP--see-also","title":"See also:","text":"<p>The Shap library on GitHub : https://github.com/shap/shap/tree/master</p> Source code in <code>antakia/antakia.py</code> <pre><code>def computeSHAP(self, verbose:bool = True):\n\"\"\"\n    Computes the SHAP values of the dataset.\n    Parameters\n    ---------\n    verbose : bool\n        If True, a progress bar is displayed.\n    See also:\n    ---------\n    The Shap library on GitHub : https://github.com/shap/shap/tree/master\n    \"\"\"\nshap = compute.computationSHAP(self.dataset.X, self.dataset.X_all, self.dataset.model)\nif verbose:\nself.verbose = self.__create_progress(\"SHAP\")\nwidgets.jslink((self.widget.children[1], \"v_model\"), (shap.progress_widget, \"v_model\"))\nwidgets.jslink((self.widget.children[2], \"v_model\"), (shap.text_widget, \"v_model\"))\ndisplay(self.widget)\nself.explain[\"SHAP\"] = shap.compute()\n</code></pre>"},{"location":"documentation/antakia/#antakia.AntakIA.getDataset","title":"<code>getDataset()</code>","text":"<p>Function that returns the Dataset object containing the data to explain. For more information, please see the documentation of the class Dataset.</p> <p>Returns:</p> Type Description <code>Dataset object</code> <p>The Dataset object.</p> Source code in <code>antakia/antakia.py</code> <pre><code>def getDataset(self) -&gt; Dataset:\n\"\"\"\n    Function that returns the Dataset object containing the data to explain.\n    For more information, please see the documentation of the class Dataset.\n    Returns\n    -------\n    Dataset object\n        The Dataset object.\n    \"\"\"\nreturn self.dataset\n</code></pre>"},{"location":"documentation/antakia/#antakia.AntakIA.getExplanations","title":"<code>getExplanations(method=None)</code>","text":"<p>Function that returns the dictionary containing the explanations. The keys are the names of the explanations (for example \"SHAP\" or \"LIME\"). The explanations are pandas dataframes.</p> <p>Returns:</p> Type Description <code>dict or pandas dataframe</code> <p>The dictionary containing the explanations or the explanation corresponding to the key explanation.</p> Source code in <code>antakia/antakia.py</code> <pre><code>def getExplanations(self, method=None) -&gt; dict:\n\"\"\"\n    Function that returns the dictionary containing the explanations.\n    The keys are the names of the explanations (for example \"SHAP\" or \"LIME\"). The explanations are pandas dataframes.\n    Returns\n    -------\n    dict or pandas dataframe\n        The dictionary containing the explanations or the explanation corresponding to the key explanation.\n    \"\"\"\nif method is None:\nreturn self.explain\ntry :\nreturn self.explain[method]\nexcept KeyError:\nraise KeyError(\"The method \" + method + \" is not a valid method. The possible methods are \" + str(list(self.explain.keys())) + \".\")\n</code></pre>"},{"location":"documentation/antakia/#antakia.AntakIA.getGUI","title":"<code>getGUI()</code>","text":"<p>Function that returns the GUI object. For more information, please see the documentation of the class GUI.</p> <p>Returns:</p> Type Description <code>GUI object</code> <p>The GUI object.</p> Source code in <code>antakia/antakia.py</code> <pre><code>def getGUI(self) -&gt; GUI:\n\"\"\"\n    Function that returns the GUI object.\n    For more information, please see the documentation of the class GUI.\n    Returns\n    -------\n    GUI object\n        The GUI object.\n    \"\"\"\nreturn self.gui\n</code></pre>"},{"location":"documentation/antakia/#antakia.AntakIA.getRegions","title":"<code>getRegions()</code>","text":"<p>Function that returns the list of the regions computed by the user.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of the regions computed. A region is a list of AntakIA objects, named <code>Potato</code>.</p> Source code in <code>antakia/antakia.py</code> <pre><code>def getRegions(self) -&gt; list:\n\"\"\"\n    Function that returns the list of the regions computed by the user.\n    Returns\n    -------\n    list\n        The list of the regions computed. A region is a list of AntakIA objects, named `Potato`.\n    \"\"\"\nreturn self.regions\n</code></pre>"},{"location":"documentation/antakia/#antakia.AntakIA.getSaves","title":"<code>getSaves()</code>","text":"<p>Function that returns the list of the saves.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of the saves. A save is a list of regions.</p> Source code in <code>antakia/antakia.py</code> <pre><code>def getSaves(self) -&gt; list:\n\"\"\"\n    Function that returns the list of the saves.\n    Returns\n    -------\n    list\n        The list of the saves. A save is a list of regions.\n    \"\"\"\nreturn self.saves\n</code></pre>"},{"location":"documentation/antakia/#antakia.AntakIA.newRegion","title":"<code>newRegion(potato)</code>","text":"<p>Function that adds a region to the list of regions.</p> <p>Parameters:</p> Name Type Description Default <code>potato</code> <code>Potato object</code> <p>The Potato object to add to the list of regions.</p> required Source code in <code>antakia/antakia.py</code> <pre><code>def newRegion(self, potato: Potato):\n\"\"\"\n    Function that adds a region to the list of regions.\n    Parameters\n    ---------\n    potato : Potato object\n        The Potato object to add to the list of regions.\n    \"\"\"\nself.regions.append(potato)\n</code></pre>"},{"location":"documentation/antakia/#antakia.AntakIA.resetRegions","title":"<code>resetRegions()</code>","text":"<p>Function that resets the list of the regions computed by the user.</p> Source code in <code>antakia/antakia.py</code> <pre><code>def resetRegions(self):\n\"\"\"\n    Function that resets the list of the regions computed by the user.\n    \"\"\"\nself.regions = []\n</code></pre>"},{"location":"documentation/antakia/#antakia.AntakIA.startGUI","title":"<code>startGUI(explanation=None, projection='PaCMAP', sub_models=None, display=True)</code>","text":"<p>Function that instantiates the GUI and calls its display() function. For more information, please see the documentation of the class GUI.</p> <p>Parameters:</p> Name Type Description Default <code>explanation</code> <code>str</code> <p>The type of explanation to use. If an explanation is already computed (see antakia.dataset), it is used by default. If not, the user must choose between \"SHAP\" and \"LIME\". The explanatory values caen be computed directly in the interface!</p> <code>None</code> <code>projection</code> <code>str</code> <p>The default projection to use. The possible values are \"PaCMAP\", \"PCA\", \"t-SNE\" and \"UMAP\".</p> <code>'PaCMAP'</code> <code>sub_models</code> <code>list</code> <p>The list of the sub_models to choose from for each region. The only constraint is that sub_models must have a predict method.</p> <code>None</code> <code>display</code> <code>bool</code> <p>If True, the interface is displayed. Else, You can access the interface with the attribute gui of the class.</p> <code>True</code> Source code in <code>antakia/antakia.py</code> <pre><code>def startGUI(self,\nexplanation: str = None,\nprojection: str = \"PaCMAP\",\nsub_models: list = None,\ndisplay = True) -&gt; GUI:\n\"\"\"\n    Function that instantiates the GUI and calls its display() function.\n    For more information, please see the documentation of the class GUI.\n    Parameters\n    ---------\n    explanation : str\n        The type of explanation to use. If an explanation is already computed (see antakia.dataset), it is used by default. If not, the user must choose between \"SHAP\" and \"LIME\".\n        The explanatory values caen be computed directly in the interface!\n    projection : str\n        The default projection to use. The possible values are \"PaCMAP\", \"PCA\", \"t-SNE\" and \"UMAP\".\n    sub_models : list\n        The list of the sub_models to choose from for each region. The only constraint is that sub_models must have a predict method.\n    display : bool\n        If True, the interface is displayed. Else, You can access the interface with the attribute gui of the class.\n    \"\"\"\nself.gui = GUI(self, explanation, projection, sub_models)\nif display:\nself.gui.display()\n</code></pre>"},{"location":"documentation/compute/","title":"<code>Compute</code> (List of functions and classes)","text":""},{"location":"documentation/compute/#antakia.compute.DimensionalityReduction","title":"<code>DimensionalityReduction()</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Class that allows to reduce the dimensionality of the data.</p> Source code in <code>antakia/compute.py</code> <pre><code>def __init__(self):\n\"\"\"\n    Constructor of the class DimensionalityReduction.\n    \"\"\"\npass\n</code></pre>"},{"location":"documentation/compute/#antakia.compute.LongTask","title":"<code>LongTask(X, X_all, model)</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract class to compute long tasks, often in a separate thread.</p> <p>Attributes:</p> Name Type Description <code>X</code> <code>pandas dataframe</code> <p>The dataframe containing the data to explain.</p> <code>X_all</code> <code>pandas dataframe</code> <p>The dataframe containing the entire dataset, in order for the explanations to be computed.</p> <code>model</code> <code>model object</code> <p>The \"black-box\" model to explain.</p> Source code in <code>antakia/compute.py</code> <pre><code>def __init__(self, X, X_all, model):\nself.X = X\nself.X_all = X_all\nself.model = model\nself.progress = 0\nself.progress_widget = v.Textarea(v_model=0)\nself.text_widget = v.Textarea(v_model=None)\nself.done_widget = v.Textarea(v_model=True)\nself.value = None\nself.thread = None\n</code></pre>"},{"location":"documentation/compute/#antakia.compute.LongTask.compute","title":"<code>compute()</code>  <code>abstractmethod</code>","text":"<p>Method to compute the long task.</p> Source code in <code>antakia/compute.py</code> <pre><code>@abstractmethod\ndef compute(self):\n\"\"\"\n    Method to compute the long task.\n    \"\"\"\npass\n</code></pre>"},{"location":"documentation/compute/#antakia.compute.LongTask.compute_in_thread","title":"<code>compute_in_thread()</code>","text":"<p>Method to compute the long task in a separate thread.</p> Source code in <code>antakia/compute.py</code> <pre><code>def compute_in_thread(self):\n\"\"\"\n    Method to compute the long task in a separate thread.\n    \"\"\"\nself.thread = threading.Thread(target=self.compute)\nself.thread.start()\n</code></pre>"},{"location":"documentation/compute/#antakia.compute.computationLIME","title":"<code>computationLIME</code>","text":"<p>             Bases: <code>LongTask</code></p> <p>LIME computation class.</p>"},{"location":"documentation/compute/#antakia.compute.computationPCA","title":"<code>computationPCA</code>","text":"<p>             Bases: <code>DimensionalityReduction</code></p> <p>PCA computation class.</p>"},{"location":"documentation/compute/#antakia.compute.computationPaCMAP","title":"<code>computationPaCMAP</code>","text":"<p>             Bases: <code>DimensionalityReduction</code></p> <p>PaCMAP computation class.</p>"},{"location":"documentation/compute/#antakia.compute.computationSHAP","title":"<code>computationSHAP</code>","text":"<p>             Bases: <code>LongTask</code></p> <p>SHAP computation class.</p>"},{"location":"documentation/compute/#antakia.compute.computationTSNE","title":"<code>computationTSNE</code>","text":"<p>             Bases: <code>DimensionalityReduction</code></p> <p>t-SNE computation class.</p>"},{"location":"documentation/compute/#antakia.compute.computationUMAP","title":"<code>computationUMAP</code>","text":"<p>             Bases: <code>DimensionalityReduction</code></p> <p>UMAP computation class.</p>"},{"location":"documentation/compute/#antakia.compute.DimensionalityReductionChooser","title":"<code>DimensionalityReductionChooser(method)</code>","text":"<p>Function that allows to choose the dimensionality reduction method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The name of the method to use.</p> required Source code in <code>antakia/compute.py</code> <pre><code>def DimensionalityReductionChooser(method):\n\"\"\"\n    Function that allows to choose the dimensionality reduction method.\n    Parameters\n    ----------\n    method : str\n        The name of the method to use.\n    \"\"\"\nif method == 'PCA':\nreturn computationPCA()\nelif method == 't-SNE':\nreturn computationTSNE()\nelif method == 'UMAP':\nreturn computationUMAP()\nelif method == 'PaCMAP':\nreturn computationPaCMAP()\n</code></pre>"},{"location":"documentation/dataset/","title":"<code>Dataset</code> (Class)","text":"<p>Dataset object. This object contains the all data, the model to explain, the explanations and the predictions.</p> <p>Attributes:</p> Name Type Description <code>X</code> <code>pandas dataframe</code> <p>The dataframe containing the dataset (might not be the entire dataset, see <code>frac</code> method)</p> <code>X_all</code> <code>pandas dataframe</code> <p>The dataframe containing the entire dataset, in order for the explanations to be computed.</p> <code>X_scaled</code> <code>pandas dataframe</code> <p>The dataframe containing the scaled dataset.</p> <code>y</code> <code>pandas series</code> <p>The series containing the target values.</p> <code>model</code> <code>model object</code> <p>The \"black-box\" model to explain.</p> <code>y_pred</code> <code>pandas series</code> <p>The series containing the predictions of the model. If None, the predictions are computed using the model and the data.</p> <code>comments</code> <code>list of str</code> <p>The comments associated to each feature.</p> <code>sensible</code> <code>list of bool</code> <p>The list of boolean indicating if the feature is sensible or not. If True, a warning will be displayed when the feature is used in the explanations. More to come in the future.</p> <code>lat</code> <code>str</code> <p>The name of the latitude column.</p> <code>long</code> <code>str</code> <p>The name of the longitude column.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>pandas dataframe</code> <p>The dataframe containing the dataset.</p> <code>None</code> <code>csv</code> <code>str</code> <p>The path to the csv file containing the dataset.</p> <code>None</code> <code>y</code> <code>pandas series</code> <p>The series containing the target values.</p> <code>None</code> <code>model</code> <code>model object</code> <p>The \"black-box\" model to explain. The model must have a predict method.</p> <code>None</code> Source code in <code>antakia/dataset.py</code> <pre><code>def __init__(self, X:pd.DataFrame = None, csv:str = None, y:pd.Series = None, model = None):\n\"\"\"\n    Constructor of the class Dataset.\n    Parameters\n    ---------\n    X : pandas dataframe\n        The dataframe containing the dataset.\n    csv : str\n        The path to the csv file containing the dataset.\n    y : pandas series\n        The series containing the target values.\n    model : model object\n        The \"black-box\" model to explain. The model must have a predict method.\n    \"\"\"\nX.columns = [X.columns[i].replace(\" \", \"_\") for i in range(len(X.columns))]\nX = X.reset_index(drop=True)\nif X is None and csv is None :\nraise ValueError(\"You must provide a dataframe or a csv file\")\nif X is not None and csv is not None :\nraise ValueError(\"You must provide either a dataframe or a csv file, not both\")\nif X is not None :\nself.X = X\nelse :\nself.X = pd.read_csv(csv)\nself.X_all = X\nself.model = model\nself.y = y\nself.X_scaled = pd.DataFrame(StandardScaler().fit_transform(X))\nself.X_scaled.columns = X.columns\nself.y_pred = pd.Series(self.model.predict(self.X))\nself.verbose = None\nself.widget = None\nself.comments = [\"\"]*len(self.X.columns)\nself.sensible = [False]*len(self.X.columns)\nself.fraction = 1\nself.frac_indexes = self.X.index\nself.long, self.lat = None, None\nfor name in ['longitude', 'Longitude', 'Long', 'long']:\nif name in self.X.columns:\nself.long = name\nfor name in ['latitude', 'Latitude', 'Lat', 'lat']:\nif name in self.X.columns:\nself.lat = name\n</code></pre>"},{"location":"documentation/dataset/#antakia.dataset.Dataset.frac","title":"<code>frac(p)</code>","text":"<p>Reduces the dataset to a fraction of its size.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>The fraction of the dataset to keep.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import antakia\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; X = pd.DataFrame([[1, 2], [3, 4], [5, 6], [7, 8]], columns=[\"a\", \"b\"])\n&gt;&gt;&gt; my_dataset = antakia.Dataset(X, model)\n&gt;&gt;&gt; my_dataset.frac(0.5)\n&gt;&gt;&gt; my_dataset.X\n      a  b\n0     1  2\n1     5  6\n</code></pre> Source code in <code>antakia/dataset.py</code> <pre><code>def frac(self, p:float):\n\"\"\"\n    Reduces the dataset to a fraction of its size.\n    Parameters\n    ---------\n    p : float\n        The fraction of the dataset to keep.\n    Examples\n    --------\n    &gt;&gt;&gt; import antakia\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; X = pd.DataFrame([[1, 2], [3, 4], [5, 6], [7, 8]], columns=[\"a\", \"b\"])\n    &gt;&gt;&gt; my_dataset = antakia.Dataset(X, model)\n    &gt;&gt;&gt; my_dataset.frac(0.5)\n    &gt;&gt;&gt; my_dataset.X\n          a  b\n    0     1  2\n    1     5  6\n    \"\"\"\nself.X = self.X_all.sample(frac=p, random_state=9)\nself.frac_indexes = deepcopy(self.X.index)\nself.X_scaled = self.X_scaled.iloc[self.frac_indexes].reset_index(drop=True)\nself.y_pred = self.y_pred.iloc[self.frac_indexes].reset_index(drop=True)\nif self.y is not None:\nself.y = self.y.iloc[self.frac_indexes].reset_index(drop=True)\nself.fraction = p\nself.X.reset_index(drop=True, inplace=True)\n</code></pre>"},{"location":"documentation/dataset/#antakia.dataset.Dataset.getLongLat","title":"<code>getLongLat()</code>","text":"<p>Returns the longitude and latitude columns of the dataset.</p> <p>Returns:</p> Name Type Description <code>long</code> <code>str</code> <p>The name of the longitude column.</p> <code>lat</code> <code>str</code> <p>The name of the latitude column.</p> Source code in <code>antakia/dataset.py</code> <pre><code>def getLongLat(self):\n\"\"\"\n    Returns the longitude and latitude columns of the dataset.\n    Returns\n    -------\n    long : str\n        The name of the longitude column.\n    lat : str\n        The name of the latitude column.\n    \"\"\"\nreturn self.long, self.lat\n</code></pre>"},{"location":"documentation/dataset/#antakia.dataset.Dataset.improve","title":"<code>improve()</code>","text":"<p>Improves the dataset. Displays a widget to modify the dataset. For each feature, you can change its name, its type, its comment and if it is sensible or not. You also have the access to the general informations of the dataset.</p> Source code in <code>antakia/dataset.py</code> <pre><code>def improve(self):\n\"\"\"\n    Improves the dataset. Displays a widget to modify the dataset. For each feature, you can change its name, its type, its comment and if it is sensible or not.\n    You also have the access to the general informations of the dataset.\n    \"\"\"\ngeneral_infos = v.Row(class_=\"ma-2\", children=[\nv.Icon(children=[\"mdi-database\"], size=\"30px\"),\nv.Html(tag=\"h3\", class_=\"mb-3 mt-3 ml-4\", children=[\nstr(self.X.shape[0]) + \" observations, \" + str(self.X.shape[1]) + \" features\"\n])])\nliste_slides = []\nfor i in range(self.X.shape[1]):\ninfos = [min(self.X.iloc[:,i]), max(self.X.iloc[:,i]), np.mean(self.X.iloc[:,i]), np.std(self.X.iloc[:,i])]\ninfos = [round(infos[j], 3) for j in range(len(infos))]\nliste_slides.append(gui_elements.create_slide_dataset(self.X.columns[i], i+1, self.X.dtypes[i], len(self.X.columns), self.comments[i], self.sensible[i], infos))\nslidegroup = v.SlideGroup(\nv_model=None,\nclass_=\"ma-3 pa-3\",\nelevation=4,\ncenter_active=True,\nshow_arrows=True,\nchildren=liste_slides,\n)\ndef changement_sensible(widget, event, data):\ni = int(widget.class_)-1\nif widget.v_model :\nliste_slides[i].children[0].color = \"red lighten-5\"\nself.sensible[i] = True\nelse:\nliste_slides[i].children[0].color = \"white\"\nself.sensible[i] = False\ndef changement_names(widget, event, data):\ni = widget.value-1\nself.X = self.X.rename(columns={self.X.columns[i]: widget.v_model})\ndef changement_type(widget, event, data):\ni = widget.value-1\nwidget2 = liste_slides[i].children[0].children[-1].children[1].children[0]\ntry :\nself.X = self.X.astype({self.X.columns[i]: widget2.v_model})\nexcept:\nprint(\"The type of the column \" + self.X.columns[i] + \" cannot be changed to \" + widget2.v_model)\nwidget.color = \"error\"\ntime.sleep(2)\nwidget.color = \"\"\nelse:\nwidget.color = \"success\"\ntime.sleep(2)\nwidget.color = \"\"\ndef changement_comment(widget, event, data):\ni = widget.value-1\nself.comments[i] = widget.v_model\nfor i in range(len(liste_slides)):\nliste_slides[i].children[0].children[-1].children[2].on_event(\"change\", changement_sensible)\nliste_slides[i].children[0].children[-1].children[3].on_event(\"change\", changement_comment)\nliste_slides[i].children[0].children[0].children[0].on_event(\"change\", changement_names)\nliste_slides[i].children[0].children[-1].children[1].children[-1].on_event(\"click\", changement_type)\nwidget = v.Col(children=[\ngeneral_infos,\nslidegroup,\n])\ndisplay(widget)\n</code></pre>"},{"location":"documentation/dataset/#antakia.dataset.Dataset.setLongLat","title":"<code>setLongLat(long, lat)</code>","text":"<p>Sets the longitude and latitude columns of the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>long</code> <code>str</code> <p>The name of the longitude column.</p> required <code>lat</code> <code>str</code> <p>The name of the latitude column.</p> required Source code in <code>antakia/dataset.py</code> <pre><code>def setLongLat(self, long:str, lat:str):\n\"\"\"\n    Sets the longitude and latitude columns of the dataset.\n    Parameters\n    ---------\n    long : str\n        The name of the longitude column.\n    lat : str\n        The name of the latitude column.\n    \"\"\"\nself.long = long\nself.lat = lat\n</code></pre>"},{"location":"documentation/gui/","title":"<code>GUI</code> (Class)","text":"<p>Gui object. This object contains all the data and variables needed to run the interface. The interface is built using ipyvuetify and plotly. For more information, please see to the references.</p> <p>Attributes:</p> Name Type Description <code>atk</code> <code>atk object</code> <p>The atk object containing the data to explain.</p> <code>selection</code> <code>Potato object</code> <p>The <code>Potato</code> object containing the current selection. For more information, please see the documentation of the class Potato.</p> <p>Parameters:</p> Name Type Description Default <code>atk</code> <code>AntakIA object</code> <p>See the documentation of the class AntakIA.</p> required <code>explanation</code> <code>str</code> <p>The default explanation to display. It can be \"Imported\", \"SHAP\" or \"LIME\".</p> <code>None</code> <code>projection</code> <code>str</code> <p>The default projection to display. It can be \"PaCMAP\", \"PCA\", \"t-SNE\" or \"UMAP\".</p> <code>'PaCMAP'</code> <code>sub_models</code> <code>list</code> <p>The list of sub-models to choose from for each region created by the user. The sub-models must have a predict method.</p> <code>None</code> Source code in <code>antakia/gui.py</code> <pre><code>def __init__(\nself,\natk,\nexplanation: str = None,\nprojection: str = \"PaCMAP\",\nsub_models: list = None,\n):\n\"\"\"Function that creates the interface.\n    Parameters\n    ----------\n    atk : AntakIA object\n        See the documentation of the class AntakIA.\n    explanation : str\n        The default explanation to display. It can be \"Imported\", \"SHAP\" or \"LIME\".\n    projection : str\n        The default projection to display. It can be \"PaCMAP\", \"PCA\", \"t-SNE\" or \"UMAP\".\n    sub_models : list\n        The list of sub-models to choose from for each region created by the user. The sub-models must have a predict method.\n    \"\"\"\nif type(explanation) != str and type(explanation) != type(None):\nraise TypeError(\"explanation must be a string\")\nself.atk = atk\nif sub_models is None :\n# default sub_models\n# TODO : add sub_models for classifications (ex: German Credit)\nsub_models = [\nlinear_model.LinearRegression(),\nRandomForestRegressor(random_state=9),\nensemble.GradientBoostingRegressor(random_state=9),\n]\nself.sub_models = sub_models\n# Publique :\nself.selection = Potato(self.atk, [])\n# Priv\u00e9 :\nif explanation is None :\nif self.atk.explain[\"Imported\"] is not None:\nexplanation = \"Imported\"\nelse :\nexplanation = \"SHAP\"\nself.__projectionVS = projection #string\nself.__projectionES = projection #string\nself.__explanation = explanation #string\nself.dim_red = {}\nself.dim_red[\"VS\"] = {\"PCA\": None, \"t-SNE\": None, \"UMAP\": None, \"PaCMAP\": None}\nself.dim_red[\"ES\"] = {}\nself.dim_red[\"ES\"][\"Imported\"] = {\"PCA\": None, \"t-SNE\": None, \"UMAP\": None, \"PaCMAP\": None}\nself.dim_red[\"ES\"][\"SHAP\"] = {\"PCA\": None, \"t-SNE\": None, \"UMAP\": None, \"PaCMAP\": None}\nself.dim_red[\"ES\"][\"LIME\"] = {\"PCA\": None, \"t-SNE\": None, \"UMAP\": None, \"PaCMAP\": None}    \nif self.__explanation == \"SHAP\" and type(self.atk.explain[\"SHAP\"]) == type(None) :\nself.__calculus = True\nelif self.__explanation == \"LIME\" and type(self.atk.explain[\"LIME\"]) == type(None) :\nself.__calculus = True\nelse:\nself.__calculus = False\nself.__color_regions = [] # the color of the regions created by the automatic dyadic clustering\nself.__save_rules = None #useful to keep the initial rules from the skope-rules, in order to be able to reset the rules\nself.__other_columns = None #to keep track of the columns that are not used in the rules !\nself.__activate_histograms = False #to know if the histograms are activated or not (bug ipywidgets !). If they are activated, we have to update the histograms.\nself.__model_index = None #to know which sub_model is selected by the user. \nself.__labels_automatic_clustering = None #to keep track of the labels from the automatic-clustering, used for the colors !\nself.__result_dyadic_clustering = None #to keep track  of the entire results from the dyadic-clustering\nself.__score_sub_models = None #to keep track of the scores of the sub-models\nself.__table_save = None #to manipulate the table of the saves\n</code></pre>"},{"location":"documentation/gui/#antakia.gui.GUI.display","title":"<code>display()</code>","text":"<p>Function that displays the interface.</p> Source code in <code>antakia/gui.py</code> <pre><code>def display(self):\n\"\"\"Function that displays the interface.\n    \"\"\"\nif self.sub_models != None and len(self.sub_models) &gt; 9:\nraise ValueError(\"You can enter up to 9 sub-models maximum ! (changes to come)\")\n# wait screen definition\ndata_path = files(\"antakia.assets\").joinpath(\"logo_antakia.png\")\nlogo_antakia = widgets.Image(\nvalue=open(data_path, \"rb\").read(), layout=Layout(width=\"230px\")\n)\n# waiting screen progress bars definition\nprogress_shap = gui_elements.ProgressLinear()\n# VS dimension reduction progress bar\nprogress_red = gui_elements.ProgressLinear()\n# consolidation of progress bars and progress texts in a single HBox\nprog_shap = gui_elements.TotalProgress(\"Computing of explanatory values\", progress_shap)\nprog_red = gui_elements.TotalProgress(\"Computing of dimensions reduction\", progress_red)\n# definition of the splash screen which includes all the elements,\nsplash_screen = v.Layout(\nclass_=\"d-flex flex-column align-center justify-center\",\nchildren=[logo_antakia, prog_shap, prog_red],\n)\n# we send the splash screen\ndisplay(splash_screen)\n# if we import the explanatory values, the progress bar of this one is at 100\nif not self.__calculus:\nprogress_shap.v_model = 100\nprog_shap.children[2].children[\n0\n].v_model = \"Imported explanatory values\"\nelse :\nif self.__explanation == \"SHAP\":\ncompute_SHAP = compute.computationSHAP(self.atk.dataset.X, self.atk.dataset.X_all, self.atk.dataset.model)\nwidgets.jslink((progress_shap, \"v_model\"), (compute_SHAP.progress_widget, \"v_model\"))\nwidgets.jslink((prog_shap.children[2].children[0], \"v_model\"), (compute_SHAP.text_widget, \"v_model\"))\nself.atk.explain[\"SHAP\"] = compute_SHAP.compute()\nelif self.__explanation == \"LIME\":\ncompute_LIME = compute.computationLIME(self.atk.dataset.X, self.atk.dataset.X_all, self.atk.dataset.model)\nwidgets.jslink((progress_shap, \"v_model\"), (compute_LIME.progress_widget, \"v_model\"))\nwidgets.jslink((prog_shap.children[2].children[0], \"v_model\"), (compute_LIME.text_widget, \"v_model\"))\nself.atk.explain[\"LIME\"] = compute_LIME.compute()\n# definition of the default projection\n# base, we take the PaCMAP projection\ninitial_choice_of_projection = [\"PCA\", \"t-SNE\", \"UMAP\", \"PaCMAP\"].index(self.__projectionVS) # string\nprog_red.children[2].children[0].v_model = \"Values space... \"\nself.dim_red[\"VS\"][self.__projectionVS] = compute.initialize_dim_red_VS(self.atk.dataset.X_scaled, self.__projectionVS)\nprogress_red.v_model = +50\nprog_red.children[2].children[0].v_model = \"Values space... Explanatory space...\"\nself.dim_red[\"ES\"][self.__explanation][self.__projectionES] = compute.initialize_dim_red_ES(self.atk.explain[self.__explanation], self.__projectionES)\nprogress_red.v_model = +50\n# once all this is done, the splash screen is removed\nsplash_screen.class_ = \"d-none\"\nloading_bar = v.ProgressCircular(\nindeterminate=True, color=\"blue\", width=\"6\", size=\"35\", class_=\"mx-4 my-3\"\n)\n# loading when we compute the projections\nout_loading1 = widgets.HBox([loading_bar])\nout_loading2 = widgets.HBox([loading_bar])\nout_loading1.layout.visibility = \"hidden\"\nout_loading2.layout.visibility = \"hidden\"\n# dropdown allowing to choose the projection in the value space\ndropdown_for_VS = v.Select(\nlabel=\"Projection in the VS:\",\nitems=[\"PCA\", \"t-SNE\", \"UMAP\", \"PaCMAP\"],\nstyle_=\"width: 150px\",\n)\ndropdown_for_VS.v_model = dropdown_for_VS.items[initial_choice_of_projection]\n# dropdown allowing to choose the projection in the space of the explanations\ndropdown_for_ES = v.Select(\nlabel=\"Projection in the ES:\",\nitems=[\"PCA\", \"t-SNE\", \"UMAP\", \"PaCMAP\"],\nstyle_=\"width: 150px\",\n)\ndropdown_for_ES.v_model = dropdown_for_ES.items[initial_choice_of_projection]\n# here the sliders of the parameters for the VS!\nslider_param_PaCMAP_neighbours_VS = gui_elements.SliderParam(v_model=10, min=5, max=30, step=1, label=\"Number of neighbors :\")\nslider_param_PaCMAP_mn_ratio_VS = gui_elements.SliderParam(v_model=0.5, min=0.1, max=0.9, step=0.1, label=\"MN ratio :\")\nslider_param_PaCMAP_fp_ratio_VS = gui_elements.SliderParam(v_model=2, min=0.1, max=5, step=0.1, label=\"FP ratio :\")\ndef function_update_sliderVS(widget, event, data):\n# function that updates the values \u200b\u200bwhen there is a change of sliders in the parameters of PaCMAP for the VS\nif widget.label == \"Number of neighbors :\":\nslider_param_PaCMAP_neighbours_VS.children[1].children = [str(data)]\nelif widget.label == \"MN ratio :\":\nslider_param_PaCMAP_mn_ratio_VS.children[1].children = [str(data)]\nelif widget.label == \"FP ratio :\":\nslider_param_PaCMAP_fp_ratio_VS.children[1].children = [str(data)]\nslider_param_PaCMAP_neighbours_VS.children[0].on_event(\n\"input\", function_update_sliderVS\n)\nslider_param_PaCMAP_mn_ratio_VS.children[0].on_event(\n\"input\", function_update_sliderVS\n)\nslider_param_PaCMAP_fp_ratio_VS.children[0].on_event(\n\"input\", function_update_sliderVS\n)\n# sliders parametres VS\nall_sliders_VS = widgets.VBox(\n[\nslider_param_PaCMAP_neighbours_VS,\nslider_param_PaCMAP_mn_ratio_VS,\nslider_param_PaCMAP_fp_ratio_VS,\n],\nlayout=Layout(width=\"100%\"),\n)\nvalidate_params_proj_VS = v.Btn(\nchildren=[\nv.Icon(left=True, children=[\"mdi-check\"]),\n\"Validate\",\n]\n)\nreset_params_proj_VS = v.Btn(\nclass_=\"ml-4\",\nchildren=[\nv.Icon(left=True, children=[\"mdi-skip-backward\"]),\n\"Reset\",\n],\n)\ntwo_buttons_params = widgets.HBox(\n[validate_params_proj_VS, reset_params_proj_VS]\n)\nparams_proj_VS = widgets.VBox(\n[all_sliders_VS, two_buttons_params], layout=Layout(width=\"100%\")\n)\ndef change_parameters_VS(*b):\n# function that updates the projections when changing the parameters of the projection\nn_neighbors = slider_param_PaCMAP_neighbours_VS.children[0].v_model\nMN_ratio = slider_param_PaCMAP_mn_ratio_VS.children[0].v_model\nFP_ratio = slider_param_PaCMAP_fp_ratio_VS.children[0].v_model\nout_loading1.layout.visibility = \"visible\"\ndim_red = compute.DimensionalityReductionChooser(method=\"PaCMAP\")\nself.dim_red['VS']['PaCMAP'] = [dim_red.compute(self.atk.dataset.X_scaled, 2, False, n_neighbors, MN_ratio, FP_ratio), dim_red.compute(self.atk.dataset.X_scaled, 3, False, n_neighbors, MN_ratio, FP_ratio)]\nout_loading1.layout.visibility = \"hidden\"\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\nvalidate_params_proj_VS.on_event(\"click\", change_parameters_VS)\ndef reset_param_VS(*b):\n# reset projection settings\nout_loading1.layout.visibility = \"visible\"\ndim_red = compute.DimensionalityReductionChooser(method=\"PaCMAP\")\nself.dim_red['VS']['PaCMAP'] = [dim_red.compute(self.atk.dataset.X_scaled, 2), dim_red.compute(self.atk.dataset.X_scaled, 3)]\nout_loading1.layout.visibility = \"hidden\"\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\nreset_params_proj_VS.on_event(\"click\", reset_param_VS)\n# here the sliders of the parameters for the ES!\nslider_param_PaCMAP_voisins_ES = gui_elements.SliderParam(v_model=10, min=5, max=30, step=1, label=\"Number of neighbors :\")\nslider_param_PaCMAP_mn_ratio_ES = gui_elements.SliderParam(v_model=0.5, min=0.1, max=0.9, step=0.1, label=\"MN ratio :\")\nslider_param_PaCMAP_fp_ratio_ES = gui_elements.SliderParam(v_model=2, min=0.1, max=5, step=0.1, label=\"FP ratio :\")\ndef function_update_sliderES(widget, event, data):\nif widget.label == \"Number of neighbors :\":\nslider_param_PaCMAP_voisins_ES.children[1].children = [str(data)]\nelif widget.label == \"MN ratio :\":\nslider_param_PaCMAP_mn_ratio_ES.children[1].children = [str(data)]\nelif widget.label == \"FP ratio :\":\nslider_param_PaCMAP_fp_ratio_ES.children[1].children = [str(data)]\nslider_param_PaCMAP_voisins_ES.children[0].on_event(\n\"input\", function_update_sliderES\n)\nslider_param_PaCMAP_mn_ratio_ES.children[0].on_event(\n\"input\", function_update_sliderES\n)\nslider_param_PaCMAP_fp_ratio_ES.children[0].on_event(\n\"input\", function_update_sliderES\n)\nall_sliders_ES = widgets.VBox(\n[\nslider_param_PaCMAP_voisins_ES,\nslider_param_PaCMAP_mn_ratio_ES,\nslider_param_PaCMAP_fp_ratio_ES,\n],\nlayout=Layout(\nwidth=\"100%\",\n),\n)\nvalidate_params_proj_ES = v.Btn(\nchildren=[\nv.Icon(left=True, children=[\"mdi-check\"]),\n\"Validate\",\n]\n)\nreset_params_proj_ES = v.Btn(\nclass_=\"ml-4\",\nchildren=[\nv.Icon(left=True, children=[\"mdi-skip-backward\"]),\n\"Reset\",\n],\n)\ntwo_buttons_params_ES = widgets.HBox(\n[validate_params_proj_ES, reset_params_proj_ES]\n)\nparams_proj_ES = widgets.VBox(\n[all_sliders_ES, two_buttons_params_ES],\nlayout=Layout(width=\"100%\", display=\"flex\", align_items=\"center\"),\n)\ndef change_params_ES(*b):\nn_neighbors = slider_param_PaCMAP_voisins_ES.children[0].v_model\nMN_ratio = slider_param_PaCMAP_mn_ratio_ES.children[0].v_model\nFP_ratio = slider_param_PaCMAP_fp_ratio_ES.children[0].v_model\nout_loading2.layout.visibility = \"visible\"\ndim_red_compute = compute.DimensionalityReductionChooser(method=\"PaCMAP\")\nself.dim_red[\"ES\"][self.__explanation][self.__projectionES] = [dim_red_compute.compute(self.atk.explain[self.__explanation], 2, False, n_neighbors, MN_ratio, FP_ratio), dim_red_compute.compute(self.atk.explain[self.__explanation], 3, False, n_neighbors, MN_ratio, FP_ratio)]\nout_loading2.layout.visibility = \"hidden\"\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\nvalidate_params_proj_ES.on_event(\"click\", change_params_ES)\ndef reset_param_ES(*b):\nout_loading2.layout.visibility = \"visible\"\ndim_red_compute = compute.DimensionalityReductionChooser(method=\"PaCMAP\")\nself.dim_red[\"ES\"][self.__explanation][self.__projectionES] = [dim_red_compute.compute(self.atk.explain[self.__explanation], 2), dim_red_compute.compute(self.atk.explain[self.__explanation], 3)]\nout_loading2.layout.visibility = \"hidden\"\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\nreset_params_proj_ES.on_event(\"click\", reset_param_ES)\n# allows you to choose the color of the points\n# y, y hat, residuals, current selection, regions, unselected points, automatic clustering\nradio_buttons_for_color_choice = gui_elements.color_choice()\ndef function_change_color(*args, opacity: bool = True):\n# allows you to change the color of the points when you click on the buttons\ncolor = None\nscale = True\nto_modify = True\nif radio_buttons_for_color_choice.v_model == \"y\":\ncolor = self.atk.dataset.y\nelif radio_buttons_for_color_choice.v_model == \"y^\":\ncolor = self.atk.dataset.y_pred\nelif radio_buttons_for_color_choice.v_model == \"Selec actuelle\":\nscale = False\ncolor = [\"grey\"] * len(self.atk.dataset.X)\nfor i in range(len(self.selection.indexes)):\ncolor[self.selection.indexes[i]] = \"blue\"\nelif radio_buttons_for_color_choice.v_model == \"R\u00e9sidus\":\ncolor = self.atk.dataset.y - self.atk.dataset.y_pred\ncolor = [abs(i) for i in color]\nelif radio_buttons_for_color_choice.v_model == \"R\u00e9gions\":\nscale = False\ncolor = [0] * len(self.atk.dataset.X)\nfor i in range(len(self.atk.dataset.X)):\nfor j in range(len(self.atk.regions)):\nif i in self.atk.regions[j].indexes:\ncolor[i] = j + 1\nelif radio_buttons_for_color_choice.v_model == \"Non selec\":\nscale = False\ncolor = [\"red\"] * len(self.atk.dataset.X)\nif len(self.atk.regions) &gt; 0:\nfor i in range(len(self.atk.dataset.X)):\nfor j in range(len(self.atk.regions)):\nif i in self.atk.regions[j].indexes:\ncolor[i] = \"grey\"\nelif radio_buttons_for_color_choice.v_model == \"Clustering auto\":\ncolor = self.__labels_automatic_clustering\nto_modify = False\nscale = False\nwith self.fig1.batch_update():\nself.fig1.data[0].marker.color = color\nif color is not None:\nself.fig1.data[0].customdata= color\nelse:\nself.fig1.data[0].customdata= [None]*len(self.atk.dataset.X)\nif opacity:\nself.fig1.data[0].marker.opacity = 1\nwith self.fig2.batch_update():\nself.fig2.data[0].marker.color = color\nif opacity:\nself.fig2.data[0].marker.opacity = 1\nif color is not None:\nself.fig2.data[0].customdata= color\nelse:\nself.fig2.data[0].customdata= [None]*len(self.atk.dataset.X)\nwith self.fig1_3D.batch_update():\nself.fig1_3D.data[0].marker.color = color\nif color is not None:\nself.fig1_3D.data[0].customdata= color\nelse:\nself.fig1_3D.data[0].customdata= [None]*len(self.atk.dataset.X)\nwith self.fig2_3D.batch_update():\nself.fig2_3D.data[0].marker.color = color\nif color is not None:\nself.fig2_3D.data[0].customdata= color\nelse:\nself.fig2_3D.data[0].customdata= [None]*len(self.atk.dataset.X)\nif scale:\nself.fig1.update_traces(marker=dict(showscale=True))\nself.fig1_3D.update_traces(marker=dict(showscale=True))\nself.fig1.data[0].marker.colorscale = \"Viridis\"\nself.fig1_3D.data[0].marker.colorscale = \"Viridis\"\nself.fig2.data[0].marker.colorscale = \"Viridis\"\nself.fig2_3D.data[0].marker.colorscale = \"Viridis\"\nelse:\nself.fig1.update_traces(marker=dict(showscale=False))\nself.fig1_3D.update_traces(marker=dict(showscale=False))\nif to_modify:\nself.fig1.data[0].marker.colorscale = \"Plasma\"\nself.fig1_3D.data[0].marker.colorscale = \"Plasma\"\nself.fig2.data[0].marker.colorscale = \"Plasma\"\nself.fig2_3D.data[0].marker.colorscale = \"Plasma\"\nelse:\nself.fig1.data[0].marker.colorscale = \"Viridis\"\nself.fig1_3D.data[0].marker.colorscale = \"Viridis\"\nself.fig2.data[0].marker.colorscale = \"Viridis\"\nself.fig2_3D.data[0].marker.colorscale = \"Viridis\"\nradio_buttons_for_color_choice.on_event(\"change\", function_change_color)\n# marker 1 is the marker of figure 1\nmarker1 = dict(\ncolor=self.atk.dataset.y,\ncolorscale=\"Viridis\",\ncolorbar=dict(\ntitle=\"y\",\nthickness=20,\n),\n)\n# marker 2 is the marker of figure 2 (without colorbar therefore)\nmarker2 = dict(color=self.atk.dataset.y, colorscale=\"Viridis\")\nbarre_menu, fig_size, bouton_save = gui_elements.create_menu_bar()\n# for the part on backups\ninit_len_saves = deepcopy(len(self.atk.saves))\ndef init_save(save):\ntext_regions = \"There is no backup\"\nif len(save) &gt; 0:\ntext_regions = str(len(save)) + \" save(s) found\"\ntable_save = []\nfor i in range(len(save)):\nnew_or_not = \"Imported\"\nif i &gt; init_len_saves:\nnew_or_not = \"Created\"\ntable_save.append(\n[\ni + 1,\nsave[i][\"name\"],\nnew_or_not,\nlen(save[i][\"regions\"]),\n]\n)\ntable_save = pd.DataFrame(\ntable_save,\ncolumns=[\n\"Save #\",\n\"Name\",\n\"Origin\",\n\"Number of regions\",\n],\n)\ncolumns = [\n{\"text\": c, \"sortable\": True, \"value\": c} for c in table_save.columns\n]\ntable_save = v.DataTable(\nv_model=[],\nshow_select=True,\nsingle_select=True,\nheaders=columns,\nitems=table_save.to_dict(\"records\"),\nitem_value=\"Save #\",\nitem_key=\"Save #\",\n)\nreturn [table_save, text_regions]\n# the table that contains the backups\nself.__table_save = init_save(self.atk.saves)[0]\n# initialize the save menu !\ndialogue_save, card_save, delete_save, name_save, visualize_chosen_save, new_save = gui_elements.dialog_save(bouton_save, init_save(self.atk.saves)[1], self.__table_save, self.atk)\n# save a backup\ndef delete_save_function(*args):\nif self.__table_save.v_model == []:\nreturn\nself.__table_save = card_save.children[1]\nindex = self.__table_save.v_model[0][\"Save #\"] - 1\nself.atk.saves.pop(index)\nself.__table_save, text = init_save(self.atk.saves)\ncard_save.children = [text, self.__table_save] + card_save.children[\n2:\n]\ndelete_save.on_event(\"click\", delete_save_function)\n# to view a backup\ndef function_visu_save(*args):\nself.__table_save = card_save.children[1]\nif len(self.__table_save.v_model) == 0:\nreturn\nindex = self.__table_save.v_model[0][\"Save #\"] - 1\nself.atk.regions = [element for element in self.atk.saves[index][\"regions\"]]\ncolor = deepcopy(self.atk.saves[index][\"labels\"])\nself.__color_regions = deepcopy(color)\nwith self.fig1.batch_update():\nself.fig1.data[0].marker.color = color\nself.fig1.data[0].marker.opacity = 1\nwith self.fig2.batch_update():\nself.fig2.data[0].marker.color = color\nself.fig2.data[0].marker.opacity = 1\nwith self.fig1_3D.batch_update():\nself.fig1_3D.data[0].marker.color = color\nwith self.fig2_3D.batch_update():\nself.fig2_3D.data[0].marker.color = color\nradio_buttons_for_color_choice.v_model = \"R\u00e9gions\"\nself.fig1.update_traces(marker=dict(showscale=False))\nself.fig2.update_traces(marker=dict(showscale=False))\nfunction_new_region()\nvisualize_chosen_save.on_event(\"click\", function_visu_save)\n# create a new savegame with the current regions\ndef function_new_save(*args):\nif len(name_save.v_model) == 0 or len(name_save.v_model) &gt; 25:\nraise Exception(\"The name of the save must be between 1 and 25 characters !\")\nsave1 = {\"regions\": self.atk.regions, \"labels\": self.__color_regions,\"name\": name_save.v_model}\nsave = {key: value[:] for key, value in save1.items()}\nself.atk.saves.append(save)\nself.__table_save, text_region = init_save(self.atk.saves)\ncard_save.children = [text_region, self.__table_save] + card_save.children[2:]\nnew_save.on_event(\"click\", function_new_save)\n# value space graph\nself.fig1 = go.FigureWidget(\ndata=go.Scatter(x=[1], y=[1], mode=\"markers\", marker=marker1, customdata=marker1[\"color\"], hovertemplate = '%{customdata:.3f}')\n)\n# to remove the plotly logo\nself.fig1._config = self.fig1._config | {\"displaylogo\": False}\n# border size\nM = 40\nself.fig1.update_layout(margin=dict(l=M, r=M, t=0, b=M), width=int(fig_size.v_model))\nself.fig1.update_layout(dragmode=\"lasso\")\n# grapbique de l'espace des explications\nself.fig2 = go.FigureWidget(\ndata=go.Scatter(x=[1], y=[1], mode=\"markers\", marker=marker2, customdata=marker2[\"color\"], hovertemplate = '%{customdata:.3f}')\n)\nself.fig2.update_layout(margin=dict(l=M, r=M, t=0, b=M), width=int(fig_size.v_model))\nself.fig2.update_layout(dragmode=\"lasso\")\nself.fig2._config = self.fig2._config | {\"displaylogo\": False}\n# two checkboxes to choose the projection dimension of figures 1 and 2\ndimension_projection = v.Switch(\nclass_=\"ml-3 mr-2\",\nv_model=False,\nlabel=\"\",\n)\ndimension_projection_text = v.Row(\nclass_=\"ma-3\",\nchildren=[\nv.Icon(children=[\"mdi-numeric-2-box\"]),\nv.Icon(children=[\"mdi-alpha-d-box\"]),\ndimension_projection,\nv.Icon(children=[\"mdi-numeric-3-box\"]),\nv.Icon(children=[\"mdi-alpha-d-box\"]),\n],\n)\ndimension_projection_text = add_tooltip(\ndimension_projection_text, \"Dimension of the projection\"\n)\ndef function_dimension_projection(*args):\nif dimension_projection.v_model:\nfig_2D_ou_3D.children = [fig1_3D_and_text, fig2_3D_and_text]\nelse:\nfig_2D_ou_3D.children = [fig1_and_text, fig2_and_text]\ndimension_projection.on_event(\"change\", function_dimension_projection)\n# marker 3D is the marker of figure 1 in 3D\nmarker_3D = dict(\ncolor=self.atk.dataset.y,\ncolorscale=\"Viridis\",\ncolorbar=dict(\nthickness=20,\n),\nsize=3,\n)\n# marker 3D_2 is the marker of figure 2 in 3D (without the colorbar therefore!)\nmarker_3D_2 = dict(color=self.atk.dataset.y, colorscale=\"Viridis\", size=3)\nself.fig1_3D = go.FigureWidget(\ndata=go.Scatter3d(\nx=[1], y=[1], z=[1], mode=\"markers\", marker=marker_3D,  customdata=marker_3D[\"color\"], hovertemplate = '%{customdata:.3f}'\n)\n)\nself.fig1_3D.update_layout(\nmargin=dict(l=M, r=M, t=0, b=M),\nwidth=int(fig_size.v_model),\nscene=dict(aspectmode=\"cube\"),\ntemplate=\"none\",\n)\nself.fig1_3D._config = self.fig1_3D._config | {\"displaylogo\": False}\nself.fig2_3D = go.FigureWidget(\ndata=go.Scatter3d(\nx=[1], y=[1], z=[1], mode=\"markers\", marker=marker_3D_2, customdata=marker_3D_2[\"color\"], hovertemplate = '%{customdata:.3f}'\n)\n)\nself.fig2_3D.update_layout(\nmargin=dict(l=M, r=M, t=0, b=M),\nwidth=int(fig_size.v_model),\nscene=dict(aspectmode=\"cube\"),\ntemplate=\"none\",\n)\nself.fig2_3D._config = self.fig2_3D._config | {\"displaylogo\": False}\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\n# text that indicate spaces for better understanding\ntextVS = widgets.HTML(\"&lt;h3&gt;Values Space&lt;h3&gt;\")\ntextES = widgets.HTML(\"&lt;h3&gt;Explanatory Space&lt;h3&gt;\")\n# we display the figures and the text above!\nfig1_and_text = gui_elements.figure_and_text(self.fig1, textVS)\nfig2_and_text = gui_elements.figure_and_text(self.fig2, textES)\nfig1_3D_and_text = gui_elements.figure_and_text(self.fig1_3D, textVS)\nfig2_3D_and_text = gui_elements.figure_and_text(self.fig2_3D, textES)\n# HBox which allows you to choose between 2D and 3D figures by changing its children parameter!\nfig_2D_ou_3D = widgets.HBox([fig1_and_text, fig2_and_text])\n# allows to update graphs 1 &amp; 2 according to the chosen projection\ndef update_scatter(*args):\nself.__projectionVS = deepcopy(dropdown_for_VS.v_model)\nself.__projectionES = deepcopy(dropdown_for_ES.v_model)\nif self.dim_red[\"VS\"][dropdown_for_VS.v_model] is None:\nout_loading1.layout.visibility = \"visible\"\ndim_red_compute = compute.DimensionalityReductionChooser(method=dropdown_for_VS.v_model)\nself.dim_red[\"VS\"][dropdown_for_VS.v_model] = [dim_red_compute.compute(self.atk.dataset.X_scaled, 2), dim_red_compute.compute(self.atk.dataset.X_scaled, 3)]\nout_loading1.layout.visibility = \"hidden\"\nif self.dim_red[\"ES\"][self.__explanation][dropdown_for_ES.v_model] is None:\nout_loading2.layout.visibility = \"visible\"\ndim_red_compute = compute.DimensionalityReductionChooser(method=dropdown_for_ES.v_model)\nself.dim_red[\"ES\"][self.__explanation][dropdown_for_ES.v_model] = [dim_red_compute.compute(self.atk.explain[self.__explanation], 2), dim_red_compute.compute(self.atk.explain[self.__explanation], 3)]\nout_loading2.layout.visibility = \"hidden\"\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\n# for the parameters of the projection\nif dropdown_for_VS.v_model == \"PaCMAP\":\nparam_VS.v_slots[0][\"children\"].disabled = False\nelse:\nparam_VS.v_slots[0][\"children\"].disabled = True\nif dropdown_for_ES.v_model == \"PaCMAP\":\nparam_ES.v_slots[0][\"children\"].disabled = False\nelse:\nparam_ES.v_slots[0][\"children\"].disabled = True\ndropdown_for_VS.v_model = self.__projectionVS\ndropdown_for_ES.v_model = self.__projectionES\n# we observe the changes in the values \u200b\u200bof the dropdowns to change the method of reduction\ndropdown_for_VS.on_event(\"change\", update_scatter)\ndropdown_for_ES.on_event(\"change\", update_scatter)\nself.__color_regions = [0] * len(self.atk.dataset.X)\n# definition of the table that will show the different results of the regions, with a stat of info about them\ntable_regions = widgets.Output()\n# definition of the text that will give information on the selection\ntext_base, text_base_debut, text_selec, card_selec, button_validate_skope, button_reset_skope = gui_elements.create_selection_card()\ntext_skope, text_skopeES, text_skopeVS, one_card_VS, one_card_ES = gui_elements.create_card_skope()\n# texts that will contain the information on the self.sub_models\nmods = gui_elements.create_slide_sub_models(self)\ndef change(widget, event, data, args: bool = True):\nif args == True:\nfor i in range(len(mods.children)):\nmods.children[i].children[0].color = \"white\"\nwidget.color = \"blue lighten-4\"\nfor i in range(len(mods.children)):\nif mods.children[i].children[0].color == \"blue lighten-4\":\nself.__model_index = i\nfor i in range(len(mods.children)):\nmods.children[i].children[0].on_event(\"click\", change)\nvalidate_one_region, supprimer_toutes_les_tuiles, selection = gui_elements.create_buttons_regions()\n# we define the sliders used to modify the histogram resulting from the skope\nslider_skope1, button_in_real_time_graph1, slider_text_comb1 = gui_elements.slider_skope()\nslider_skope2, button_in_real_time_graph2, slider_text_comb2 = gui_elements.slider_skope()\nslider_skope3, button_in_real_time_graph3, slider_text_comb3 = gui_elements.slider_skope()\n# if \"in real-time\" is checked, no need to validate the changes!\ndef update_validate1(*args):\nif button_in_real_time_graph1.v_model:\nvalidate_change_1.disabled = True\nelse:\nvalidate_change_1.disabled = False\nbutton_in_real_time_graph1.on_event(\"change\", update_validate1)\ndef update_validate2(*args):\nif button_in_real_time_graph2.value:\nvalidate_change_2.disabled = True\nelse:\nvalidate_change_2.disabled = False\nbutton_in_real_time_graph2.on_event(\"change\", update_validate2)\ndef update_validate3(*args):\nif button_in_real_time_graph3.v_model:\nvalidate_change_3.disabled = True\nelse:\nvalidate_change_3.disabled = False\nbutton_in_real_time_graph3.on_event(\"change\", update_validate3)\n# valid buttons definition changes:\ndef validate_change():\nwidget = v.Btn(\nclass_=\"ma-3\",\nchildren=[\nv.Icon(class_=\"mr-2\", children=[\"mdi-check\"]),\n\"Validate the changes\",\n],\n)\nreturn widget\nvalidate_change_1 = validate_change()\nvalidate_change_2 = validate_change()\nvalidate_change_3 = validate_change()\n# we wrap the validation button and the checkbox which allows you to view in real time\ntwo_end1 = widgets.HBox([validate_change_1, button_in_real_time_graph1])\ntwo_end2 = widgets.HBox([validate_change_2, button_in_real_time_graph2])\ntwo_end3 = widgets.HBox([validate_change_3, button_in_real_time_graph3])\n# we define the number of bars of the histogram\nnumber_of_bins_histograms = 50\n# we define the histograms\n[histogram1, histogram2, histogram3] = gui_elements.create_histograms(number_of_bins_histograms, fig_size.v_model)\nhistogram1 = deepcopy(histogram1)\nhistogram2 = deepcopy(histogram2)\nhistogram3 = deepcopy(histogram3)\nall_histograms = [histogram1, histogram2, histogram3]\n# definitions of the different color choices for the swarm\n[total_beeswarm_1, total_beeswarm_2, total_beeswarm_3] = gui_elements.create_beeswarms(self, self.__explanation, fig_size.v_model)\nchoice_color_beeswarm1 = total_beeswarm_1.children[0]\nchoice_color_beeswarm2 = total_beeswarm_2.children[0]\nchoice_color_beeswarm3 = total_beeswarm_3.children[0]\nbeeswarm1 = total_beeswarm_1.children[1]\nbeeswarm2 = total_beeswarm_2.children[1]\nbeeswarm3 = total_beeswarm_3.children[1]\n# update the beeswarm plots\ndef change_color_beeswarm_shap1(*args):\nif choice_color_beeswarm1.children[1].v_model == False:\nmarker = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[0][2])[1]\nbeeswarm1.data[0].marker = marker\nbeeswarm1.update_traces(marker=dict(showscale=True))\nelse:\nmodifie_all_histograms(\nslider_skope1.v_model[0]  , slider_skope1.v_model[1]  , 0\n)\nbeeswarm1.update_traces(marker=dict(showscale=False))\nchoice_color_beeswarm1.children[1].on_event(\n\"change\", change_color_beeswarm_shap1\n)\ndef change_color_beeswarm_shap2(*args):\nif choice_color_beeswarm2.children[1].v_model == False:\nmarker = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[1][2])[1]\nbeeswarm2.data[0].marker = marker\nbeeswarm2.update_traces(marker=dict(showscale=True))\nelse:\nmodifie_all_histograms(\nslider_skope2.v_model[0]  , slider_skope2.v_model[1]  , 1\n)\nbeeswarm2.update_traces(marker=dict(showscale=False))\nchoice_color_beeswarm2.children[1].on_event(\n\"change\", change_color_beeswarm_shap2\n)\ndef change_color_beeswarm_shap3(*args):\nif choice_color_beeswarm3.children[1].v_model == False:\nmarker = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[2][2])[1]\nbeeswarm3.data[0].marker = marker\nbeeswarm3.update_traces(marker=dict(showscale=True))\nelse:\nmodifie_all_histograms(\nslider_skope3.v_model[0]  , slider_skope3.v_model[1]  , 2\n)\nbeeswarm3.update_traces(marker=dict(showscale=False))\nchoice_color_beeswarm3.children[1].on_event(\n\"change\", change_color_beeswarm_shap3\n)\nall_beeswarms_total = [total_beeswarm_1, total_beeswarm_2, total_beeswarm_3]\nall_beeswarms = [beeswarm1, beeswarm2, beeswarm3]\nall_color_choosers_beeswarms = [\nchoice_color_beeswarm1,\nchoice_color_beeswarm2,\nchoice_color_beeswarm3,\n]\n# set of elements that contain histograms and sliders\nall_widgets_slider_histo1 = widgets.VBox([slider_text_comb1, histogram1, two_end1])\nall_widgets_slider_histo2 = widgets.VBox([slider_text_comb2, histogram2, two_end2])\nall_widgets_slider_histo3 = widgets.VBox([slider_text_comb3, histogram3, two_end3])\n# definition of buttons to delete features (disabled for the first 3 for the moment)\nb_delete_skope1 = gui_elements.button_delete_skope()\nb_delete_skope2 = gui_elements.button_delete_skope()\nb_delete_skope3 = gui_elements.button_delete_skope()\n# checkbow to know if the feature is continuous or not\nis_continuous_1 = v.Checkbox(v_model=True, label=\"is continuous?\")\nis_continuous_2 = v.Checkbox(v_model=True, label=\"is continuous?\")\nis_continuous_3 = v.Checkbox(v_model=True, label=\"is continuous?\")\n# the right side of the features : button to delete the feature from the rules + checkbox \"is continuous?\"\nright_side_1 = v.Col(children=[b_delete_skope1, is_continuous_1], class_=\"d-flex flex-column align-center justify-center\")\nright_side_2 = v.Col(children=[b_delete_skope2, is_continuous_2], class_=\"d-flex flex-column align-center justify-center\")\nright_side_3 = v.Col(children=[b_delete_skope3, is_continuous_3], class_=\"d-flex flex-column align-center justify-center\")\nself.__all_widgets_class_1 = gui_elements.create_class_selector(self, self.atk.dataset.X.columns[0])\nself.__all_widgets_class_2 = gui_elements.create_class_selector(self, self.atk.dataset.X.columns[0])\nself.__all_widgets_class_3 = gui_elements.create_class_selector(self, self.atk.dataset.X.columns[0])\n# when teh user checks the fact that this feature \ndef change_continuous1(widget, event, data):\nif widget.v_model == True and widget == right_side_1.children[1]:\nin_accordion1.children = [all_widgets_slider_histo1] + list(in_accordion1.children[1:])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == self.selection.rules[0][2] and i-count != 0:\nself.selection.rules.pop(i-count)\ncount += 1\nself.selection.rules[0][0] = slider_skope1.v_model[0]\nself.selection.rules[0][4] = slider_skope1.v_model[1]\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nelse:\nin_accordion1.children = [self.__all_widgets_class_1] + list(in_accordion1.children[1:])\nl = []\nfor i in range(len(self.__all_widgets_class_1.children[2].children)):\nif self.__all_widgets_class_1.children[2].children[i].v_model:\nl.append(int(self.__all_widgets_class_1.children[2].children[i].label))\nif len(l) == 0:\nwidget.v_model = True\nreturn\ncolumn = deepcopy(self.selection.rules[0][2])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == column:\nself.selection.rules.pop(i-count)\ncount += 1\ncroissant = 0\nfor ele in l:\nself.selection.rules.insert(0+croissant, [ele-0.5, '&lt;=', column, '&lt;=', ele+0.5])\ncroissant += 1\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules), is_class=True)\nupdate_all_graphs()\ndef change_continuous2(widget, event, data):\nfeatures = [self.selection.rules[i][2] for i in range(len(self.selection.rules))]\nthe_set = []\nfor i in range(len(features)):\nif features[i] not in the_set:\nthe_set.append(features[i])\nindex = features.index(the_set[1])\nif widget.v_model and widget == right_side_2.children[1]:\nin_accordion2.children = [all_widgets_slider_histo2] + list(in_accordion2.children[1:])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == self.selection.rules[index][2] and i-count != index:\nself.selection.rules.pop(i-count)\ncount += 1\nself.selection.rules[index][0] = slider_skope2.v_model[0]\nself.selection.rules[index][4] = slider_skope2.v_model[1]\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nelse:\nin_accordion2.children = [self.__all_widgets_class_2] + list(in_accordion2.children[1:])\nl = []\nfor i in range(len(self.__all_widgets_class_2.children[2].children)):\nif self.__all_widgets_class_2.children[2].children[i].v_model:\nl.append(int(self.__all_widgets_class_2.children[2].children[i].label))\nif len(l) == 0:\nwidget.v_model = True\nreturn\ncolumn = deepcopy(self.selection.rules[index][2])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == column:\nself.selection.rules.pop(i-count)\ncount += 1\ncroissant = 0\nfor ele in l:\nself.selection.rules.insert(index+croissant, [ele-0.5, '&lt;=', column, '&lt;=', ele+0.5])\ncroissant += 1\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules), is_class=True)\nupdate_all_graphs()\ndef change_continuous3(widget, event, data):\nfeatures = [self.selection.rules[i][2] for i in range(len(self.selection.rules))]\nthe_set = []\nfor i in range(len(features)):\nif features[i] not in the_set:\nthe_set.append(features[i])\nindex = features.index(the_set[2])\nif widget.v_model and widget == right_side_3.children[1]:\nin_accordion3.children = [all_widgets_slider_histo3] + list(in_accordion3.children[1:])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == self.selection.rules[index][2] and i-count != index:\nself.selection.rules.pop(i-count)\ncount += 1\nself.selection.rules[index][0] = slider_skope3.v_model[0]\nself.selection.rules[index][4] = slider_skope3.v_model[1]\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nelse:\nin_accordion3.children = [self.__all_widgets_class_3] + list(in_accordion3.children[1:])\nl = []\nfor i in range(len(self.__all_widgets_class_3.children[2].children)):\nif self.__all_widgets_class_3.children[2].children[i].v_model:\nl.append(int(self.__all_widgets_class_3.children[2].children[i].label))\nif len(l) == 0:\nwidget.v_model = True\nreturn\ncolumn = deepcopy(self.selection.rules[index][2])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == column:\nself.selection.rules.pop(i-count)\ncount += 1\ncroissant = 0\nfor ele in l:\nself.selection.rules.insert(index+croissant, [ele-0.5, '&lt;=', column, '&lt;=', ele+0.5])\ncroissant += 1\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules), is_class=True)\nupdate_all_graphs()\n# the \"is continuous\" checkbox\nright_side_1.children[1].on_event(\"change\", change_continuous1)\nright_side_2.children[1].on_event(\"change\", change_continuous2)\nright_side_3.children[1].on_event(\"change\", change_continuous3)\nin_accordion1 = widgets.HBox(\n[all_widgets_slider_histo1, total_beeswarm_1, right_side_1],\nlayout=Layout(align_items=\"center\"),\n)\nin_accordion2 = widgets.HBox(\n[all_widgets_slider_histo2, total_beeswarm_2, right_side_2],\nlayout=Layout(align_items=\"center\"),\n)\nin_accordion3 = widgets.HBox(\n[all_widgets_slider_histo3, total_beeswarm_3, right_side_3],\nlayout=Layout(align_items=\"center\"),\n)\n# we define several accordions in this way to be able to open several at the same time\nin_accordion1_n = gui_elements.accordion_skope(\"X1\", in_accordion1)\nin_accordion2_n = gui_elements.accordion_skope(\"X2\", in_accordion2)\nin_accordion3_n = gui_elements.accordion_skope(\"X3\", in_accordion3)\naccordion_skope = widgets.VBox(\nchildren=[in_accordion1_n, in_accordion2_n, in_accordion3_n],\nlayout=Layout(width=\"100%\", height=\"auto\"),\n)\n# allows you to take the set of rules and modify the graph so that it responds to everything!\ndef update_all_graphs():\nself.selection.state = Potato.REFINED_SKR\n\"\"\"\n        new_tuile = self.atk.dataset.X[\n            (self.atk.dataset.X[self.selection.rules[0][2]] &gt;= self.selection.rules[0][0])\n            &amp; (self.atk.dataset.X[self.selection.rules[0][2]] &lt;= self.selection.rules[0][4])\n        ].index\n        for i in range(1, len(self.selection.rules)):\n            X_temp = self.atk.dataset.X[\n                (self.atk.dataset.X[self.selection.rules[i][2]] &gt;= self.selection.rules[i][0])\n                &amp; (self.atk.dataset.X[self.selection.rules[i][2]] &lt;= self.selection.rules[i][4])\n            ].index\n            new_tuile = [g for g in new_tuile if g in X_temp]\n        \"\"\"\nnew_tuile = self.selection.applyRules(to_return=True)\ny_shape_skope = []\ny_color_skope = []\ny_opa_skope = []\nfor i in range(len(self.atk.dataset.X)):\nif i in new_tuile:\ny_shape_skope.append(\"circle\")\ny_color_skope.append(\"blue\")\ny_opa_skope.append(0.5)\nelse:\ny_shape_skope.append(\"cross\")\ny_color_skope.append(\"grey\")\ny_opa_skope.append(0.5)\nwith self.fig1.batch_update():\nself.fig1.data[0].marker.color = y_color_skope\nwith self.fig2.batch_update():\nself.fig2.data[0].marker.color = y_color_skope\nwith self.fig1_3D.batch_update():\nself.fig1_3D.data[0].marker.color = y_color_skope\nwith self.fig2_3D.batch_update():\nself.fig2_3D.data[0].marker.color = y_color_skope\n# allows to modify all the histograms according to the rules\ndef modifie_all_histograms(value_min, value_max, index):\nnew_list_tout = self.atk.dataset.X.index[\nself.atk.dataset.X[self.selection.rules[index][2]].between(value_min, value_max)\n].tolist()\nfor i in range(len(self.selection.rules)):\nmin = self.selection.rules[i][0]\nmax = self.selection.rules[i][4]\nif i != index:\nnew_list_temp = self.atk.dataset.X.index[\nself.atk.dataset.X[self.selection.rules[i][2]].between(min, max)\n].tolist()\nnew_list_tout = [g for g in new_list_tout if g in new_list_temp]\nif self.selection.indexes_from_map is not None:\nnew_list_tout = [g for g in new_list_tout if g in self.selection.indexes_from_map]\nfor i in range(len(self.selection.rules)):\nwith all_histograms[i].batch_update():\nall_histograms[i].data[2].x = self.atk.dataset.X[self.selection.rules[i][2]][new_list_tout]\nif all_color_choosers_beeswarms[i].children[1].v_model:\nwith all_beeswarms[i].batch_update():\ny_color = [0] * len(self.atk.explain[self.__explanation])\nif i == index:\nindexs = self.atk.dataset.X.index[\nself.atk.dataset.X[self.selection.rules[i][2]].between(value_min, value_max)\n].tolist()\nelse:\nindexs = self.atk.dataset.X.index[\nself.atk.dataset.X[self.selection.rules[i][2]].between(\nself.selection.rules[i][0], self.selection.rules[i][4]\n)\n].tolist()\nfor j in range(len(self.atk.explain[self.__explanation])):\nif j in new_list_tout:\ny_color[j] = \"blue\"\nelif j in indexs:\ny_color[j] = \"#85afcb\"\nelse:\ny_color[j] = \"grey\"\nall_beeswarms[i].data[0].marker.color = y_color\n# when the value of a slider is modified, the histograms and graphs are modified\ndef on_value_change_skope1(widget, event, data):\nif widget.__class__.__name__ == \"RangeSlider\":\nslider_text_comb1.children[0].v_model = slider_skope1.v_model[0]\nslider_text_comb1.children[2].v_model = slider_skope1.v_model[1]\nelse :\nif slider_text_comb1.children[0].v_model == '' or slider_text_comb1.children[2].v_model == '':\nreturn\nelse:\nslider_skope1.v_model = [float(slider_text_comb1.children[0].v_model), float(slider_text_comb1.children[2].v_model)]\nnew_list = [\ng\nfor g in list(self.atk.dataset.X[self.selection.rules[0][2]].values)\nif g &gt;= slider_skope1.v_model[0]\nand g &lt;= slider_skope1.v_model[1]\n]\nwith histogram1.batch_update():\nhistogram1.data[1].x = new_list\nif self.__activate_histograms:\nmodifie_all_histograms(\nslider_skope1.v_model[0], slider_skope1.v_model[1], 0\n)\nif button_in_real_time_graph1.v_model:\n#self.selection.rules[0][0] = float(deepcopy(slider_skope1.v_model[0]))\n#self.selection.rules[0][4] = float(deepcopy(slider_skope1.v_model[1]))\nself.selection.rules[0][0] = float(deepcopy(slider_skope1.v_model[0]))\nself.selection.rules[0][4] = float(deepcopy(slider_skope1.v_model[1]))\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\ndef on_value_change_skope2(widget, event, data):\nif widget.__class__.__name__ == \"RangeSlider\":\nslider_text_comb2.children[0].v_model = slider_skope2.v_model[0]  \nslider_text_comb2.children[2].v_model = slider_skope2.v_model[1]  \nnew_list = [\ng\nfor g in list(self.atk.dataset.X[self.selection.rules[1][2]].values)\nif g &gt;= slider_skope2.v_model[0]  \nand g &lt;= slider_skope2.v_model[1]  \n]\nwith histogram2.batch_update():\nhistogram2.data[1].x = new_list\nif self.__activate_histograms:\nmodifie_all_histograms(\nslider_skope2.v_model[0]  , slider_skope2.v_model[1]  , 1\n)\nif button_in_real_time_graph2.v_model:\nself.selection.rules[1][0] = float(deepcopy(slider_skope2.v_model[0]  ))\nself.selection.rules[1][4] = float(deepcopy(slider_skope2.v_model[1]  ))\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\ndef on_value_change_skope3(widget, event, data):\nif widget.__class__.__name__ == \"RangeSlider\":\nslider_text_comb3.children[0].v_model = slider_skope3.v_model[0]  \nslider_text_comb3.children[2].v_model = slider_skope3.v_model[1]  \nnew_list = [\ng\nfor g in list(self.atk.dataset.X[self.selection.rules[2][2]].values)\nif g &gt;= slider_skope3.v_model[0]  \nand g &lt;= slider_skope3.v_model[1]  \n]\nwith histogram3.batch_update():\nhistogram3.data[1].x = new_list\nif self.__activate_histograms:\nmodifie_all_histograms(\nslider_skope3.v_model[0]  , slider_skope3.v_model[1]  , 2\n)\nif button_in_real_time_graph3.v_model:\nself.selection.rules[2][0] = float(deepcopy(slider_skope3.v_model[0]  ))\nself.selection.rules[2][4] = float(deepcopy(slider_skope3.v_model[1]  ))\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\ndef liste_to_string_skope(liste, is_class=False):\nchaine = \"\"\nfor rule in liste:\nfor i in range(len(rule)):\nif type(rule[i]) == float:\nchaine += str(np.round(float(rule[i]), 2))\nelif rule[i] is None:\nchaine += \"None\"\nelif type(rule[i]) == list:\nchaine+=\"{\"\nchaine += str(rule[i][0])\nfor j in range(1, len(rule[i])):\nchaine += \",\" + str(rule[i][j])\nchaine+=\"}\"\nelse:\nchaine += str(rule[i])\nchaine += \" \"\nreturn chaine\n# cwhen the user validates the updates he makes on a rule\ndef function_change_validate_1(*change):\na = deepcopy(float(slider_skope1.v_model[0]))\nb = deepcopy(float(slider_skope1.v_model[1]))\nself.selection.rules[0][0] = a\nself.selection.rules[0][4] = b\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nfunction_scores_models(None)\ndef function_change_validate_2(*change):\nself.selection.rules[1][0] = float(slider_skope2.v_model[0])\nself.selection.rules[1][4] = float(slider_skope2.v_model[1])\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nfunction_scores_models(None)\ndef function_change_validate_3(*change):\nself.selection.rules[2][0] = float(slider_skope3.v_model[0])\nself.selection.rules[2][4] = float(slider_skope3.v_model[1])\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nfunction_scores_models(None)\nvalidate_change_1.on_event(\"click\", function_change_validate_1)\nvalidate_change_2.on_event(\"click\", function_change_validate_2)\nvalidate_change_3.on_event(\"click\", function_change_validate_3)\ndef rules_to_indexs():\nliste_bool = [True] * len(self.atk.dataset.X)\nfor i in range(len(self.atk.dataset.X)):\nfor j in range(len(self.selection.rules)):\ncolumn = list(self.atk.dataset.X.columns).index(self.selection.rules[j][2])\nif (\nself.selection.rules[j][0] &gt; self.atk.dataset.X.iloc[i, column]\nor self.atk.dataset.X.iloc[i, column] &gt; self.selection.rules[j][4]\n):\nliste_bool[i] = False\ntemp = [i for i in range(len(self.atk.dataset.X)) if liste_bool[i]]\nreturn temp\ndef function_scores_models(temp):\nif type(temp) == type(None):\ntemp = rules_to_indexs()\nresult_models = function_models(self.atk.dataset.X.iloc[temp, :], self.atk.dataset.y.iloc[temp], self.sub_models)\nscore_tot = []\nfor i in range(len(self.sub_models)):\nscore_tot.append(compute.function_score(self.atk.dataset.y.iloc[temp], result_models[i][-2]))\nscore_init = compute.function_score(self.atk.dataset.y.iloc[temp], self.atk.dataset.y_pred[temp])\nif score_init == 0:\nl_compar = [\"/\"] * len(self.sub_models)\nelse:\nl_compar = [\nround(100 * (score_init - score_tot[i]) / score_init, 1)\nfor i in range(len(self.sub_models))\n]\nself.__score_sub_models = []\nfor i in range(len(self.sub_models)):\nself.__score_sub_models.append(\n[\nscore_tot[i],\nscore_init,\nl_compar[i],\n]\n)\n# to generate a string for the scores\n# TODO: different score for the classification! Recall/precision!\ndef string_for_score(i):\nif score_tot[i] == 0:\nreturn (\n\"MSE = \"\n+ str(score_tot[i])\n+ \" (against \"\n+ str(score_init)\n+ \", +\"\n+ \"\u221e\"\n+ \"%)\"\n)\nelse:\nif round(100 * (score_init - score_tot[i]) / score_init, 1) &gt; 0:\nreturn (\n\"MSE = \"\n+ str(score_tot[i])\n+ \" (against \"\n+ str(score_init)\n+ \", +\"\n+ str(\nround(100 * (score_init - score_tot[i]) / score_init, 1)\n)\n+ \"%)\"\n)\nelse:\nreturn (\n\"MSE = \"\n+ str(score_tot[i])\n+ \" (against \"\n+ str(score_init)\n+ \", \"\n+ str(\nround(100 * (score_init - score_tot[i]) / score_init, 1)\n)\n+ \"%)\"\n)\nfor i in range(len(self.sub_models)):\nmods.children[i].children[0].children[1].children = string_for_score(i)\n# when you click on the skope-rules button\ndef function_validation_skope(*sender):\nloading_models.class_ = \"d-flex\"\nself.__activate_histograms = True\nif self.selection.y_train == None:\ntext_skopeVS.children[1].children = [\nwidgets.HTML(\"Please select points\")\n]\ntext_skopeES.children[1].children = [\nwidgets.HTML(\"Please select points\")\n]\nelif 0 not in self.selection.y_train or 1 not in self.selection.y_train:\ntext_skopeVS.children[1].children = [\nwidgets.HTML(\"You can't choose everything/nothing !\")\n]\ntext_skopeES.children[1].children = [\nwidgets.HTML(\"You can't choose everything/nothing !\")\n]\nelse:\n# skope calculation for X\nself.selection.applySkope(self.__explanation, 0.2, 0.2)\nprint(self.selection.rules)\n# if no rule for one of the two, nothing is displayed\nif self.selection.success == False:\ntext_skopeVS.children[1].children = [\nwidgets.HTML(\"No rule found\")\n]\ntext_skopeES.children[1].children = [\nwidgets.HTML(\"No rule found\")\n]\n# otherwise we display\nelse:\n#chaine_carac = transform_string(skope_rules_clf.rules_[0])\ntext_skopeVS.children[0].children[3].children = [\n\"p = \"\n+ str(self.selection.score[0])\n+ \"%\"\n+ \" r = \"\n+ str(self.selection.score[1])\n+ \"%\"\n+ \" ext. of the tree = \"\n+ str(self.selection.score[2])\n]\n# there we find the values \u200b\u200bof the skope to use them for the sliders\ncolumns_rules = [self.selection.rules[i][2] for i in range(len(self.selection.rules))]\nnew_columns_rules = []\nfor i in range(len(columns_rules)):\nif columns_rules[i] not in new_columns_rules:\nnew_columns_rules.append(columns_rules[i])\ncolumns_rules = new_columns_rules\nself.__other_columns = [g for g in self.atk.dataset.X.columns if g not in columns_rules]\nwidget_list_add_skope.items = self.__other_columns\nwidget_list_add_skope.v_model = self.__other_columns[0]\nself.selection.rules = self.selection.rules\none_card_VS.children = gui_elements.generate_rule_card(\nliste_to_string_skope(self.selection.rules)\n)\n[new_y, marker] = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[0][2])\nbeeswarm1.data[0].y = deepcopy(new_y)\nbeeswarm1.data[0].x = self.atk.explain[self.__explanation][columns_rules[0] + \"_shap\"]\nbeeswarm1.data[0].marker = marker\nall_histograms = [histogram1]\nif len(set([self.selection.rules[i][2] for i in range(len(self.selection.rules))])) &gt; 1:\nall_histograms = [histogram1, histogram2]\n[new_y, marker] = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[1][2])\nbeeswarm2.data[0].y = deepcopy(new_y)\nbeeswarm2.data[0].x = self.atk.explain[self.__explanation][columns_rules[1] + \"_shap\"]\nbeeswarm2.data[0].marker = marker\nif len(set([self.selection.rules[i][2] for i in range(len(self.selection.rules))])) &gt; 2:\nall_histograms = [histogram1, histogram2, histogram3]\n[new_y, marker] = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[2][2])\nbeeswarm3.data[0].y = deepcopy(new_y)\nbeeswarm3.data[0].x = self.atk.explain[self.__explanation][columns_rules[2] + \"_shap\"]\nbeeswarm3.data[0].marker = marker\ny_shape_skope = []\ny_color_skope = []\ny_opa_skope = []\nfor i in range(len(self.atk.dataset.X)):\nif i in self.selection.indexes:\ny_shape_skope.append(\"circle\")\ny_color_skope.append(\"blue\")\ny_opa_skope.append(0.5)\nelse:\ny_shape_skope.append(\"cross\")\ny_color_skope.append(\"grey\")\ny_opa_skope.append(0.5)\nradio_buttons_for_color_choice.v_model = \"Selec actuelle\"\nfunction_change_color(None)\naccordion_skope.children = [\nin_accordion1_n,\n]\nin_accordion1_n.children[0].children[0].children = (\n\"X1 (\" + columns_rules[0].replace(\"_\", \" \") + \")\"\n)\nif len(columns_rules) &gt; 1:\naccordion_skope.children = [\nin_accordion1_n,\nin_accordion2_n,\n]\nin_accordion2_n.children[0].children[0].children = (\n\"X2 (\" + columns_rules[1].replace(\"_\", \" \") + \")\"\n)\nif len(columns_rules) &gt; 2:\naccordion_skope.children = [\nin_accordion1_n,\nin_accordion2_n,\nin_accordion3_n,\n]\nin_accordion3_n.children[0].children[0].children = (\n\"X3 (\" + columns_rules[2].replace(\"_\", \" \") + \")\"\n)\nself.__all_widgets_class_1 = gui_elements.create_class_selector(self, columns_rules[0], self.selection.rules[0][0], self.selection.rules[0][4], fig_size=fig_size.v_model)\nif len(columns_rules) &gt; 1:\nself.__all_widgets_class_2 = gui_elements.create_class_selector(self, columns_rules[1], self.selection.rules[1][0], self.selection.rules[1][4], fig_size=fig_size.v_model)\nif len(columns_rules) &gt; 2:\nself.__all_widgets_class_3 = gui_elements.create_class_selector(self, columns_rules[2], self.selection.rules[2][0], self.selection.rules[2][4], fig_size=fig_size.v_model)\nfor ii in range(len(self.__all_widgets_class_1.children[2].children)):\nself.__all_widgets_class_1.children[2].children[ii].on_event(\"change\", change_continuous1)\nfor ii in range(len(self.__all_widgets_class_2.children[2].children)):\nself.__all_widgets_class_2.children[2].children[ii].on_event(\"change\", change_continuous2)\nfor ii in range(len(self.__all_widgets_class_3.children[2].children)):\nself.__all_widgets_class_3.children[2].children[ii].on_event(\"change\", change_continuous3)\nif self.atk.dataset.lat in columns_rules and self.atk.dataset.long in columns_rules:\nbutton_add_map.disabled = False\nelse:\nbutton_add_map.disabled = True\nslider_skope1.min = -10e10\nslider_skope1.max = 10e10\nslider_skope2.min = -10e10\nslider_skope2.max = 10e10\nslider_skope3.min = -10e10\nslider_skope3.max = 10e10\nslider_skope1.max = max(self.atk.dataset.X[columns_rules[0]])\nslider_skope1.min = min(self.atk.dataset.X[columns_rules[0]])\nslider_skope1.v_model = [self.selection.rules[0][0], self.selection.rules[0][-1]]\n[slider_text_comb1.children[0].v_model, slider_text_comb1.children[2].v_model] = [slider_skope1.v_model[0], slider_skope1.v_model[1]]\nif len(self.selection.rules) &gt; 1 :\nslider_skope2.max = max(self.atk.dataset.X[columns_rules[1]])\nslider_skope2.min = min(self.atk.dataset.X[columns_rules[1]])\nslider_skope2.v_model = [self.selection.rules[1][0], self.selection.rules[1][-1]]\n[slider_text_comb2.children[0].v_model, slider_text_comb2.children[2].v_model] = [slider_skope2.v_model[0],slider_skope2.v_model[1]]\nif len(self.selection.rules) &gt; 2:\nslider_skope3.max = max(self.atk.dataset.X[columns_rules[2]])\nslider_skope3.min = min(self.atk.dataset.X[columns_rules[2]])\nslider_skope3.v_model = [self.selection.rules[2][0], self.selection.rules[2][-1]]\n[\nslider_text_comb3.children[0].v_model,\nslider_text_comb3.children[2].v_model,\n] = [\nslider_skope3.v_model[0],\nslider_skope3.v_model[1],\n]\nwith histogram1.batch_update():\nhistogram1.data[0].x = list(self.atk.dataset.X[columns_rules[0]])\ndf_respect1 = self.selection.respectOneRule(0)\nhistogram1.data[1].x = list(df_respect1[columns_rules[0]])\nif len(set([self.selection.rules[i][2] for i in range(len(self.selection.rules))])) &gt; 1:\nwith histogram2.batch_update():\nhistogram2.data[0].x = list(self.atk.dataset.X[columns_rules[1]])\ndf_respect2 = self.selection.respectOneRule(1)\nhistogram2.data[1].x = list(df_respect2[columns_rules[1]])\nif len(set([self.selection.rules[i][2] for i in range(len(self.selection.rules))])) &gt; 2:\nwith histogram3.batch_update():\nhistogram3.data[0].x = list(self.atk.dataset.X[columns_rules[2]])\ndf_respect3 = self.selection.respectOneRule(2)\nhistogram3.data[1].x = list(df_respect3[columns_rules[2]])\nmodifie_all_histograms(\nslider_skope1.v_model[0], slider_skope1.v_model[1], 0\n)\ntext_skopeES.children[0].children[3].children = [\n# str(skope_rules_clf.rules_[0])\n# + \"\\n\"\n\"p = \"\n+ str(self.selection.score_exp[0])\n+ \"%\"\n+ \" r = \"\n+ str(self.selection.score_exp[1])\n+ \"%\"\n+ \" ext. of the tree =\"\n+ str(self.selection.score_exp[2])\n]\none_card_ES.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules_exp))\nfunction_scores_models(self.selection.indexes)\nin_accordion1_n.children[0].disabled = False\nin_accordion2_n.children[0].disabled = False\nin_accordion3_n.children[0].disabled = False\nslider_skope1.on_event(\"input\", on_value_change_skope1)\nslider_skope2.on_event(\"input\", on_value_change_skope2)\nslider_skope3.on_event(\"input\", on_value_change_skope3)\nslider_text_comb1.children[0].on_event(\"input\", on_value_change_skope1)\nslider_text_comb1.children[2].on_event(\"input\", on_value_change_skope1)\nloading_models.class_ = \"d-none\"\nself.__save_rules = deepcopy(self.selection.rules)\nfunction_change_color(None)\ndef reset_skope(*b):\nself.selection.rules = self.__save_rules\nfunction_validation_skope(None)\nfunction_scores_models(None)\nbutton_reset_skope.on_event(\"click\", reset_skope)\n# here to see the values \u200b\u200bof the selected points (VS and ES)\nout_selec = v.Layout(style_=\"min-width: 47%; max-width: 47%\", children=[v.Html(tag=\"h4\", children=[\"Select points on the figure to see their values \u200b\u200bhere\"])])\nout_selec_SHAP = v.Layout(style_=\"min-width: 47%; max-width: 47%\", children=[v.Html(tag=\"h4\", children=[\"Select points on the figure to see their SHAP values \u200b\u200bhere\"])])\nout_selec_all = v.Alert(\nmax_height=\"400px\",\nstyle_=\"overflow: auto\",\nelevation=\"0\",\nchildren=[\nv.Row(class_='d-flex flex-row justify-space-between', children=[out_selec, v.Divider(class_=\"ma-2\", vertical=True), out_selec_SHAP]),\n],\n)\n# to see the data of the current selection\nout_accordion = v.ExpansionPanels(\nclass_=\"ma-2\",\nchildren=[\nv.ExpansionPanel(\nchildren=[\nv.ExpansionPanelHeader(children=[\"Data selected\"]),\nv.ExpansionPanelContent(children=[out_selec_all]),\n]\n)\n],\n)\nfind_clusters = v.Btn(\nclass_=\"ma-1 mt-2 mb-0\",\nelevation=\"2\",\nchildren=[v.Icon(children=[\"mdi-magnify\"]), \"Find clusters\"],\n)\nslider_clusters = v.Slider(\nstyle_=\"width : 30%\",\nclass_=\"ma-3 mb-0\",\nmin=2,\nmax=20,\nstep=1,\nv_model=3,\ndisabled=True,\n)\ntext_slider_cluster = v.Html(\ntag=\"h3\",\nclass_=\"ma-3 mb-0\",\nchildren=[\"Number of clusters \" + str(slider_clusters.v_model)],\n)\ndef fonct_text_clusters(*b):\ntext_slider_cluster.children = [\n\"Number of clusters \" + str(slider_clusters.v_model)\n]\nslider_clusters.on_event(\"input\", fonct_text_clusters)\ncheck_number_of_clusters = v.Checkbox(\nv_model=True, label=\"Optimal number of clusters :\", class_=\"ma-3\"\n)\ndef bool_nb_opti(*b):\nslider_clusters.disabled = check_number_of_clusters.v_model\ncheck_number_of_clusters.on_event(\"change\", bool_nb_opti)\npart_for_clusters = v.Layout(\nclass_=\"d-flex flex-row\",\nchildren=[\nfind_clusters,\ncheck_number_of_clusters,\nslider_clusters,\ntext_slider_cluster,\n],\n)\nnew_df = pd.DataFrame([], columns=[\"Region #\", \"Number of points\"])\ncolumns = [{\"text\": c, \"sortable\": True, \"value\": c} for c in new_df.columns]\nresults_clusters_table = v.DataTable(\nclass_=\"w-100\",\nstyle_=\"width : 100%\",\nv_model=[],\nshow_select=False,\nheaders=columns,\nitems=new_df.to_dict(\"records\"),\nitem_value=\"Region #\",\nitem_key=\"Region #\",\nhide_default_footer=True,\n)\nresults_clusters = v.Row(\nchildren=[\nv.Layout(\nclass_=\"flex-grow-0 flex-shrink-0\",\nchildren=[v.Btn(class_=\"d-none\", elevation=0, disabled=True)],\n),\nv.Layout(\nclass_=\"flex-grow-1 flex-shrink-0\",\nchildren=[results_clusters_table],\n),\n],\n)\n# allows you to make dyadic clustering\ndef function_clusters(*b):\nloading_clusters.class_ = \"d-flex\"\nif check_number_of_clusters.v_model:\nresult = function_auto_clustering(self.atk.dataset.X_scaled, self.atk.explain[self.__explanation], 3, True)\nelse:\nnb_clusters = slider_clusters.v_model\nresult = function_auto_clustering(self.atk.dataset.X_scaled, self.atk.explain[self.__explanation], nb_clusters, False)\nself.__result_dyadic_clustering = result\nlabels = result[1]\nself.__labels_automatic_clustering = labels\nwith self.fig1.batch_update():\nself.fig1.data[0].marker.color = labels\nself.fig1.update_traces(marker=dict(showscale=False))\nwith self.fig2.batch_update():\nself.fig2.data[0].marker.color = labels\nwith self.fig1_3D.batch_update():\nself.fig1_3D.data[0].marker.color = labels\nself.fig1_3D.update_traces(marker=dict(showscale=False))\nwith self.fig2_3D.batch_update():\nself.fig2_3D.data[0].marker.color = labels\nlabels_regions = result[0]\nnew_df = []\nfor i in range(len(labels_regions)):\nnew_df.append(\n[\ni + 1,\nlen(labels_regions[i]),\nstr(round(len(labels_regions[i]) / len(self.atk.dataset.X) * 100, 2)) + \"%\",\n]\n)\nnew_df = pd.DataFrame(\nnew_df,\ncolumns=[\"Region #\", \"Number of points\", \"Percentage of the dataset\"],\n)\ndata = new_df.to_dict(\"records\")\ncolumns = [\n{\"text\": c, \"sortable\": False, \"value\": c} for c in new_df.columns\n]\nresults_clusters_table = v.DataTable(\nclass_=\"w-100\",\nstyle_=\"width : 100%\",\nshow_select=False,\nsingle_select=True,\nv_model=[],\nheaders=columns,\nitems=data,\nitem_value=\"Region #\",\nitem_key=\"Region #\",\nhide_default_footer=True,\n)\nall_chips = []\nall_radio = []\nN_stages = len(labels_regions)\nMultip = 100\ndebut = 0\nfin = (N_stages * Multip - 1) * (1 + 1 / (N_stages - 1))\npas = (N_stages * Multip - 1) / (N_stages - 1)\nscale_colors = np.arange(debut, fin, pas)\na = 0\nfor i in scale_colors:\ncolor = sns.color_palette(\"viridis\", N_stages * Multip).as_hex()[\nround(i)\n]\nall_chips.append(v.Chip(class_=\"rounded-circle\", color=color))\nall_radio.append(v.Radio(class_=\"mt-4\", value=str(a)))\na += 1\nall_radio[-1].class_ = \"mt-4 mb-0 pb-0\"\npart_for_radio = v.RadioGroup(\nv_model=None,\nclass_=\"mt-10 ml-7\",\nstyle_=\"width : 10%\",\nchildren=all_radio,\n)\npart_for_chips = v.Col(\nclass_=\"mt-10 mb-2 ml-0 d-flex flex-column justify-space-between\",\nstyle_=\"width : 10%\",\nchildren=all_chips,\n)\nresults_clusters = v.Row(\nchildren=[\nv.Layout(\nclass_=\"flex-grow-0 flex-shrink-0\", children=[part_for_radio]\n),\nv.Layout(\nclass_=\"flex-grow-0 flex-shrink-0\", children=[part_for_chips]\n),\nv.Layout(\nclass_=\"flex-grow-1 flex-shrink-0\",\nchildren=[results_clusters_table],\n),\n],\n)\npart_for_selection.children = part_for_selection.children[:-1] + [\nresults_clusters\n]\nradio_buttons_for_color_choice.v_model = \"Clustering auto\"\npart_for_selection.children[-1].children[0].children[0].on_event(\n\"change\", function_choice_cluster\n)\nloading_clusters.class_ = \"d-none\"\nreturn N_stages\n# when we select a region created by the automatic dyadic clustering\ndef function_choice_cluster(widget, event, data):\nresult = self.__result_dyadic_clustering\nlabels = result[1]\nindex = part_for_selection.children[-1].children[0].children[0].v_model\nliste = [i for i, d in enumerate(labels) if d == float(index)]\nfunction_lasso_selection(None, None, None, liste)\nradio_buttons_for_color_choice.v_model = \"Clustering auto\"\nfunction_change_color(opacity=False)\nfind_clusters.on_event(\"click\", function_clusters)\n# function which is called as soon as the points are selected (step 1)\ndef function_lasso_selection(trace, points, selector, *args):\nif len(args) &gt; 0:\nliste = args[0]\nles_points = liste\nelse:\nles_points = points.point_inds\nself.selection = Potato(self.atk, les_points)\nself.selection.state = Potato.LASSO\nif len(les_points) == 0:\ncard_selec.children[0].children[1].children = \"0 point !\"\ntext_selec.value = text_base_debut\nreturn\ncard_selec.children[0].children[1].children = (\nstr(len(les_points))\n+ \" points selected (\"\n+ str(round(len(les_points) / len(self.atk.dataset.X) * 100, 2))\n+ \"% of the overall)\"\n)\ntext_selec.value = (\ntext_base\n+ str(len(les_points))\n+ \" points selected (\"\n+ str(round(len(les_points) / len(self.atk.dataset.X) * 100, 2))\n+ \"% of the overall)\"\n)\nopa = []\nfor i in range(len(self.fig2.data[0].x)):\nif i in les_points:\nopa.append(1)\nelse:\nopa.append(0.1)\nwith self.fig2.batch_update():\nself.fig2.data[0].marker.opacity = opa\nwith self.fig1.batch_update():\nself.fig1.data[0].marker.opacity = opa\nX_train = self.atk.dataset.X.copy()\nX_mean = (\npd.DataFrame(\nX_train.iloc[self.selection.indexes, :].mean(axis=0).values.reshape(1, -1),\ncolumns=X_train.columns,\n)\n.round(2)\n.rename(index={0: \"Mean of the selection\"})\n)\nX_mean_tot = (\npd.DataFrame(\nX_train.mean(axis=0).values.reshape(1, -1), columns=X_train.columns\n)\n.round(2)\n.rename(index={0: \"Mean of the whole dataset\"})\n)\nX_mean = pd.concat([X_mean, X_mean_tot], axis=0)\nSHAP_mean = (\npd.DataFrame(\nself.atk.explain[self.__explanation].iloc[self.selection.indexes, :]\n.mean(axis=0)\n.values.reshape(1, -1),\ncolumns=self.atk.explain[self.__explanation].columns,\n)\n.round(2)\n.rename(index={0: \"Mean of the selection\"})\n)\nSHAP_mean_tot = (\npd.DataFrame(\nself.atk.explain[self.__explanation].mean(axis=0).values.reshape(1, -1),\ncolumns=self.atk.explain[self.__explanation].columns,\n)\n.round(2)\n.rename(index={0: \"Mean of the whole dataset\"})\n)\nSHAP_mean = pd.concat([SHAP_mean, SHAP_mean_tot], axis=0)\nX_mean.insert(loc=0, column=' ', value=[\"Mean of the selection\", \"Mean of the whole dataset\"])\ndata = X_mean.to_dict(\"records\")\ncolumns = [\n{\"text\": c, \"sortable\": True, \"value\": c} for c in X_mean.columns\n]\nout_selec_table_means = v.DataTable(\nv_model=[],\nshow_select=False,\nheaders=columns.copy(),\nitems=data.copy(),\nhide_default_footer=True,\ndisable_sort=True,\n)\ndata = X_train.iloc[self.selection.indexes, :].round(3).to_dict(\"records\")\ncolumns = [\n{\"text\": c, \"sortable\": True, \"value\": c} for c in X_train.columns\n]\nout_selec_table = v.DataTable(\nv_model=[],\nshow_select=False,\nheaders=columns.copy(),\nitems=data.copy(),\n)\nout_selec.children = [v.Col(class_= \"d-flex flex-column justify-center align-center\", children=[\nv.Html(tag=\"h3\", children=[\"Values Space\"]),\nout_selec_table_means,\nv.Divider(class_=\"ma-6\"),\nv.Html(tag=\"h4\", children=[\"Entire dataset:\"], class_=\"mb-2\"),\nout_selec_table\n])]\nSHAP_mean.insert(loc=0, column=' ', value=[\"Mean of the selection\", \"Mean of the whole dataset\"])\ndata = SHAP_mean.to_dict(\"records\")\ncolumns = [\n{\"text\": c, \"sortable\": True, \"value\": c} for c in SHAP_mean.columns\n]\nout_selec_table_means = v.DataTable(\nv_model=[],\nshow_select=False,\nheaders=columns.copy(),\nitems=data.copy(),\nhide_default_footer=True,\ndisable_sort=True,\n)\ndata = self.atk.explain[self.__explanation].iloc[self.selection.indexes, :].round(3).to_dict(\"records\")\ncolumns = [\n{\"text\": c, \"sortable\": True, \"value\": c} for c in self.atk.explain[self.__explanation].columns\n]\nout_selec_table = v.DataTable(\nv_model=[],\nshow_select=False,\nheaders=columns.copy(),\nitems=data.copy(),\n)\nout_selec_SHAP.children = [v.Col(class_=\"d-flex flex-column justify-center align-center\", children=[\nv.Html(tag=\"h3\", children=[\"Explanatory Space\"]),\nout_selec_table_means,\nv.Divider(class_=\"ma-6\"),\nv.Html(tag=\"h4\", children=[\"Entire dataset:\"], class_=\"mb-2\"),\nout_selec_table\n])]\n# function that is called when validating a tile to add it to the set of regions\ndef function_new_region(*args):\nif len(args) == 0:\npass\nelif self.selection in self.atk.regions:\nprint(\"AntakIA WARNING: this region is already in the set of regions\")\nelse:\nself.selection.state = Potato.REGION\nif self.__model_index == None:\nname_model = None\nscore_model = [1,1,1]\nelse:\nname_model = self.sub_models[self.__model_index].__class__.__name__\nscore_model = self.__score_sub_models[self.__model_index]\nif self.selection.rules == None :\nreturn\nself.selection.applyRules()\nnew_tuile = deepcopy(self.selection.getIndexes())\nself.selection.sub_model[\"name\"], self.selection.sub_model[\"score\"] = name_model, score_model\n# here we will force so that all the points of the new tile belong only to it: we will modify the existing tiles\nself.atk.regions = conflict_handler(self.atk.regions, new_tuile)\nself.selection.setIndexes(new_tuile)\nself.atk.newRegion(self.selection)\nself.__color_regions=[0]*len(self.atk.dataset.X)\nfor i in range(len(self.__color_regions)):\nfor j in range(len(self.atk.regions)):\nif i in self.atk.regions[j].indexes:\nself.__color_regions[i] = j+1\nbreak\ntoute_somme = 0\ntemp = []\nscore_tot = 0\nscore_tot_glob = 0\nautre_toute_somme = 0\nfor i in range(len(self.atk.regions)):\nif self.atk.regions[i].sub_model[\"score\"] == None:\ntemp.append(\n[\ni + 1,\nlen(self.atk.regions[i]),\nnp.round(len(self.atk.regions[i]) / len(self.atk.dataset.X) * 100, 2),\n\"/\",\n\"/\",\n\"/\",\n\"/\",\n]\n)\nelse:\ntemp.append(\n[\ni + 1,\nlen(self.atk.regions[i]),\nnp.round(len(self.atk.regions[i]) / len(self.atk.dataset.X) * 100, 2),\nself.atk.regions[i].sub_model[\"model\"],\nself.atk.regions[i].sub_model[\"score\"][0],\nself.atk.regions[i].sub_model[\"score\"][1],\nstr(self.atk.regions[i].sub_model[\"score\"][2]) + \"%\",\n]\n)\nscore_tot += self.atk.regions[i].sub_model[\"score\"][0] * len(self.atk.regions[i])\nscore_tot_glob += self.atk.regions[i].sub_model[\"score\"][1] * len(\nself.atk.regions[i]\n)\nautre_toute_somme += len(self.atk.regions[i])\ntoute_somme += len(self.atk.regions[i])\nif autre_toute_somme == 0:\nscore_tot = \"/\"\nscore_tot_glob = \"/\"\npercent = \"/\"\nelse:\nscore_tot = round(score_tot / autre_toute_somme, 3)\nscore_tot_glob = round(score_tot_glob / autre_toute_somme, 3)\npercent = (\nstr(round(100 * (score_tot_glob - score_tot) / score_tot_glob, 1))\n+ \"%\"\n)\ntemp.append(\n[\n\"Total\",\ntoute_somme,\nnp.round(toute_somme / len(self.atk.dataset.X) * 100, 2),\n\"/\",\nscore_tot,\nscore_tot_glob,\npercent,\n]\n)\nnew_df = pd.DataFrame(\ntemp,\ncolumns=[\n\"Region #\",\n\"Number of points\",\n\"% of the dataset\",\n\"Model\",\n\"Score of the sub-model (MSE)\",\n\"Score of the global model (MSE)\",\n\"Gain in MSE\",\n],\n)\nwith table_regions:\nclear_output()\ndata = new_df[:-1].to_dict(\"records\")\ntotal = new_df[-1:].iloc[:, 1:].to_dict(\"records\")\ncolumns = [\n{\"text\": c, \"sortable\": True, \"value\": c} for c in new_df.columns\n]\ncolumns_total = [\n{\"text\": c, \"sortable\": True, \"value\": c}\nfor c in new_df.columns[1:]\n]\ntable_donnes = v.DataTable(\nv_model=[],\nshow_select=True,\nheaders=columns,\nitems=data,\nitem_value=\"Region #\",\nitem_key=\"Region #\",\n)\ntable_total = v.DataTable(\nv_model=[],\nheaders=columns_total,\nitems=total,\nhide_default_footer=True,\n)\nensemble_tables = v.Layout(\nclass_=\"d-flex flex-column\",\nchildren=[\ntable_donnes,\nv.Divider(class_=\"mt-7 mb-4\"),\nv.Html(tag=\"h2\", children=[\"Review of the regions :\"]),\ntable_total,\n],\n)\ndef function_suppression_tuiles(*b):\nif table_donnes.v_model == []:\nreturn\ntaille = len(table_donnes.v_model)\na = 0\nfor i in range(taille):\nindex = table_donnes.v_model[i][\"Region #\"] - 1\nself.atk.regions.pop(index - a)\nfunction_new_region()\na += 1\nradio_buttons_for_color_choice.v_model = \"R\u00e9gions\"\nfunction_change_color()\nsupprimer_toutes_les_tuiles.on_event(\n\"click\", function_suppression_tuiles\n)\ndisplay(ensemble_tables)\nvalidate_one_region.on_event(\"click\", function_new_region)\nbutton_validate_skope.on_event(\"click\", function_validation_skope)\nself.fig1.data[0].on_selection(function_lasso_selection)\nself.fig2.data[0].on_selection(function_lasso_selection)\ndef function_fig_size(*args):\nwith self.fig1.batch_update():\nself.fig1.layout.width = int(fig_size.v_model)\nwith self.fig2.batch_update():\nself.fig2.layout.width = int(fig_size.v_model)\nwith self.fig1_3D.batch_update():\nself.fig1_3D.layout.width = int(fig_size.v_model)\nwith self.fig2_3D.batch_update():\nself.fig2_3D.layout.width = int(fig_size.v_model)\nfor i in range(len(all_histograms)):\nwith all_histograms[i].batch_update():\nall_histograms[i].layout.width = 0.9 * int(fig_size.v_model)\nwith all_beeswarms[i].batch_update():\nall_beeswarms[i].layout.width = 0.9 * int(fig_size.v_model)\nfig_size.on_event(\"input\", function_fig_size)\nbutton_add_skope = v.Btn(\nclass_=\"ma-4 pa-2 mb-1\",\nchildren=[v.Icon(children=[\"mdi-plus\"]), \"Add a rule\"],\n)\nwidget_list_add_skope = v.Select(\nclass_=\"mr-3 mb-0\",\nitems=[\"/\"],\nv_model=\"/\",\nstyle_=\"max-width : 15%\",\n)\nbutton_add_map = v.Btn(\nclass_=\"ma-4 pa-2 mb-1\",\nchildren=[v.Icon(class_=\"mr-4\", children=[\"mdi-map\"]), \"Display the map\"],\ncolor=\"white\",\ndisabled=True,\n)\ndef function_display_map(widget, event, data):\nif widget.color == \"white\":\npart_map.class_= \"d-flex justify-space-around ma-0 pa-0\"\nwidget.color = \"error\"\nwidget.children =  [widget.children[0]] + [\"Hide the map\"]\nself.__save_lat_rule = [self.selection.rules[i] for i in range(len(self.selection.rules)) if self.selection.rules[i][2] == self.atk.dataset.lat]\nself.__save_long_rule = [self.selection.rules[i] for i in range(len(self.selection.rules)) if self.selection.rules[i][2] == self.atk.dataset.long]\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == self.atk.dataset.lat or self.selection.rules[i-count][2] == self.atk.dataset.long:\nself.selection.rules.pop(i-count)\ncount += 1\nfor i in range(len(accordion_skope.children)):\nif accordion_skope.children[i].children[0].children[0].children[0][4:-1] in [self.atk.dataset.lat, self.atk.dataset.long]:\naccordion_skope.children[i].disabled = True\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nelse:\nself.selection.setIndexesFromMap(None)\nwidget.color = \"white\"\npart_map.class_= \"d-none ma-0 pa-0\"\nwidget.children =  [widget.children[0]] + [\"Display the map\"]\nself.selection.rules = self.selection.rules + self.__save_lat_rule + self.__save_long_rule\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nfor i in range(len(accordion_skope.children)):\naccordion_skope.children[i].disabled = False\nbutton_add_map.on_event(\"click\", function_display_map)\nadd_group = v.Row(children=[button_add_skope, widget_list_add_skope, v.Spacer(), button_add_map])\n# function called when we add a feature to the rules. We instanciate the exact same things than from the previous features\n# (beeswarms, histograms, etc...)\ndef function_add_skope(*b):\nnew_rule = [0] * 5\ncolumn = widget_list_add_skope.v_model\nif self.__other_columns == None:\nreturn\nself.__other_columns = [a for a in self.__other_columns if a != column]\nnew_rule[2] = column\nnew_rule[0] = round(min(list(self.atk.dataset.X[column].values)), 1)\nnew_rule[1] = \"&lt;=\"\nnew_rule[3] = \"&lt;=\"\nnew_rule[4] = round(max(list(self.atk.dataset.X[column].values)), 1)\nself.selection.rules.append(new_rule)\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nnew_validate_change, new_slider_skope, new_histogram = gui_elements.create_new_feature_rule(self, new_rule, column, number_of_bins_histograms, fig_size.v_model)\nall_histograms.append(new_histogram)\ndef new_function_change_validate(*change):\nii = -1\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i][2] == column_2:\nii = int(i)\na = deepcopy(float(new_slider_skope.v_model[0]  ))\nb = deepcopy(float(new_slider_skope.v_model[1]  ))\nself.selection.rules[ii][0] = a\nself.selection.rules[ii][4] = b\nself.selection.rules[ii][0] = a\nself.selection.rules[ii][4] = b\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nfunction_scores_models(None)\nnew_validate_change.on_event(\"click\", new_function_change_validate)\nnew_button_in_real_time_graph = v.Checkbox(\nv_model=False, label=\"Real-time updates on the graphs\", class_=\"ma-3\"\n)\nnew_slider_text_comb = v.Layout(\nchildren=[\nv.TextField(\nstyle_=\"max-width:100px\",\nv_model=new_slider_skope.v_model[0]  ,\nhide_details=True,\ntype=\"number\",\ndensity=\"compact\",\n),\nnew_slider_skope,\nv.TextField(\nstyle_=\"max-width:100px\",\nv_model=new_slider_skope.v_model[1]  ,\nhide_details=True,\ntype=\"number\",\ndensity=\"compact\",\n),\n],\n)\ndef new_update_validate(*args):\nif new_button_in_real_time_graph.v_model:\nnew_validate_change.disabled = True\nelse:\nnew_validate_change.disabled = False\nnew_button_in_real_time_graph.on_event(\"change\", new_update_validate)\nnew_two_end = widgets.HBox([new_validate_change, new_button_in_real_time_graph])\nnew_all_widgets_slider_histo = widgets.VBox(\n[new_slider_text_comb, new_histogram, new_two_end]\n)\ncolumn_shap = column + \"_shap\"\ny_histo_shap = [0] * len(self.atk.explain[self.__explanation])\nnew_beeswarm = go.FigureWidget(\ndata=[go.Scatter(x=self.atk.explain[self.__explanation][column_shap], y=y_histo_shap, mode=\"markers\")]\n)\nnew_beeswarm.update_layout(\nmargin=dict(l=0, r=0, t=0, b=0),\nheight=200,\nwidth=0.9 * int(fig_size.v_model),\n)\nnew_beeswarm.update_yaxes(visible=False, showticklabels=False)\n[new_y, marker] = compute.function_beeswarm_shap(self, self.__explanation, column)\nnew_beeswarm.data[0].y = new_y\nnew_beeswarm.data[0].x = self.atk.explain[self.__explanation][column_shap]\nnew_beeswarm.data[0].marker = marker\nnew_choice_color_beeswarm = v.Row(\nclass_=\"pt-3 mt-0 ml-4\",\nchildren=[\n\"Value of Xi\",\nv.Switch(\nclass_=\"ml-3 mr-2 mt-0 pt-0\",\nv_model=False,\nlabel=\"\",\n),\n\"Current selection\",\n],\n)\ndef new_change_color_beeswarm_shap(*args):\nif new_choice_color_beeswarm.children[1].v_model == False:\nmarker = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[len(self.selection.rules) - 1][2])[1]\nnew_beeswarm.data[0].marker = marker\nnew_beeswarm.update_traces(marker=dict(showscale=True))\nelse:\nmodifie_all_histograms(\nnew_slider_skope.v_model[0]  ,\nnew_slider_skope.v_model[1]  ,\n0,\n)\nnew_beeswarm.update_traces(marker=dict(showscale=False))\nnew_choice_color_beeswarm.children[1].on_event(\n\"change\", new_change_color_beeswarm_shap\n)\nnew_beeswarm_tot = widgets.VBox([new_choice_color_beeswarm, new_beeswarm])\nnew_beeswarm_tot.layout.margin = \"0px 0px 0px 20px\"\nall_beeswarms_total.append(new_beeswarm_tot)\nif not check_beeswarm.v_model:\nnew_beeswarm_tot.layout.display = \"none\"\nall_beeswarms.append(new_beeswarm)\nall_color_choosers_beeswarms.append(new_choice_color_beeswarm)\nwidget_list_add_skope.items = self.__other_columns\nwidget_list_add_skope.v_model = self.__other_columns[0]\nnew_b_delete_skope = v.Btn(\ncolor=\"error\",\nclass_=\"ma-2 ml-4 pa-1\",\nelevation=\"3\",\nicon=True,\nchildren=[v.Icon(children=[\"mdi-delete\"])],\n)\ndef new_delete_skope(*b):\ncolumn_2 = new_slider_skope.label\nii = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i][2] == column_2:\nii = i\nbreak\nall_beeswarms_total.pop(ii)\nall_histograms.pop(ii)\nself.selection.rules.pop(ii)\nall_beeswarms.pop(ii)\nall_color_choosers_beeswarms.pop(ii)\nself.__other_columns = [column_2] + self.__other_columns\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nwidget_list_add_skope.items = self.__other_columns\nwidget_list_add_skope.v_model = self.__other_columns[0]\naccordion_skope.children = [\na for a in accordion_skope.children if a != new_in_accordion_n\n]\nfor i in range(ii, len([accordion_skope.children[a] for a in range(len(accordion_skope.children)) if accordion_skope.children[a].disabled == False])):\ncol = \"X\" + str(i + 1) + \" (\" + self.selection.rules[i][2] + \")\"\naccordion_skope.children[i].children[0].children[0].children = [col]\nif widget_list_add_skope.v_model in [self.atk.dataset.lat, self.atk.dataset.long]:\nif self.atk.dataset.lat in [self.selection.rules[i][2] for i in range(len(self.selection.rules))] and self.atk.dataset.long in [self.selection.rules[i][2] for i in range(len(self.selection.rules))]:\nbutton_add_map.disabled = False\nelse :\nbutton_add_map.disabled = True\nupdate_all_graphs()\nnew_b_delete_skope.on_event(\"click\", new_delete_skope)\nis_continuous_new = v.Checkbox(v_model=True, label=\"is continuous?\")\nright_side_new = v.Col(children=[new_b_delete_skope, is_continuous_new], class_=\"d-flex flex-column align-center justify-center\")\nall_widgets_class_new = gui_elements.create_class_selector(self, self.selection.rules[-1][2], min=min(list(self.atk.dataset.X[new_slider_skope.label].values)), max=max(list(self.atk.dataset.X[new_slider_skope.label].values)), fig_size=fig_size.v_model)\ndef change_continuous_new(widget, event, data):\ncolumn_2 = new_slider_skope.label\nindex = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i][2] == column_2:\nindex = i\nbreak\nif widget.v_model == True and widget == right_side_new.children[1]:\nnew_in_accordion.children = [new_all_widgets_slider_histo] + list(new_in_accordion.children[1:])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == self.selection.rules[index][2] and i-count != index:\nself.selection.rules.pop(i-count)\ncount += 1\nself.selection.rules[index][0] = new_slider_skope.v_model[0]\nself.selection.rules[index][4] = new_slider_skope.v_model[1]\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nelse:\nnew_in_accordion.children = [all_widgets_class_new] + list(new_in_accordion.children[1:])\nl = []\nfor i in range(len(all_widgets_class_new.children[2].children)):\nif all_widgets_class_new.children[2].children[i].v_model:\nl.append(int(all_widgets_class_new.children[2].children[i].label))\nif len(l) == 0:\nwidget.v_model = True\nreturn\ncolumn = deepcopy(self.selection.rules[index][2])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == column:\nself.selection.rules.pop(i-count)\ncount += 1\ncroissant = 0\nfor ele in l:\nself.selection.rules.insert(index+croissant, [ele-0.5, '&lt;=', column, '&lt;=', ele+0.5])\ncroissant += 1\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules), is_class=True)\nupdate_all_graphs()\nright_side_new.children[1].on_event(\"change\", change_continuous_new)\nfor ii in range(len(all_widgets_class_new.children[2].children)):\nall_widgets_class_new.children[2].children[ii].on_event(\"change\", change_continuous_new)\nnew_in_accordion = widgets.HBox(\n[new_all_widgets_slider_histo, new_beeswarm_tot, right_side_new],\nlayout=Layout(align_items=\"center\"),\n)\nnew_in_accordion_n = v.ExpansionPanels(\nclass_=\"ma-2 mb-1\",\nchildren=[\nv.ExpansionPanel(\nchildren=[\nv.ExpansionPanelHeader(children=[\"Xn\"]),\nv.ExpansionPanelContent(children=[new_in_accordion]),\n]\n)\n],\n)\naccordion_skope.children = [*accordion_skope.children, new_in_accordion_n]\nname_colcol = \"X\" + str(len(accordion_skope.children)) + \" (\" + column + \")\"\naccordion_skope.children[-1].children[0].children[0].children = name_colcol\nwith new_histogram.batch_update():\nnew_list = [\ng\nfor g in list(self.atk.dataset.X[column].values)\nif g &gt;= new_slider_skope.v_model[0]  \nand g &lt;= new_slider_skope.v_model[1]  \n]\nnew_histogram.data[1].x = new_list\ncolumn_2 = new_slider_skope.label\nnew_list_rule = self.atk.dataset.X.index[\nself.atk.dataset.X[column_2].between(\nnew_slider_skope.v_model[0]  ,\nnew_slider_skope.v_model[1]  ,\n)\n].tolist()\nnew_list_tout = new_list_rule.copy()\nfor i in range(1, len(self.selection.rules)):\nnew_list_temp = self.atk.dataset.X.index[\nself.atk.dataset.X[self.selection.rules[i][2]].between(\nself.selection.rules[i][0], self.selection.rules[i][4]\n)\n].tolist()\nnew_list_tout = [g for g in new_list_tout if g in new_list_temp]\nnew_list_tout_new = self.atk.dataset.X[column_2][new_list_tout]\nnew_histogram.data[2].x = new_list_tout_new\ndef new_on_value_change_skope(*b1):\nnew_slider_text_comb.children[0].v_model = (\nnew_slider_skope.v_model[0]  \n)\nnew_slider_text_comb.children[2].v_model = (\nnew_slider_skope.v_model[1]  \n)\ncolumn_2 = new_slider_skope.label\nii = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i][2] == column_2:\nii = i\nbreak\nnew_list = [\ng\nfor g in list(self.atk.dataset.X[column_2].values)\nif g &gt;= new_slider_skope.v_model[0]  \nand g &lt;= new_slider_skope.v_model[1]  \n]\nwith new_histogram.batch_update():\nnew_histogram.data[1].x = new_list\nif self.__activate_histograms:\nmodifie_all_histograms(\nnew_slider_skope.v_model[0]  ,\nnew_slider_skope.v_model[1]  ,\nii,\n)\nif new_button_in_real_time_graph.v_model:\nself.selection.rules[ii - 1][0] = float(\ndeepcopy(new_slider_skope.v_model[0]  )\n)\nself.selection.rules[ii - 1][4] = float(\ndeepcopy(new_slider_skope.v_model[1]  )\n)\none_card_VS.children = gui_elements.generate_rule_card(\nliste_to_string_skope(self.selection.rules)\n)\nupdate_all_graphs()\nnew_slider_skope.on_event(\"input\", new_on_value_change_skope)\nif new_slider_skope.label in [self.atk.dataset.lat, self.atk.dataset.long]:\nif self.atk.dataset.lat in [self.selection.rules[i][2] for i in range(len(self.selection.rules))] and self.atk.dataset.long in [self.selection.rules[i][2] for i in range(len(self.selection.rules))]:\nbutton_add_map.disabled = False\nelse :\nbutton_add_map.disabled = True\nfunction_new_region()\nbutton_add_skope.on_event(\"click\", function_add_skope)\nparam_VS = gui_elements.create_settings_card(params_proj_VS, \"Settings of the projection in the Values Space\")\nparam_ES = gui_elements.create_settings_card(params_proj_ES, \"Settings of the projection in the Explanatory Space\")\nprojVS_and_load = widgets.HBox(\n[\ndropdown_for_VS,\nv.Layout(children=[param_VS]),\nout_loading1,\n]\n)\nprojES_and_load = widgets.HBox(\n[\ndropdown_for_ES,\nv.Layout(children=[param_ES]),\nout_loading2,\n]\n)\nbouton_reset_opa = v.Btn(\nicon=True,\nchildren=[v.Icon(children=[\"mdi-opacity\"])],\nclass_=\"ma-2 ml-6 pa-3\",\nelevation=\"3\",\n)\nbouton_reset_opa.children = [\nadd_tooltip(\nbouton_reset_opa.children[0],\n\"Reset the opacity of the points\",\n)\n]\ndef function_reset_opa(*args):\nwith self.fig1.batch_update():\nself.fig1.data[0].marker.opacity = 1\nwith self.fig2.batch_update():\nself.fig2.data[0].marker.opacity = 1\nbouton_reset_opa.on_event(\"click\", function_reset_opa)\nitems = [{'text': \"Imported\", 'disabled': True},\n{'text': \"SHAP\", 'disabled': True},\n{'text': \"LIME\", 'disabled': True}]\nfor item in items:\nif self.atk.explain[item['text']] is not None:\nitem_default = item['text']\nitem['disabled'] = False\nchoose_explanation = v.Select(\nlabel=\"Explainability method\",\nitems=items,\nv_model=item_default,\nclass_=\"ma-2 mt-1 ml-6\",\nstyle_=\"width: 150px\",\ndisabled = False,\n)\ndef function_choose_explanation(widget, event, data):\nself.__explanation = data\nexp_val = self.atk.explain[data]\nif self.dim_red['ES'][self.__explanation][self.__projectionES] == None:\nout_loading2.layout.visibility = \"visible\"\ndim_red = compute.DimensionalityReductionChooser(method=dropdown_for_ES.v_model)\nself.dim_red['ES'][self.__explanation][self.__projectionES] = [dim_red.compute(exp_val, 2), dim_red.compute(exp_val, 3)]\nout_loading2.layout.visibility = \"hidden\"\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\nchoose_explanation.on_event(\"change\", function_choose_explanation)\nnew_prog_SHAP = gui_elements.prog_other(\"SHAP\")\nnew_prog_LIME = gui_elements.prog_other(\"LIME\")\nif self.__calculus == True:\nif self.__explanation == \"SHAP\":\nnew_prog_SHAP.children[1].v_model = 100\nnew_prog_SHAP.children[2].v_model = \"Computations already done !\"\nnew_prog_SHAP.children[-1].disabled = True\nelif self.__explanation == \"LIME\":\nnew_prog_LIME.children[1].v_model = 100\nnew_prog_LIME.children[2].v_model = \"Computations already done !\"\nnew_prog_LIME.children[-1].disabled = True\ndef function_validation_explanation(widget, event, data):\nif widget.v_model == \"SHAP\":\nself.__compute_SHAP = compute.computationSHAP(self.atk.dataset.X, self.atk.dataset.X_all, self.atk.dataset.model)\nwidgets.jslink((new_prog_SHAP.children[1], \"v_model\"), (self.__compute_SHAP.progress_widget, \"v_model\"))\nwidgets.jslink((new_prog_SHAP.children[2], \"v_model\"), (self.__compute_SHAP.text_widget, \"v_model\"))\nwidgets.jslink((new_prog_SHAP.children[-1], \"color\"), (self.__compute_SHAP.done_widget, \"v_model\"))\nself.__compute_SHAP.compute_in_thread()\nnew_prog_SHAP.children[-1].disabled = True\nif widget.v_model == \"LIME\":\nself.__compute_LIME = compute.computationLIME(self.atk.dataset.X, self.atk.dataset.X_all, self.atk.dataset.model)\nwidgets.jslink((new_prog_LIME.children[1], \"v_model\"), (self.__compute_LIME.progress_widget, \"v_model\"))\nwidgets.jslink((new_prog_LIME.children[2], \"v_model\"), (self.__compute_LIME.text_widget, \"v_model\"))\nwidgets.jslink((new_prog_LIME.children[-1], \"color\"), (self.__compute_LIME.done_widget, \"v_model\"))\nself.__compute_LIME.compute_in_thread()\nnew_prog_LIME.children[-1].disabled = True\ndef when_SHAP_computation_is_done(*args):\nself.atk.explain[\"SHAP\"] = self.__compute_SHAP.value\nitems = choose_explanation.items.copy()\nfor item in items:\nif item['text'] == \"SHAP\":\nitem['disabled'] = False\nchoose_explanation.items = items.copy() + [{'text': \"Update\", 'disabled': False}]\nchoose_explanation.items = choose_explanation.items[:-1]\ndef when_LIME_computation_is_done(*args):\nself.atk.explain[\"LIME\"] = self.__compute_LIME.value\nitems = choose_explanation.items.copy()\nfor item in items:\nif item['text'] == \"LIME\":\nitem['disabled'] = False\nchoose_explanation.items = items.copy() + [{'text': \"Update\", 'disabled': False}]\nchoose_explanation.items = choose_explanation.items[:-1]\nnew_prog_SHAP.children[-1].observe(when_SHAP_computation_is_done, \"color\")\nnew_prog_LIME.children[-1].observe(when_LIME_computation_is_done, \"color\")\nnew_prog_SHAP.children[-1].on_event(\"click\", function_validation_explanation)\nnew_prog_LIME.children[-1].on_event(\"click\", function_validation_explanation)\ntime_computing = gui_elements.time_computing(new_prog_SHAP, new_prog_LIME)\nwidgets.jslink(\n(time_computing.children[0], \"v_model\"), (time_computing.children[1].children[0], \"v_model\")\n)\nchoose_computing = v.Menu(\nv_slots=[\n{\n\"name\": \"activator\",\n\"variable\": \"props\",\n\"children\": v.Btn(\nv_on=\"props.on\",\nicon=True,\nsize=\"x-large\",\nchildren=[add_tooltip(v.Icon(children=[\"mdi-timer-sand\"], size=\"large\"), \"Time of computing\")],\nclass_=\"ma-2 pa-3\",\nelevation=\"3\",\n),\n}\n],\nchildren=[\nv.Card(\nclass_=\"pa-4\",\nrounded=True,\nchildren=[time_computing],\nmin_width=\"500\",\n)\n],\nv_model=False,\nclose_on_content_click=False,\noffset_y=True,\n)\ntop_of_the_UI_all_buttons = widgets.HBox(\n[\ndimension_projection_text,\nv.Layout(\nclass_=\"pa-2 ma-2\",\nelevation=\"3\",\nchildren=[\nadd_tooltip(\nv.Icon(\nchildren=[\"mdi-format-color-fill\"],\nclass_=\"mt-n5 mr-4\"\n),\n\"Color of the points\",\n),\nradio_buttons_for_color_choice,\nbouton_reset_opa,\nchoose_explanation,\nchoose_computing,\n],\n),\nv.Layout(class_=\"mt-3\", children=[projVS_and_load, projES_and_load]),\n],\nlayout=Layout(\nwidth=\"100%\",\ndisplay=\"flex\",\nflex_flow=\"row\",\njustify_content=\"space-around\",\n),\n)\nfigures = widgets.VBox([fig_2D_ou_3D], layout=Layout(width=\"100%\"))\ncheck_beeswarm = v.Checkbox(\nv_model=True,\nlabel=\"Show Shapley's beeswarm plots\",\nclass_=\"ma-1 mr-3\",\n)\ndef function_check_beeswarm(*b):\nif not check_beeswarm.v_model:\nfor i in range(len(all_beeswarms_total)):\nall_beeswarms_total[i].layout.display = \"none\"\nelse:\nfor i in range(len(all_beeswarms_total)):\nall_beeswarms_total[i].layout.display = \"block\"\ncheck_beeswarm.on_event(\"change\", function_check_beeswarm)\nbuttons_skope = v.Layout(\nclass_=\"d-flex flex-row\",\nchildren=[\nbutton_validate_skope,\nbutton_reset_skope,\nv.Spacer(),\ncheck_beeswarm,\n],\n)\ntwo_buttons = widgets.VBox([buttons_skope, text_skope])\nbouton_magic = v.Btn(\nclass_=\"ma-3\",\nchildren=[\nv.Icon(children=[\"mdi-creation\"], class_=\"mr-3\"),\n\"Magic button\",\n],\n)\npart_for_magic = v.Layout(\nclass_=\"d-flex flex-row justify-center align-center\",\nchildren=[\nv.Spacer(),\nbouton_magic,\nv.Checkbox(v_model=True, label=\"Demonstration mode\", class_=\"ma-4\"),\nv.TextField(\nclass_=\"shrink\",\ntype=\"number\",\nlabel=\"Time between the steps (ds)\",\nv_model=10,\n),\nv.Spacer(),\n],\n)\ndef function_checkbox_magic(*args):\nif part_for_magic.children[2].v_model:\npart_for_magic.children[3].disabled = False\nelse:\npart_for_magic.children[3].disabled = True\npart_for_magic.children[2].on_event(\"change\", function_checkbox_magic)\ndef find_best_score():\na = 1000\nfor i in range(len(self.__score_sub_models)):\nscore = self.__score_sub_models[i][0]\nif score &lt; a:\na = score\nindex = i\nreturn index\ndef function_bouton_magic(*args):\ndemo = part_for_magic.children[2].v_model\nif demo == False:\nstages.children[0].v_model = 3\nN_stages = function_clusters(None)\nif demo:\ntempo = int(part_for_magic.children[3].v_model) / 10\nif tempo &lt; 0:\ntempo = 0\nelse:\ntempo = 0\ntime.sleep(tempo)\nfor i in range(N_stages):\npart_for_selection.children[-1].children[0].children[0].v_model = str(i)\nfunction_choice_cluster(None, None, None)\ntime.sleep(tempo)\nif demo:\nstages.children[0].v_model = 1\ntime.sleep(tempo)\nfunction_validation_skope(None)\ntime.sleep(tempo)\nif demo:\nstages.children[0].v_model = 2\ntime.sleep(tempo)\nindex = find_best_score()\nmods.children[index].children[0].color = \"blue lighten-4\"\nchange(None, None, None, False)\ntime.sleep(tempo)\nmods.children[index].children[0].color = \"white\"\nif demo:\nstages.children[0].v_model = 3\ntime.sleep(tempo)\nfunction_new_region(None)\ntime.sleep(tempo)\nif i != N_stages - 1:\nif demo:\nstages.children[0].v_model = 0\ntime.sleep(tempo)\nradio_buttons_for_color_choice.v_model = \"R\u00e9gions\"\nfunction_change_color(None)\n#map plotly\nmap_select = go.FigureWidget(\ndata=go.Scatter(x=[1], y=[1], mode=\"markers\", marker=marker1, customdata=marker1[\"color\"], hovertemplate = '%{customdata:.3f}')\n)\nmap_select.update_layout(dragmode=\"lasso\")\n# instanciate the map, with longitude and latitude\nif self.atk.dataset.lat is not None and self.atk.dataset.long is not None:\ndf = self.atk.dataset.X\ndata=go.Scattergeo(\nlon = df[self.atk.dataset.long],\nlat = df[self.atk.dataset.lat],\nmode = 'markers',\nmarker_color = self.atk.dataset.y,\n)\nmap_select = go.FigureWidget(\ndata=data\n)\nlat_center = max(df[self.atk.dataset.lat]) - (max(df[self.atk.dataset.lat]) - min(df[self.atk.dataset.lat]))/2\nlong_center = max(df[self.atk.dataset.long]) - (max(df[self.atk.dataset.long]) - min(df[self.atk.dataset.long]))/2\nmap_select.update_layout(\nmargin={\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0},\n#geo_scope=\"world\",\nheight=300,\nwidth=900,\ngeo=dict(\ncenter=dict(\nlat=lat_center,\nlon=long_center\n),\nprojection_scale=5,\nshowland = True,\n)\n)\nmap_text_selection = v.Card(\nstyle_=\"width: 30%\",\nclass_=\"ma-5\",\nchildren=[\nv.CardTitle(children=[\"Selection on the map\"]),\nv.CardText(\nchildren=[\nv.Html(\ntag=\"div\",\nchildren=[\"No selection\"],\n)\n]\n),\n],\n)\ndef change_text_map(trace, points, selector):\nmap_text_selection.children[1].children[0].children = [\"Number of entries selected: \" + str(len(points.point_inds))]\nself.selection.setIndexesFromMap(points.point_inds)\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nmap_select.data[0].on_selection(change_text_map)\npart_map = v.Layout(\nclass_=\"d-none ma-0 pa-0\",\nchildren=[map_select, map_text_selection]\n)\nbouton_magic.on_event(\"click\", function_bouton_magic)\nloading_clusters = v.ProgressLinear(\nindeterminate=True, class_=\"ma-3\", style_=\"width : 100%\"\n)\nloading_clusters.class_ = \"d-none\"\npart_for_selection = v.Col(\nchildren=[\ncard_selec,\nout_accordion,\npart_for_clusters,\nloading_clusters,\nresults_clusters,\n]\n)\nloading_models = v.ProgressLinear(\nindeterminate=True,\nclass_=\"my-0 mx-15\",\nstyle_=\"width: 100%;\",\ncolor=\"primary\",\nheight=\"5\",\n)\nloading_models.class_ = \"d-none\"\npart_for_skope = v.Col(children=[two_buttons, accordion_skope, add_group, part_map])\npart_for_modele = widgets.VBox([loading_models, mods])\npart_for_toutes_regions = widgets.VBox([selection, table_regions])\nstages = v.Card(\nclass_=\"w-100 pa-3 ma-3\",\nelevation=\"3\",\nchildren=[\nv.Tabs(\nclass_=\"w-100\",\nv_model=\"tabs\",\nchildren=[\nv.Tab(value=\"one\", children=[\"1. Current selection\"]),\nv.Tab(value=\"two\", children=[\"2. Selection adjustment\"]),\nv.Tab(value=\"three\", children=[\"3. Choice of the sub-model\"]),\nv.Tab(value=\"four\", children=[\"4. Overview of the regions\"]),\n],\n),\nv.CardText(\nclass_=\"w-100\",\nchildren=[\nv.Window(\nclass_=\"w-100\",\nv_model=\"tabs\",\nchildren=[\nv.WindowItem(value=0, children=[part_for_selection]),\nv.WindowItem(value=1, children=[part_for_skope]),\nv.WindowItem(value=2, children=[part_for_modele]),\nv.WindowItem(value=3, children=[part_for_toutes_regions]),\n],\n)\n],\n),\n],\n)\nwidgets.jslink(\n(stages.children[0], \"v_model\"), (stages.children[1].children[0], \"v_model\")\n)\npart_for_data = widgets.VBox(\n[\nbarre_menu,\ndialogue_save,\ntop_of_the_UI_all_buttons,\nfigures,\nstages,\npart_for_magic,\n],\nlayout=Layout(width=\"100%\"),\n)\ndisplay(part_for_data)\n</code></pre>"},{"location":"documentation/gui/#antakia.gui.GUI.getSelection","title":"<code>getSelection()</code>","text":"<p>Function that returns the current selection.</p> <p>Returns:</p> Type Description <code>Potato object</code> <p>The current selection.</p> Source code in <code>antakia/gui.py</code> <pre><code>def getSelection(self):\n\"\"\"Function that returns the current selection.\n    Returns\n    -------\n    Potato object\n        The current selection.\n    \"\"\"\nreturn self.selection\n</code></pre>"},{"location":"documentation/gui/#antakia.gui.GUI.getSubModels","title":"<code>getSubModels()</code>","text":"<p>Function that returns the list of sub-models.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of sub-models.</p> Source code in <code>antakia/gui.py</code> <pre><code>def getSubModels(self):\n\"\"\"Function that returns the list of sub-models.\n    Returns\n    -------\n    list\n        The list of sub-models.\n    \"\"\"\nreturn self.sub_models\n</code></pre>"},{"location":"documentation/gui/#antakia.gui.GUI.setSubModel","title":"<code>setSubModel(sub_models)</code>","text":"<p>Function that sets the list of sub-models.</p> <p>Parameters:</p> Name Type Description Default <code>sub_models</code> <code>list</code> <p>The new list of sub-models.</p> required Source code in <code>antakia/gui.py</code> <pre><code>def setSubModel(self, sub_models):\n\"\"\"Function that sets the list of sub-models.\n    Parameters\n    ----------\n    sub_models : list\n        The new list of sub-models.\n    \"\"\"\nself.sub_models = sub_models\n</code></pre>"},{"location":"documentation/potato/","title":"<code>Potato</code> (Class)","text":"<p>A Potato object! A Potato is a selection of points from the dataset, on wich the user can apply a surrogate-model.</p> <p>Attributes:</p> Name Type Description <code>atk</code> <code>AntakIA object</code> <p>The AntakIA object linked to the potato.</p> <code>indexes</code> <code>list</code> <p>The list of the indexes of the points in the dataset.</p> <code>dataset</code> <code>Dataset object</code> <p>The Dataset object containing the data of the selection.</p> <code>data</code> <code>pandas dataframe</code> <p>The dataframe containing the data of the selection.</p> <code>y</code> <code>list</code> <p>The list of the target values of the selection.</p> <code>sub_model</code> <code>model object</code> <p>The surrogate-model of the selection. Could be None.</p> <code>rules</code> <code>list</code> <p>The list of the rules that defines the selection.</p> <code>score</code> <code>tuple</code> <p>The score of the surrogate-model. Is the following format : (precision, recall, extract of the tree).</p> <code>rules_exp</code> <code>list</code> <p>The list of the rules that defines the selection in the explanation space.</p> <code>score_exp</code> <code>tuple</code> <p>The score of the surrogate-model in the explanation space. Is the following format : (precision, recall, extract of the tree).</p> <code>success</code> <code>bool</code> <p>True if the rules have been found, False otherwise.</p> <code>y_train</code> <code>list</code> <p>The list of the target values of the dataset.</p> <code>explain</code> <code>dict</code> <p>The dict containing the explanations of the selection. Is the following format : {\"Imported\": imported explanations, \"SHAP\": SHAP explanations, \"LIME\": LIME explanations}.</p> <code>state</code> <code>int</code> <p>The state of the potato.</p> <p>Parameters:</p> Name Type Description Default <code>atk</code> <code>AntakIA object</code> <p>The AntakIA object linked to the potato.</p> required <code>array</code> <code>list</code> <p>The list of the indexes of the points in the dataset.</p> <code>[]</code> <code>json_path</code> <code>str</code> <p>The name of the json file containing the indexes of the points in the dataset.</p> <code>None</code> Source code in <code>antakia/potato.py</code> <pre><code>def __init__(self,  atk, array:list = [], json_path: str = None) -&gt; None:\n\"\"\"\n    Constructor of the class Potato.\n    Parameters\n    ----------\n    atk : AntakIA object\n        The AntakIA object linked to the potato.\n    array : list\n        The list of the indexes of the points in the dataset.\n    json_path : str\n        The name of the json file containing the indexes of the points in the dataset.\n    \"\"\"\nimport antakia\nif not isinstance(atk, antakia.AntakIA):\nraise ValueError(\"You must provide an AntakIA object\")\nself.atk = atk\nself.state = Potato.UNKNOWN\nif json_path is not None and array != []:\nraise ValueError(\"You can't provide a list and a json file\")\nif json_path is not None:\nself.state = Potato.JSON\nif json_path[-5:] != \".json\":\njson_path += \".json\"\nfileObject = open(json_path, \"r\")\njsonContent = fileObject.read()\nself.indexes = JSON.loads(jsonContent)\nelse :\nself.indexes = array\nself.dataset = atk.dataset\nif self.dataset.X is not None:\nself.data = self.dataset.X.iloc[self.indexes]\nelse :\nself.data = None\nif self.dataset.y is not None:\nself.y = self.dataset.y.iloc[self.indexes]\nelse :\nself.y = None\nself.sub_model = {\"model\": None, \"score\": None}\nself.rules = None\nself.score = None\nself.rules_exp = None\nself.score_exp = None\nself.success = None\nself.y_train = []\nfor i in range(len(self.dataset.X)):\nif i in self.indexes:\nself.y_train.append(1)\nelse :\nself.y_train.append(0)\nself.indexes_from_map = None\nself.explain = {\"Imported\": None, \"SHAP\": None, \"LIME\": None}\nif self.atk.explain[\"Imported\"] is not None:\nself.explain[\"Imported\"] = self.atk.explain[\"Imported\"].iloc[self.indexes]\nif self.atk.explain[\"SHAP\"] is not None:\nself.explain[\"SHAP\"] = self.atk.explain[\"SHAP\"].iloc[self.indexes]\nif self.atk.explain[\"LIME\"] is not None:\nself.explain[\"LIME\"] = self.atk.explain[\"LIME\"].iloc[self.indexes]\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.__len__","title":"<code>__len__()</code>","text":"<p>The length of the potato.</p> <p>Returns:</p> Type Description <code>int</code> <p>The length of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"\n    The length of the potato.\n    Returns\n    -------\n    int\n        The length of the potato.\n    \"\"\"\nreturn len(self.indexes)\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.applyRules","title":"<code>applyRules(to_return=False)</code>","text":"<p>Function that applies the rules to the dataset, in order to create a new selection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from antakia import AntakIA, Dataset, Potato\n&gt;&gt;&gt; X = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns = [\"col1\", \"col2\", \"col3\"], index = [1, 3, 4])\n&gt;&gt;&gt; atk = AntakIA(Dataset(X, model))\n&gt;&gt;&gt; potato = Potato(indexes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], atk)\n&gt;&gt;&gt; potato.rules = [[0, \"&lt;=\", \"col1\", \"&lt;=\", 9], [3, \"&lt;=\", \"col2\", \"&lt;=\", 8]]\n&gt;&gt;&gt; potato.applyRules()\n&gt;&gt;&gt; potato.indexes\n[3, 4] # only the two last points respect the rules !\n</code></pre> Source code in <code>antakia/potato.py</code> <pre><code>def applyRules(self, to_return:bool=False):\n\"\"\"\n    Function that applies the rules to the dataset, in order to create a new selection.\n    Examples\n    --------\n    &gt;&gt;&gt; from antakia import AntakIA, Dataset, Potato\n    &gt;&gt;&gt; X = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns = [\"col1\", \"col2\", \"col3\"], index = [1, 3, 4])\n    &gt;&gt;&gt; atk = AntakIA(Dataset(X, model))\n    &gt;&gt;&gt; potato = Potato(indexes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], atk)\n    &gt;&gt;&gt; potato.rules = [[0, \"&lt;=\", \"col1\", \"&lt;=\", 9], [3, \"&lt;=\", \"col2\", \"&lt;=\", 8]]\n    &gt;&gt;&gt; potato.applyRules()\n    &gt;&gt;&gt; potato.indexes\n    [3, 4] # only the two last points respect the rules !\n    \"\"\"\nself.state = Potato.SKR\n\"\"\"\n    rules = self.rules\n    df = self.dataset.X\n    for i in range(len(rules)):\n        regle1 = \"df.loc[\" + str(rules[i][0]) + rules[i][1] + \"df['\" + rules[i][2] + \"']]\"\n        regle2 = \"df.loc[\" + \"df['\" + rules[i][2] + \"']\" + rules[i][3] + str(rules[i][4]) + \"]\"\n        df = eval(regle1)\n        df = eval(regle2)\n    self.data = df\n    self.setIndexes(df.index)\n    \"\"\"\nsolo_features = list(set([self.rules[i][2] for i in range(len(self.rules))]))\nnombre_features_rules = []\nfor i in range(len(solo_features)):\nnombre_features_rules.append([])\nfor i in range(len(self.rules)):\nnombre_features_rules[solo_features.index(self.rules[i][2])].append(self.rules[i])\nnouvelle_tuile = self.atk.dataset.X.index\nfor i in range(len(nombre_features_rules)):\nnouvelle_tuile_temp = []\nfor j in range(len(nombre_features_rules[i])):\nX_temp = self.atk.dataset.X[\n(self.atk.dataset.X[nombre_features_rules[i][j][2]] &gt;= nombre_features_rules[i][j][0])\n&amp; (self.atk.dataset.X[nombre_features_rules[i][j][2]] &lt;= nombre_features_rules[i][j][4])\n].index\nnouvelle_tuile_temp = list(nouvelle_tuile_temp) + list(X_temp)\nnouvelle_tuile_temp = list(set(nouvelle_tuile_temp))\nnouvelle_tuile = [g for g in nouvelle_tuile if g in nouvelle_tuile_temp]\nif self.indexes_from_map is not None:\nnouvelle_tuile = [g for g in nouvelle_tuile if g in self.indexes_from_map]\nif to_return:\nreturn nouvelle_tuile\nself.setIndexes(nouvelle_tuile)\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.applySkope","title":"<code>applySkope(explanation, p=0.7, r=0.7)</code>","text":"<p>Function that applies the skope-rules algorithm to the dataset, in order to create a new selection. Must be connected to the AntakIA object (for the explanation space).</p> <p>Parameters:</p> Name Type Description Default <code>explanation</code> <code>str</code> <p>The name of the explanation to use.</p> required <code>p</code> <code>float = 0.7</code> <p>The minimum precision of the rules.</p> <code>0.7</code> <code>r</code> <code>float = 0.7</code> <p>The minimum recall of the rules.</p> <code>0.7</code> Source code in <code>antakia/potato.py</code> <pre><code>def applySkope(self, explanation, p:float = 0.7, r:float = 0.7):\n\"\"\"\n    Function that applies the skope-rules algorithm to the dataset, in order to create a new selection.\n    Must be connected to the AntakIA object (for the explanation space).\n    Parameters\n    ----------\n    explanation : str\n        The name of the explanation to use.\n    p : float = 0.7\n        The minimum precision of the rules.\n    r : float = 0.7\n        The minimum recall of the rules.\n    \"\"\"\nif self.atk.explain[explanation] is None:\nraise ValueError(\"You must provide a valid explanation space\")\ny_train = np.zeros(len(self.dataset.X))\ny_train[self.indexes] = 1\nskope_rules_clf = SkopeRules(\nfeature_names=self.dataset.X.columns,\nrandom_state=42,\nn_estimators=5,\nrecall_min=r,\nprecision_min=p,\nmax_depth_duplication=0,\nmax_samples=1.0,\nmax_depth=3,\n)\nskope_rules_clf.fit(self.dataset.X, y_train)\nskope_rules_clf_exp = SkopeRules(\nfeature_names=self.atk.explain[explanation].columns,\nrandom_state=42,\nn_estimators=5,\nrecall_min=r,\nprecision_min=p,\nmax_depth_duplication=0,\nmax_samples=1.0,\nmax_depth=3,\n)\nskope_rules_clf_exp.fit(self.atk.explain[explanation], y_train)\nif skope_rules_clf.rules_ == [] or skope_rules_clf_exp.rules_ == []:\nself.rules, self.score_skope, self.rules_exp, self.score_skope_exp = None, None, None, None\nself.success = False\nself.__error_message(\"No rules found for this precision and recall\")\nelse :\nself.rules, self.score = self.__transform_rules(skope_rules_clf.rules_, self.dataset.X)\nself.rules_exp, self.score_exp = self.__transform_rules(skope_rules_clf_exp.rules_, self.atk.explain[explanation])\nself.checkForDuplicates()\nself.applyRules()\nself.success = True\nself.state = Potato.SKR\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.checkForDuplicates","title":"<code>checkForDuplicates()</code>","text":"<p>Function that checks if there are duplicates in the rules. A duplicate is a rule that has the same feature as another rule, but with a different threshold.</p> Source code in <code>antakia/potato.py</code> <pre><code>def checkForDuplicates(self):\n\"\"\"\n    Function that checks if there are duplicates in the rules.\n    A duplicate is a rule that has the same feature as another rule, but with a different threshold.\n    \"\"\"\nfeatures = [self.rules[i][2] for i in range(len(self.rules))]\nfeatures_alone = list(set(features))\nif len(features) == len(features_alone):\nreturn\nelse :\nfor feature in features:\nif features.count(feature) &gt; 1:\na=0\nfor i in range(len(self.rules)):\nmin_feature = -10e99\nmax_feature = 10e99\nif self.rules[i-a][2] == feature:\nif self.rules[i-a][0] &gt; min_feature:\nmin_feature = self.rules[i-a][0]\nif self.rules[i-a][4] &lt; max_feature:\nmax_feature = self.rules[i-a][4]\nself.rules.pop(i-a)\na+=1\nself.rules.append([min_feature, \"&lt;=\", feature, \"&lt;=\", max_feature])\n# same thing for the explanation space\nfeatures = [self.rules_exp[i][2] for i in range(len(self.rules_exp))]\nfeatures_alone = list(set(features))\nif len(features) == len(features_alone):\nreturn\nelse :\nfor feature in features:\nif features.count(feature) &gt; 1:\na=0\nfor i in range(len(self.rules_exp)):\nmin_feature = -10e99\nmax_feature = 10e99\nif self.rules_exp[i-a][2] == feature:\nif self.rules_exp[i-a][0] &gt; min_feature:\nmin_feature = self.rules_exp[i-a][0]\nif self.rules_exp[i-a][4] &lt; max_feature:\nmax_feature = self.rules_exp[i-a][4]\nself.rules_exp.pop(i-a)\na+=1\nself.rules_exp.append([min_feature, \"&lt;=\", feature, \"&lt;=\", max_feature])\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.getESdata","title":"<code>getESdata(explanation='Imported')</code>","text":"<p>Function that returns the data of the potato in the explanation space.</p> <p>Parameters:</p> Name Type Description Default <code>explanation</code> <code>str</code> <p>The name of the explanation space.</p> <code>'Imported'</code> <p>Returns:</p> Type Description <code>pandas dataframe</code> <p>The data of the potato in the explanation space.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getESdata(self, explanation=\"Imported\") -&gt; list:\n\"\"\"\n    Function that returns the data of the potato in the explanation space.\n    Parameters\n    ----------\n    explanation : str\n        The name of the explanation space.\n    Returns\n    -------\n    pandas dataframe\n        The data of the potato in the explanation space.\n    \"\"\"\nreturn self.explain[explanation]\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.getESrules","title":"<code>getESrules()</code>","text":"<p>Function that returns the rules of the potato in the explanation space.</p> <p>Returns:</p> Type Description <code>list</code> <p>The rules of the potato in the explanation space.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getESrules(self):\n\"\"\"\n    Function that returns the rules of the potato in the explanation space.\n    Returns\n    -------\n    list\n        The rules of the potato in the explanation space.\n    \"\"\"\nreturn self.rules_exp\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.getESscore","title":"<code>getESscore()</code>","text":"<p>Function that returns the score of the potato in the explanation space.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>The score of the potato in the explanation space.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getESscore(self):\n\"\"\"\n    Function that returns the score of the potato in the explanation space.\n    Returns\n    -------\n    tuple\n        The score of the potato in the explanation space.\n    \"\"\"\nreturn self.score_exp\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.getIndexes","title":"<code>getIndexes()</code>","text":"<p>Function that returns the indexes of the potato.</p> <p>Returns:</p> Type Description <code>list</code> <p>The indexes of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getIndexes(self) -&gt; list:\n\"\"\"\n    Function that returns the indexes of the potato.\n    Returns\n    -------\n    list\n        The indexes of the potato.\n    \"\"\"\nreturn self.indexes\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.getSubModel","title":"<code>getSubModel()</code>","text":"<p>Function that returns the sub-model of the potato.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The sub-model of the potato. Is the following format : {\"model\": model object, \"score\": score of the model}.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getSubModel(self):\n\"\"\"\n    Function that returns the sub-model of the potato.\n    Returns\n    -------\n    dict\n        The sub-model of the potato. Is the following format : {\"model\": model object, \"score\": score of the model}.\n    \"\"\"\nreturn self.sub_model\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.getVSdata","title":"<code>getVSdata()</code>","text":"<p>Function that returns the data of the potato.</p> <p>Returns:</p> Type Description <code>pandas dataframe</code> <p>The data of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getVSdata(self) -&gt; pd.DataFrame:\n\"\"\"\n    Function that returns the data of the potato.\n    Returns\n    -------\n    pandas dataframe\n        The data of the potato.\n    \"\"\"\nreturn self.data\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.getVSrules","title":"<code>getVSrules()</code>","text":"<p>Function that returns the rules of the potato.</p> <p>Returns:</p> Type Description <code>list</code> <p>The rules of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getVSrules(self):\n\"\"\"\n    Function that returns the rules of the potato.\n    Returns\n    -------\n    list\n        The rules of the potato.\n    \"\"\"\nreturn self.rules\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.getVSscore","title":"<code>getVSscore()</code>","text":"<p>Function that returns the score of the potato.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>The score of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getVSscore(self):\n\"\"\"\n    Function that returns the score of the potato.\n    Returns\n    -------\n    tuple\n        The score of the potato.\n    \"\"\"\nreturn self.score\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.printRules","title":"<code>printRules()</code>","text":"<p>Function that prints the rules of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def printRules(self):\n\"\"\"\n    Function that prints the rules of the potato.\n    \"\"\"\nif self.rules is None:\nprint(\"No rules\")\nelse :\nself.pretty_print(self.rules, ch3 = '-', ch2=\" \")\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.respectOneRule","title":"<code>respectOneRule(index)</code>","text":"<p>Function that returns the points of the dataset that respect only one rule of the list of rules.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the rule to respect.</p> required <p>Returns:</p> Type Description <code>pandas dataframe</code> <p>The dataframe containing the points of the dataset that respect only one rule of the list of rules.</p> Source code in <code>antakia/potato.py</code> <pre><code>def respectOneRule(self, index:int):\n\"\"\"\n    Function that returns the points of the dataset that respect only one rule of the list of rules.\n    Parameters\n    ----------\n    index : int\n        The index of the rule to respect.\n    Returns\n    -------\n    pandas dataframe\n        The dataframe containing the points of the dataset that respect only one rule of the list of rules.\n    \"\"\"\nrules = self.rules\ndf = deepcopy(self.dataset.X)\nregle1 = \"df.loc[\" + str(rules[index][0]) + rules[index][1] + \"df['\" + rules[index][2] + \"']]\"\nregle2 = \"df.loc[\" + \"df['\" + rules[index][2] + \"']\" + rules[index][3] + str(rules[index][4]) + \"]\"\ndf = eval(regle1)\ndf = eval(regle2)\nreturn df\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.setIndexes","title":"<code>setIndexes(indexes)</code>","text":"<p>Function that sets the indexes of the potato.</p> <p>Parameters:</p> Name Type Description Default <code>indexes</code> <code>list</code> <p>The new indexes of the potato.</p> required Source code in <code>antakia/potato.py</code> <pre><code>def setIndexes(self, indexes:list) -&gt; None:\n\"\"\"\n    Function that sets the indexes of the potato.\n    Parameters\n    ----------\n    indexes : list\n        The new indexes of the potato.\n    \"\"\"\nself.indexes = indexes\nself.data = self.dataset.X.iloc[self.indexes]\nself.y = self.dataset.y.iloc[self.indexes]\nself.y_train = []\nfor i in range(len(self.dataset.X)):\nif i in self.indexes:\nself.y_train.append(1)\nelse :\nself.y_train.append(0)\nself.state = Potato.LASSO\nself.success = None\nself.explain = {\"Imported\": None, \"SHAP\": None, \"LIME\": None}\nif self.atk.explain[\"Imported\"] is not None:\nself.explain[\"Imported\"] = self.atk.explain[\"Imported\"].iloc[self.indexes]\nif self.atk.explain[\"SHAP\"] is not None:\nself.explain[\"SHAP\"] = self.atk.explain[\"SHAP\"].iloc[self.indexes]\nif self.atk.explain[\"LIME\"] is not None:\nself.explain[\"LIME\"] = self.atk.explain[\"LIME\"].iloc[self.indexes]\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.setIndexesFromMap","title":"<code>setIndexesFromMap(indexes)</code>","text":"<p>Function that sets the indexes of the potato from a map.</p> <p>Parameters:</p> Name Type Description Default <code>indexes</code> <code>list</code> <p>The new indexes of the potato.</p> required Source code in <code>antakia/potato.py</code> <pre><code>def setIndexesFromMap(self, indexes:list) -&gt; None:\n\"\"\"\n    Function that sets the indexes of the potato from a map.\n    Parameters\n    ----------\n    indexes : list\n        The new indexes of the potato.\n    \"\"\"\nself.indexes_from_map = indexes\nself.applyRules()\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.setSubModel","title":"<code>setSubModel(model)</code>","text":"<p>Function that sets the sub-model of the potato.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>model object</code> <p>The new sub-model of the potato.</p> required Source code in <code>antakia/potato.py</code> <pre><code>def setSubModel(self, model) -&gt; None:\n\"\"\"\n    Function that sets the sub-model of the potato.\n    Parameters\n    ----------\n    model : model object\n        The new sub-model of the potato.\n    \"\"\"\nself.sub_model[\"model\"] = model\nmodel.fit(self.data, self.y)\nself.sub_model[\"score\"] = model.score(self.data, self.y)\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.size","title":"<code>size()</code>","text":"<p>Function that returns the shape of the potato.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>The shape of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def size(self) -&gt; int:\n\"\"\"\n    Function that returns the shape of the potato.\n    Returns\n    -------\n    tuple\n        The shape of the potato.\n    \"\"\"\nreturn len(self.indexes)\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.stateToSring","title":"<code>stateToSring()</code>","text":"<p>Returns the state of the potato</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the state</p> Source code in <code>antakia/potato.py</code> <pre><code>def stateToSring(self)-&gt; str :\n\"\"\"\n    Returns the state of the potato\n    Returns\n    -------\n    str\n        The name of the state\n    \"\"\"\nif self.state == Potato.UNKNOWN : return \"unknown\"\nelif self.state == Potato.LASSO : return \"lasso\"\nelif self.state == Potato.SKR : return \"skope ruled\"\nelif self.state == Potato.REFINED_SKR : return \"refined skope rules\"\nelif self.state == Potato.REGION : return \"region\"\nelif self.state == Potato.JSON : return \"json importation\"\nelse : raise ValueError(\"unknown state for a potato\")\n</code></pre>"},{"location":"documentation/potato/#antakia.potato.Potato.toJson","title":"<code>toJson()</code>","text":"<p>Function that returns the potato in the form of a json file.</p> <p>Returns:</p> Type Description <code>json</code> <p>The potato in the form of a json file.</p> Source code in <code>antakia/potato.py</code> <pre><code>def toJson(self):\n\"\"\"\n    Function that returns the potato in the form of a json file.\n    Returns\n    -------\n    json\n        The potato in the form of a json file.\n    \"\"\"\nreturn {\"indexes\": self.indexes, \"state\": self.state, \"rules\": self.rules, \"score\": self.score, \"rules_exp\": self.rules_exp, \"score_exp\": self.score_exp, \"sub_model\": self.sub_model, \"success\": self.success}\n</code></pre>"},{"location":"documentation/utils/","title":"<code>utils</code> (Set of functions)","text":"<p>Package AntakIA de AI-vidence</p>"},{"location":"documentation/utils/#antakia.utils.AntakIA","title":"<code>AntakIA(dataset, import_explanation=None, saves=None, saves_path=None)</code>","text":"<p>AntakIA object. This main class of the antakia package. It contains all the data and variables needed to run the interface (see antakia.GUI).</p> <p>Attributes:</p> Name Type Description <code>dataset</code> <code>Dataset object</code> <p>The Dataset object containing the data to explain. For more information, please see the documentation of the class Dataset.</p> <code>explain</code> <code>dict</code> <p>The dictionary containing the explanations. The keys are the names of the explanations (for example \"SHAP\" or \"LIME\"). The explanations are pandas dataframes. You can import your own explanations using <code>import_explanation</code>.</p> <code>regions</code> <code>list</code> <p>The list of the regions computed by the user. A region is an AntakIA object, named Potato. For more information, please see the documentation of the class Potato.</p> <code>saves</code> <code>list</code> <p>The list of the saves. A save is a list of regions.</p> <code>gui</code> <code>GUI object</code> <p>The GUI object is in charge of the interface. For more information, please see the documentation of the class GUI.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset object</code> <p>The Dataset object containing the data to explain.</p> required <code>import_explanation</code> <code>pandas dataframe</code> <p>The dataframe containing the explanations. The dataframe must have the same number of rows as the dataset. The GUI can compute other types of explanations using different methods.</p> <code>None</code> Source code in <code>antakia/antakia.py</code> <pre><code>def __init__(self, dataset: Dataset, import_explanation: pd.DataFrame = None, saves: dict = None, saves_path: str = None):\n\"\"\"\n    Constructor of the class AntakIA.\n    Parameters\n    ---------\n    dataset : Dataset object\n        The Dataset object containing the data to explain.\n    import_explanation : pandas dataframe\n        The dataframe containing the explanations. The dataframe must have the same number of rows as the dataset.\n        The GUI can compute other types of explanations using different methods.\n    \"\"\"\nself.dataset = dataset\nself.regions = []\nself.gui = None\nself.explain = dict()\nif import_explanation is not None:\nself.explain[\"Imported\"] = import_explanation.iloc[dataset.frac_indexes].reset_index(drop=True)\nelse:\nself.explain[\"Imported\"] = None\nself.explain[\"SHAP\"] = None\nself.explain[\"LIME\"] = None\nif saves is not None:\nself.saves = saves\nelif saves_path is not None:\nself.saves = utils.load_save(self, saves_path)\nelse:\nself.saves = []\nself.widget = None\nself.gui = GUI(self)\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.AntakIA.computeDyadicClustering","title":"<code>computeDyadicClustering(explanation='Imported', min_clusters=3, automatic=True, sub_models=False)</code>","text":"<p>Function that computes the dyadic-clustering. Our dyadic-clustering (sometimes found as co-clusetring or bi-clustering), uses <code>mvlearn</code> and <code>skope-rules</code> to compute the clusters.</p> <p>Parameters:</p> Name Type Description Default <code>explanation</code> <code>str</code> <p>The type of explanation to use. The possible values are \"Imported\", \"SHAP\" and \"LIME\".</p> <code>'Imported'</code> <code>min_clusters</code> <code>int</code> <p>The minimum number of clusters to compute.</p> <code>3</code> <code>automatic</code> <code>bool</code> <p>If True, the number of clusters is computed automatically, respecting the minimum number of clusters.</p> <code>True</code> <code>sub_models</code> <code>bool</code> <p>If True, the best model for each region is computed. The possible models are the ones in the list sub_models.</p> <code>False</code> Source code in <code>antakia/antakia.py</code> <pre><code>def computeDyadicClustering(self, explanation:str = \"Imported\", min_clusters:int = 3, automatic:bool = True, sub_models:bool = False):\n\"\"\"\n    Function that computes the dyadic-clustering.\n    Our dyadic-clustering (sometimes found as co-clusetring or bi-clustering), uses `mvlearn` and `skope-rules` to compute the clusters.\n    Parameters\n    ---------\n    explanation : str\n        The type of explanation to use.\n        The possible values are \"Imported\", \"SHAP\" and \"LIME\".\n    min_clusters : int\n        The minimum number of clusters to compute.\n    automatic : bool\n        If True, the number of clusters is computed automatically, respecting the minimum number of clusters.\n    sub_models : bool\n        If True, the best model for each region is computed. The possible models are the ones in the list sub_models.\n    \"\"\"\nif self.explain[explanation] is None:\nraise ValueError(\"You must compute the explanations before computing the dyadic-clustering!\")\nif min_clusters &lt;2 or min_clusters &gt; len(self.dataset.X):\nraise ValueError(\"The minimum number of clusters must be between 2 and the number of observations!\")\nclusters, clusters_axis = function_auto_clustering(self.dataset.X, self.explain[explanation], min_clusters, automatic)\nself.regions = []\nfor i in range(len(clusters)):\nself.regions.append(Potato(self, clusters[i]))\nif sub_models:\nself.regions[i].sub_model[\"model\"], self.regions[i].sub_model[\"score\"] = self.__find_best_model(self.regions[i].data, self.regions[i].y, self.gui.sub_models)\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.AntakIA.computeLIME","title":"<code>computeLIME(verbose=True)</code>","text":"<p>Computes the LIME values of the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, a progress bar is displayed.</p> <code>True</code>"},{"location":"documentation/utils/#antakia.utils.AntakIA.computeLIME--see-also","title":"See also:","text":"<p>The Lime library on GitHub : https://github.com/marcotcr/lime/tree/master</p> Source code in <code>antakia/antakia.py</code> <pre><code>def computeLIME(self, verbose:bool = True):\n\"\"\"\n    Computes the LIME values of the dataset.\n    Parameters\n    ---------\n    verbose : bool\n        If True, a progress bar is displayed.\n    See also:\n    ---------\n    The Lime library on GitHub : https://github.com/marcotcr/lime/tree/master\n    \"\"\"\nlime = compute.computationSHAP(self.dataset.X, self.dataset.X_all, self.dataset.model)\nif verbose:\nself.verbose = self.__create_progress(\"LIME\")\nwidgets.jslink((self.widget.children[1], \"v_model\"), (lime.progress_widget, \"v_model\"))\nwidgets.jslink((self.widget.children[2], \"v_model\"), (lime.text_widget, \"v_model\"))\ndisplay(self.widget)\nself.explain[\"LIME\"] = lime.compute()\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.AntakIA.computeSHAP","title":"<code>computeSHAP(verbose=True)</code>","text":"<p>Computes the SHAP values of the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, a progress bar is displayed.</p> <code>True</code>"},{"location":"documentation/utils/#antakia.utils.AntakIA.computeSHAP--see-also","title":"See also:","text":"<p>The Shap library on GitHub : https://github.com/shap/shap/tree/master</p> Source code in <code>antakia/antakia.py</code> <pre><code>def computeSHAP(self, verbose:bool = True):\n\"\"\"\n    Computes the SHAP values of the dataset.\n    Parameters\n    ---------\n    verbose : bool\n        If True, a progress bar is displayed.\n    See also:\n    ---------\n    The Shap library on GitHub : https://github.com/shap/shap/tree/master\n    \"\"\"\nshap = compute.computationSHAP(self.dataset.X, self.dataset.X_all, self.dataset.model)\nif verbose:\nself.verbose = self.__create_progress(\"SHAP\")\nwidgets.jslink((self.widget.children[1], \"v_model\"), (shap.progress_widget, \"v_model\"))\nwidgets.jslink((self.widget.children[2], \"v_model\"), (shap.text_widget, \"v_model\"))\ndisplay(self.widget)\nself.explain[\"SHAP\"] = shap.compute()\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.AntakIA.getDataset","title":"<code>getDataset()</code>","text":"<p>Function that returns the Dataset object containing the data to explain. For more information, please see the documentation of the class Dataset.</p> <p>Returns:</p> Type Description <code>Dataset object</code> <p>The Dataset object.</p> Source code in <code>antakia/antakia.py</code> <pre><code>def getDataset(self) -&gt; Dataset:\n\"\"\"\n    Function that returns the Dataset object containing the data to explain.\n    For more information, please see the documentation of the class Dataset.\n    Returns\n    -------\n    Dataset object\n        The Dataset object.\n    \"\"\"\nreturn self.dataset\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.AntakIA.getExplanations","title":"<code>getExplanations(method=None)</code>","text":"<p>Function that returns the dictionary containing the explanations. The keys are the names of the explanations (for example \"SHAP\" or \"LIME\"). The explanations are pandas dataframes.</p> <p>Returns:</p> Type Description <code>dict or pandas dataframe</code> <p>The dictionary containing the explanations or the explanation corresponding to the key explanation.</p> Source code in <code>antakia/antakia.py</code> <pre><code>def getExplanations(self, method=None) -&gt; dict:\n\"\"\"\n    Function that returns the dictionary containing the explanations.\n    The keys are the names of the explanations (for example \"SHAP\" or \"LIME\"). The explanations are pandas dataframes.\n    Returns\n    -------\n    dict or pandas dataframe\n        The dictionary containing the explanations or the explanation corresponding to the key explanation.\n    \"\"\"\nif method is None:\nreturn self.explain\ntry :\nreturn self.explain[method]\nexcept KeyError:\nraise KeyError(\"The method \" + method + \" is not a valid method. The possible methods are \" + str(list(self.explain.keys())) + \".\")\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.AntakIA.getGUI","title":"<code>getGUI()</code>","text":"<p>Function that returns the GUI object. For more information, please see the documentation of the class GUI.</p> <p>Returns:</p> Type Description <code>GUI object</code> <p>The GUI object.</p> Source code in <code>antakia/antakia.py</code> <pre><code>def getGUI(self) -&gt; GUI:\n\"\"\"\n    Function that returns the GUI object.\n    For more information, please see the documentation of the class GUI.\n    Returns\n    -------\n    GUI object\n        The GUI object.\n    \"\"\"\nreturn self.gui\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.AntakIA.getRegions","title":"<code>getRegions()</code>","text":"<p>Function that returns the list of the regions computed by the user.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of the regions computed. A region is a list of AntakIA objects, named <code>Potato</code>.</p> Source code in <code>antakia/antakia.py</code> <pre><code>def getRegions(self) -&gt; list:\n\"\"\"\n    Function that returns the list of the regions computed by the user.\n    Returns\n    -------\n    list\n        The list of the regions computed. A region is a list of AntakIA objects, named `Potato`.\n    \"\"\"\nreturn self.regions\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.AntakIA.getSaves","title":"<code>getSaves()</code>","text":"<p>Function that returns the list of the saves.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of the saves. A save is a list of regions.</p> Source code in <code>antakia/antakia.py</code> <pre><code>def getSaves(self) -&gt; list:\n\"\"\"\n    Function that returns the list of the saves.\n    Returns\n    -------\n    list\n        The list of the saves. A save is a list of regions.\n    \"\"\"\nreturn self.saves\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.AntakIA.newRegion","title":"<code>newRegion(potato)</code>","text":"<p>Function that adds a region to the list of regions.</p> <p>Parameters:</p> Name Type Description Default <code>potato</code> <code>Potato object</code> <p>The Potato object to add to the list of regions.</p> required Source code in <code>antakia/antakia.py</code> <pre><code>def newRegion(self, potato: Potato):\n\"\"\"\n    Function that adds a region to the list of regions.\n    Parameters\n    ---------\n    potato : Potato object\n        The Potato object to add to the list of regions.\n    \"\"\"\nself.regions.append(potato)\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.AntakIA.resetRegions","title":"<code>resetRegions()</code>","text":"<p>Function that resets the list of the regions computed by the user.</p> Source code in <code>antakia/antakia.py</code> <pre><code>def resetRegions(self):\n\"\"\"\n    Function that resets the list of the regions computed by the user.\n    \"\"\"\nself.regions = []\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.AntakIA.startGUI","title":"<code>startGUI(explanation=None, projection='PaCMAP', sub_models=None, display=True)</code>","text":"<p>Function that instantiates the GUI and calls its display() function. For more information, please see the documentation of the class GUI.</p> <p>Parameters:</p> Name Type Description Default <code>explanation</code> <code>str</code> <p>The type of explanation to use. If an explanation is already computed (see antakia.dataset), it is used by default. If not, the user must choose between \"SHAP\" and \"LIME\". The explanatory values caen be computed directly in the interface!</p> <code>None</code> <code>projection</code> <code>str</code> <p>The default projection to use. The possible values are \"PaCMAP\", \"PCA\", \"t-SNE\" and \"UMAP\".</p> <code>'PaCMAP'</code> <code>sub_models</code> <code>list</code> <p>The list of the sub_models to choose from for each region. The only constraint is that sub_models must have a predict method.</p> <code>None</code> <code>display</code> <code>bool</code> <p>If True, the interface is displayed. Else, You can access the interface with the attribute gui of the class.</p> <code>True</code> Source code in <code>antakia/antakia.py</code> <pre><code>def startGUI(self,\nexplanation: str = None,\nprojection: str = \"PaCMAP\",\nsub_models: list = None,\ndisplay = True) -&gt; GUI:\n\"\"\"\n    Function that instantiates the GUI and calls its display() function.\n    For more information, please see the documentation of the class GUI.\n    Parameters\n    ---------\n    explanation : str\n        The type of explanation to use. If an explanation is already computed (see antakia.dataset), it is used by default. If not, the user must choose between \"SHAP\" and \"LIME\".\n        The explanatory values caen be computed directly in the interface!\n    projection : str\n        The default projection to use. The possible values are \"PaCMAP\", \"PCA\", \"t-SNE\" and \"UMAP\".\n    sub_models : list\n        The list of the sub_models to choose from for each region. The only constraint is that sub_models must have a predict method.\n    display : bool\n        If True, the interface is displayed. Else, You can access the interface with the attribute gui of the class.\n    \"\"\"\nself.gui = GUI(self, explanation, projection, sub_models)\nif display:\nself.gui.display()\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Dataset","title":"<code>Dataset(X=None, csv=None, y=None, model=None)</code>","text":"<p>Dataset object. This object contains the all data, the model to explain, the explanations and the predictions.</p> <p>Attributes:</p> Name Type Description <code>X</code> <code>pandas dataframe</code> <p>The dataframe containing the dataset (might not be the entire dataset, see <code>frac</code> method)</p> <code>X_all</code> <code>pandas dataframe</code> <p>The dataframe containing the entire dataset, in order for the explanations to be computed.</p> <code>X_scaled</code> <code>pandas dataframe</code> <p>The dataframe containing the scaled dataset.</p> <code>y</code> <code>pandas series</code> <p>The series containing the target values.</p> <code>model</code> <code>model object</code> <p>The \"black-box\" model to explain.</p> <code>y_pred</code> <code>pandas series</code> <p>The series containing the predictions of the model. If None, the predictions are computed using the model and the data.</p> <code>comments</code> <code>list of str</code> <p>The comments associated to each feature.</p> <code>sensible</code> <code>list of bool</code> <p>The list of boolean indicating if the feature is sensible or not. If True, a warning will be displayed when the feature is used in the explanations. More to come in the future.</p> <code>lat</code> <code>str</code> <p>The name of the latitude column.</p> <code>long</code> <code>str</code> <p>The name of the longitude column.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>pandas dataframe</code> <p>The dataframe containing the dataset.</p> <code>None</code> <code>csv</code> <code>str</code> <p>The path to the csv file containing the dataset.</p> <code>None</code> <code>y</code> <code>pandas series</code> <p>The series containing the target values.</p> <code>None</code> <code>model</code> <code>model object</code> <p>The \"black-box\" model to explain. The model must have a predict method.</p> <code>None</code> Source code in <code>antakia/dataset.py</code> <pre><code>def __init__(self, X:pd.DataFrame = None, csv:str = None, y:pd.Series = None, model = None):\n\"\"\"\n    Constructor of the class Dataset.\n    Parameters\n    ---------\n    X : pandas dataframe\n        The dataframe containing the dataset.\n    csv : str\n        The path to the csv file containing the dataset.\n    y : pandas series\n        The series containing the target values.\n    model : model object\n        The \"black-box\" model to explain. The model must have a predict method.\n    \"\"\"\nX.columns = [X.columns[i].replace(\" \", \"_\") for i in range(len(X.columns))]\nX = X.reset_index(drop=True)\nif X is None and csv is None :\nraise ValueError(\"You must provide a dataframe or a csv file\")\nif X is not None and csv is not None :\nraise ValueError(\"You must provide either a dataframe or a csv file, not both\")\nif X is not None :\nself.X = X\nelse :\nself.X = pd.read_csv(csv)\nself.X_all = X\nself.model = model\nself.y = y\nself.X_scaled = pd.DataFrame(StandardScaler().fit_transform(X))\nself.X_scaled.columns = X.columns\nself.y_pred = pd.Series(self.model.predict(self.X))\nself.verbose = None\nself.widget = None\nself.comments = [\"\"]*len(self.X.columns)\nself.sensible = [False]*len(self.X.columns)\nself.fraction = 1\nself.frac_indexes = self.X.index\nself.long, self.lat = None, None\nfor name in ['longitude', 'Longitude', 'Long', 'long']:\nif name in self.X.columns:\nself.long = name\nfor name in ['latitude', 'Latitude', 'Lat', 'lat']:\nif name in self.X.columns:\nself.lat = name\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Dataset.frac","title":"<code>frac(p)</code>","text":"<p>Reduces the dataset to a fraction of its size.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>The fraction of the dataset to keep.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import antakia\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; X = pd.DataFrame([[1, 2], [3, 4], [5, 6], [7, 8]], columns=[\"a\", \"b\"])\n&gt;&gt;&gt; my_dataset = antakia.Dataset(X, model)\n&gt;&gt;&gt; my_dataset.frac(0.5)\n&gt;&gt;&gt; my_dataset.X\n      a  b\n0     1  2\n1     5  6\n</code></pre> Source code in <code>antakia/dataset.py</code> <pre><code>def frac(self, p:float):\n\"\"\"\n    Reduces the dataset to a fraction of its size.\n    Parameters\n    ---------\n    p : float\n        The fraction of the dataset to keep.\n    Examples\n    --------\n    &gt;&gt;&gt; import antakia\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; X = pd.DataFrame([[1, 2], [3, 4], [5, 6], [7, 8]], columns=[\"a\", \"b\"])\n    &gt;&gt;&gt; my_dataset = antakia.Dataset(X, model)\n    &gt;&gt;&gt; my_dataset.frac(0.5)\n    &gt;&gt;&gt; my_dataset.X\n          a  b\n    0     1  2\n    1     5  6\n    \"\"\"\nself.X = self.X_all.sample(frac=p, random_state=9)\nself.frac_indexes = deepcopy(self.X.index)\nself.X_scaled = self.X_scaled.iloc[self.frac_indexes].reset_index(drop=True)\nself.y_pred = self.y_pred.iloc[self.frac_indexes].reset_index(drop=True)\nif self.y is not None:\nself.y = self.y.iloc[self.frac_indexes].reset_index(drop=True)\nself.fraction = p\nself.X.reset_index(drop=True, inplace=True)\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Dataset.getLongLat","title":"<code>getLongLat()</code>","text":"<p>Returns the longitude and latitude columns of the dataset.</p> <p>Returns:</p> Name Type Description <code>long</code> <code>str</code> <p>The name of the longitude column.</p> <code>lat</code> <code>str</code> <p>The name of the latitude column.</p> Source code in <code>antakia/dataset.py</code> <pre><code>def getLongLat(self):\n\"\"\"\n    Returns the longitude and latitude columns of the dataset.\n    Returns\n    -------\n    long : str\n        The name of the longitude column.\n    lat : str\n        The name of the latitude column.\n    \"\"\"\nreturn self.long, self.lat\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Dataset.improve","title":"<code>improve()</code>","text":"<p>Improves the dataset. Displays a widget to modify the dataset. For each feature, you can change its name, its type, its comment and if it is sensible or not. You also have the access to the general informations of the dataset.</p> Source code in <code>antakia/dataset.py</code> <pre><code>def improve(self):\n\"\"\"\n    Improves the dataset. Displays a widget to modify the dataset. For each feature, you can change its name, its type, its comment and if it is sensible or not.\n    You also have the access to the general informations of the dataset.\n    \"\"\"\ngeneral_infos = v.Row(class_=\"ma-2\", children=[\nv.Icon(children=[\"mdi-database\"], size=\"30px\"),\nv.Html(tag=\"h3\", class_=\"mb-3 mt-3 ml-4\", children=[\nstr(self.X.shape[0]) + \" observations, \" + str(self.X.shape[1]) + \" features\"\n])])\nliste_slides = []\nfor i in range(self.X.shape[1]):\ninfos = [min(self.X.iloc[:,i]), max(self.X.iloc[:,i]), np.mean(self.X.iloc[:,i]), np.std(self.X.iloc[:,i])]\ninfos = [round(infos[j], 3) for j in range(len(infos))]\nliste_slides.append(gui_elements.create_slide_dataset(self.X.columns[i], i+1, self.X.dtypes[i], len(self.X.columns), self.comments[i], self.sensible[i], infos))\nslidegroup = v.SlideGroup(\nv_model=None,\nclass_=\"ma-3 pa-3\",\nelevation=4,\ncenter_active=True,\nshow_arrows=True,\nchildren=liste_slides,\n)\ndef changement_sensible(widget, event, data):\ni = int(widget.class_)-1\nif widget.v_model :\nliste_slides[i].children[0].color = \"red lighten-5\"\nself.sensible[i] = True\nelse:\nliste_slides[i].children[0].color = \"white\"\nself.sensible[i] = False\ndef changement_names(widget, event, data):\ni = widget.value-1\nself.X = self.X.rename(columns={self.X.columns[i]: widget.v_model})\ndef changement_type(widget, event, data):\ni = widget.value-1\nwidget2 = liste_slides[i].children[0].children[-1].children[1].children[0]\ntry :\nself.X = self.X.astype({self.X.columns[i]: widget2.v_model})\nexcept:\nprint(\"The type of the column \" + self.X.columns[i] + \" cannot be changed to \" + widget2.v_model)\nwidget.color = \"error\"\ntime.sleep(2)\nwidget.color = \"\"\nelse:\nwidget.color = \"success\"\ntime.sleep(2)\nwidget.color = \"\"\ndef changement_comment(widget, event, data):\ni = widget.value-1\nself.comments[i] = widget.v_model\nfor i in range(len(liste_slides)):\nliste_slides[i].children[0].children[-1].children[2].on_event(\"change\", changement_sensible)\nliste_slides[i].children[0].children[-1].children[3].on_event(\"change\", changement_comment)\nliste_slides[i].children[0].children[0].children[0].on_event(\"change\", changement_names)\nliste_slides[i].children[0].children[-1].children[1].children[-1].on_event(\"click\", changement_type)\nwidget = v.Col(children=[\ngeneral_infos,\nslidegroup,\n])\ndisplay(widget)\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Dataset.setLongLat","title":"<code>setLongLat(long, lat)</code>","text":"<p>Sets the longitude and latitude columns of the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>long</code> <code>str</code> <p>The name of the longitude column.</p> required <code>lat</code> <code>str</code> <p>The name of the latitude column.</p> required Source code in <code>antakia/dataset.py</code> <pre><code>def setLongLat(self, long:str, lat:str):\n\"\"\"\n    Sets the longitude and latitude columns of the dataset.\n    Parameters\n    ---------\n    long : str\n        The name of the longitude column.\n    lat : str\n        The name of the latitude column.\n    \"\"\"\nself.long = long\nself.lat = lat\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.GUI","title":"<code>GUI(atk, explanation=None, projection='PaCMAP', sub_models=None)</code>","text":"<p>Gui object. This object contains all the data and variables needed to run the interface. The interface is built using ipyvuetify and plotly. For more information, please see to the references.</p> <p>Attributes:</p> Name Type Description <code>atk</code> <code>atk object</code> <p>The atk object containing the data to explain.</p> <code>selection</code> <code>Potato object</code> <p>The <code>Potato</code> object containing the current selection. For more information, please see the documentation of the class Potato.</p> <p>Parameters:</p> Name Type Description Default <code>atk</code> <code>AntakIA object</code> <p>See the documentation of the class AntakIA.</p> required <code>explanation</code> <code>str</code> <p>The default explanation to display. It can be \"Imported\", \"SHAP\" or \"LIME\".</p> <code>None</code> <code>projection</code> <code>str</code> <p>The default projection to display. It can be \"PaCMAP\", \"PCA\", \"t-SNE\" or \"UMAP\".</p> <code>'PaCMAP'</code> <code>sub_models</code> <code>list</code> <p>The list of sub-models to choose from for each region created by the user. The sub-models must have a predict method.</p> <code>None</code> Source code in <code>antakia/gui.py</code> <pre><code>def __init__(\nself,\natk,\nexplanation: str = None,\nprojection: str = \"PaCMAP\",\nsub_models: list = None,\n):\n\"\"\"Function that creates the interface.\n    Parameters\n    ----------\n    atk : AntakIA object\n        See the documentation of the class AntakIA.\n    explanation : str\n        The default explanation to display. It can be \"Imported\", \"SHAP\" or \"LIME\".\n    projection : str\n        The default projection to display. It can be \"PaCMAP\", \"PCA\", \"t-SNE\" or \"UMAP\".\n    sub_models : list\n        The list of sub-models to choose from for each region created by the user. The sub-models must have a predict method.\n    \"\"\"\nif type(explanation) != str and type(explanation) != type(None):\nraise TypeError(\"explanation must be a string\")\nself.atk = atk\nif sub_models is None :\n# default sub_models\n# TODO : add sub_models for classifications (ex: German Credit)\nsub_models = [\nlinear_model.LinearRegression(),\nRandomForestRegressor(random_state=9),\nensemble.GradientBoostingRegressor(random_state=9),\n]\nself.sub_models = sub_models\n# Publique :\nself.selection = Potato(self.atk, [])\n# Priv\u00e9 :\nif explanation is None :\nif self.atk.explain[\"Imported\"] is not None:\nexplanation = \"Imported\"\nelse :\nexplanation = \"SHAP\"\nself.__projectionVS = projection #string\nself.__projectionES = projection #string\nself.__explanation = explanation #string\nself.dim_red = {}\nself.dim_red[\"VS\"] = {\"PCA\": None, \"t-SNE\": None, \"UMAP\": None, \"PaCMAP\": None}\nself.dim_red[\"ES\"] = {}\nself.dim_red[\"ES\"][\"Imported\"] = {\"PCA\": None, \"t-SNE\": None, \"UMAP\": None, \"PaCMAP\": None}\nself.dim_red[\"ES\"][\"SHAP\"] = {\"PCA\": None, \"t-SNE\": None, \"UMAP\": None, \"PaCMAP\": None}\nself.dim_red[\"ES\"][\"LIME\"] = {\"PCA\": None, \"t-SNE\": None, \"UMAP\": None, \"PaCMAP\": None}    \nif self.__explanation == \"SHAP\" and type(self.atk.explain[\"SHAP\"]) == type(None) :\nself.__calculus = True\nelif self.__explanation == \"LIME\" and type(self.atk.explain[\"LIME\"]) == type(None) :\nself.__calculus = True\nelse:\nself.__calculus = False\nself.__color_regions = [] # the color of the regions created by the automatic dyadic clustering\nself.__save_rules = None #useful to keep the initial rules from the skope-rules, in order to be able to reset the rules\nself.__other_columns = None #to keep track of the columns that are not used in the rules !\nself.__activate_histograms = False #to know if the histograms are activated or not (bug ipywidgets !). If they are activated, we have to update the histograms.\nself.__model_index = None #to know which sub_model is selected by the user. \nself.__labels_automatic_clustering = None #to keep track of the labels from the automatic-clustering, used for the colors !\nself.__result_dyadic_clustering = None #to keep track  of the entire results from the dyadic-clustering\nself.__score_sub_models = None #to keep track of the scores of the sub-models\nself.__table_save = None #to manipulate the table of the saves\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.GUI.display","title":"<code>display()</code>","text":"<p>Function that displays the interface.</p> Source code in <code>antakia/gui.py</code> <pre><code>def display(self):\n\"\"\"Function that displays the interface.\n    \"\"\"\nif self.sub_models != None and len(self.sub_models) &gt; 9:\nraise ValueError(\"You can enter up to 9 sub-models maximum ! (changes to come)\")\n# wait screen definition\ndata_path = files(\"antakia.assets\").joinpath(\"logo_antakia.png\")\nlogo_antakia = widgets.Image(\nvalue=open(data_path, \"rb\").read(), layout=Layout(width=\"230px\")\n)\n# waiting screen progress bars definition\nprogress_shap = gui_elements.ProgressLinear()\n# VS dimension reduction progress bar\nprogress_red = gui_elements.ProgressLinear()\n# consolidation of progress bars and progress texts in a single HBox\nprog_shap = gui_elements.TotalProgress(\"Computing of explanatory values\", progress_shap)\nprog_red = gui_elements.TotalProgress(\"Computing of dimensions reduction\", progress_red)\n# definition of the splash screen which includes all the elements,\nsplash_screen = v.Layout(\nclass_=\"d-flex flex-column align-center justify-center\",\nchildren=[logo_antakia, prog_shap, prog_red],\n)\n# we send the splash screen\ndisplay(splash_screen)\n# if we import the explanatory values, the progress bar of this one is at 100\nif not self.__calculus:\nprogress_shap.v_model = 100\nprog_shap.children[2].children[\n0\n].v_model = \"Imported explanatory values\"\nelse :\nif self.__explanation == \"SHAP\":\ncompute_SHAP = compute.computationSHAP(self.atk.dataset.X, self.atk.dataset.X_all, self.atk.dataset.model)\nwidgets.jslink((progress_shap, \"v_model\"), (compute_SHAP.progress_widget, \"v_model\"))\nwidgets.jslink((prog_shap.children[2].children[0], \"v_model\"), (compute_SHAP.text_widget, \"v_model\"))\nself.atk.explain[\"SHAP\"] = compute_SHAP.compute()\nelif self.__explanation == \"LIME\":\ncompute_LIME = compute.computationLIME(self.atk.dataset.X, self.atk.dataset.X_all, self.atk.dataset.model)\nwidgets.jslink((progress_shap, \"v_model\"), (compute_LIME.progress_widget, \"v_model\"))\nwidgets.jslink((prog_shap.children[2].children[0], \"v_model\"), (compute_LIME.text_widget, \"v_model\"))\nself.atk.explain[\"LIME\"] = compute_LIME.compute()\n# definition of the default projection\n# base, we take the PaCMAP projection\ninitial_choice_of_projection = [\"PCA\", \"t-SNE\", \"UMAP\", \"PaCMAP\"].index(self.__projectionVS) # string\nprog_red.children[2].children[0].v_model = \"Values space... \"\nself.dim_red[\"VS\"][self.__projectionVS] = compute.initialize_dim_red_VS(self.atk.dataset.X_scaled, self.__projectionVS)\nprogress_red.v_model = +50\nprog_red.children[2].children[0].v_model = \"Values space... Explanatory space...\"\nself.dim_red[\"ES\"][self.__explanation][self.__projectionES] = compute.initialize_dim_red_ES(self.atk.explain[self.__explanation], self.__projectionES)\nprogress_red.v_model = +50\n# once all this is done, the splash screen is removed\nsplash_screen.class_ = \"d-none\"\nloading_bar = v.ProgressCircular(\nindeterminate=True, color=\"blue\", width=\"6\", size=\"35\", class_=\"mx-4 my-3\"\n)\n# loading when we compute the projections\nout_loading1 = widgets.HBox([loading_bar])\nout_loading2 = widgets.HBox([loading_bar])\nout_loading1.layout.visibility = \"hidden\"\nout_loading2.layout.visibility = \"hidden\"\n# dropdown allowing to choose the projection in the value space\ndropdown_for_VS = v.Select(\nlabel=\"Projection in the VS:\",\nitems=[\"PCA\", \"t-SNE\", \"UMAP\", \"PaCMAP\"],\nstyle_=\"width: 150px\",\n)\ndropdown_for_VS.v_model = dropdown_for_VS.items[initial_choice_of_projection]\n# dropdown allowing to choose the projection in the space of the explanations\ndropdown_for_ES = v.Select(\nlabel=\"Projection in the ES:\",\nitems=[\"PCA\", \"t-SNE\", \"UMAP\", \"PaCMAP\"],\nstyle_=\"width: 150px\",\n)\ndropdown_for_ES.v_model = dropdown_for_ES.items[initial_choice_of_projection]\n# here the sliders of the parameters for the VS!\nslider_param_PaCMAP_neighbours_VS = gui_elements.SliderParam(v_model=10, min=5, max=30, step=1, label=\"Number of neighbors :\")\nslider_param_PaCMAP_mn_ratio_VS = gui_elements.SliderParam(v_model=0.5, min=0.1, max=0.9, step=0.1, label=\"MN ratio :\")\nslider_param_PaCMAP_fp_ratio_VS = gui_elements.SliderParam(v_model=2, min=0.1, max=5, step=0.1, label=\"FP ratio :\")\ndef function_update_sliderVS(widget, event, data):\n# function that updates the values \u200b\u200bwhen there is a change of sliders in the parameters of PaCMAP for the VS\nif widget.label == \"Number of neighbors :\":\nslider_param_PaCMAP_neighbours_VS.children[1].children = [str(data)]\nelif widget.label == \"MN ratio :\":\nslider_param_PaCMAP_mn_ratio_VS.children[1].children = [str(data)]\nelif widget.label == \"FP ratio :\":\nslider_param_PaCMAP_fp_ratio_VS.children[1].children = [str(data)]\nslider_param_PaCMAP_neighbours_VS.children[0].on_event(\n\"input\", function_update_sliderVS\n)\nslider_param_PaCMAP_mn_ratio_VS.children[0].on_event(\n\"input\", function_update_sliderVS\n)\nslider_param_PaCMAP_fp_ratio_VS.children[0].on_event(\n\"input\", function_update_sliderVS\n)\n# sliders parametres VS\nall_sliders_VS = widgets.VBox(\n[\nslider_param_PaCMAP_neighbours_VS,\nslider_param_PaCMAP_mn_ratio_VS,\nslider_param_PaCMAP_fp_ratio_VS,\n],\nlayout=Layout(width=\"100%\"),\n)\nvalidate_params_proj_VS = v.Btn(\nchildren=[\nv.Icon(left=True, children=[\"mdi-check\"]),\n\"Validate\",\n]\n)\nreset_params_proj_VS = v.Btn(\nclass_=\"ml-4\",\nchildren=[\nv.Icon(left=True, children=[\"mdi-skip-backward\"]),\n\"Reset\",\n],\n)\ntwo_buttons_params = widgets.HBox(\n[validate_params_proj_VS, reset_params_proj_VS]\n)\nparams_proj_VS = widgets.VBox(\n[all_sliders_VS, two_buttons_params], layout=Layout(width=\"100%\")\n)\ndef change_parameters_VS(*b):\n# function that updates the projections when changing the parameters of the projection\nn_neighbors = slider_param_PaCMAP_neighbours_VS.children[0].v_model\nMN_ratio = slider_param_PaCMAP_mn_ratio_VS.children[0].v_model\nFP_ratio = slider_param_PaCMAP_fp_ratio_VS.children[0].v_model\nout_loading1.layout.visibility = \"visible\"\ndim_red = compute.DimensionalityReductionChooser(method=\"PaCMAP\")\nself.dim_red['VS']['PaCMAP'] = [dim_red.compute(self.atk.dataset.X_scaled, 2, False, n_neighbors, MN_ratio, FP_ratio), dim_red.compute(self.atk.dataset.X_scaled, 3, False, n_neighbors, MN_ratio, FP_ratio)]\nout_loading1.layout.visibility = \"hidden\"\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\nvalidate_params_proj_VS.on_event(\"click\", change_parameters_VS)\ndef reset_param_VS(*b):\n# reset projection settings\nout_loading1.layout.visibility = \"visible\"\ndim_red = compute.DimensionalityReductionChooser(method=\"PaCMAP\")\nself.dim_red['VS']['PaCMAP'] = [dim_red.compute(self.atk.dataset.X_scaled, 2), dim_red.compute(self.atk.dataset.X_scaled, 3)]\nout_loading1.layout.visibility = \"hidden\"\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\nreset_params_proj_VS.on_event(\"click\", reset_param_VS)\n# here the sliders of the parameters for the ES!\nslider_param_PaCMAP_voisins_ES = gui_elements.SliderParam(v_model=10, min=5, max=30, step=1, label=\"Number of neighbors :\")\nslider_param_PaCMAP_mn_ratio_ES = gui_elements.SliderParam(v_model=0.5, min=0.1, max=0.9, step=0.1, label=\"MN ratio :\")\nslider_param_PaCMAP_fp_ratio_ES = gui_elements.SliderParam(v_model=2, min=0.1, max=5, step=0.1, label=\"FP ratio :\")\ndef function_update_sliderES(widget, event, data):\nif widget.label == \"Number of neighbors :\":\nslider_param_PaCMAP_voisins_ES.children[1].children = [str(data)]\nelif widget.label == \"MN ratio :\":\nslider_param_PaCMAP_mn_ratio_ES.children[1].children = [str(data)]\nelif widget.label == \"FP ratio :\":\nslider_param_PaCMAP_fp_ratio_ES.children[1].children = [str(data)]\nslider_param_PaCMAP_voisins_ES.children[0].on_event(\n\"input\", function_update_sliderES\n)\nslider_param_PaCMAP_mn_ratio_ES.children[0].on_event(\n\"input\", function_update_sliderES\n)\nslider_param_PaCMAP_fp_ratio_ES.children[0].on_event(\n\"input\", function_update_sliderES\n)\nall_sliders_ES = widgets.VBox(\n[\nslider_param_PaCMAP_voisins_ES,\nslider_param_PaCMAP_mn_ratio_ES,\nslider_param_PaCMAP_fp_ratio_ES,\n],\nlayout=Layout(\nwidth=\"100%\",\n),\n)\nvalidate_params_proj_ES = v.Btn(\nchildren=[\nv.Icon(left=True, children=[\"mdi-check\"]),\n\"Validate\",\n]\n)\nreset_params_proj_ES = v.Btn(\nclass_=\"ml-4\",\nchildren=[\nv.Icon(left=True, children=[\"mdi-skip-backward\"]),\n\"Reset\",\n],\n)\ntwo_buttons_params_ES = widgets.HBox(\n[validate_params_proj_ES, reset_params_proj_ES]\n)\nparams_proj_ES = widgets.VBox(\n[all_sliders_ES, two_buttons_params_ES],\nlayout=Layout(width=\"100%\", display=\"flex\", align_items=\"center\"),\n)\ndef change_params_ES(*b):\nn_neighbors = slider_param_PaCMAP_voisins_ES.children[0].v_model\nMN_ratio = slider_param_PaCMAP_mn_ratio_ES.children[0].v_model\nFP_ratio = slider_param_PaCMAP_fp_ratio_ES.children[0].v_model\nout_loading2.layout.visibility = \"visible\"\ndim_red_compute = compute.DimensionalityReductionChooser(method=\"PaCMAP\")\nself.dim_red[\"ES\"][self.__explanation][self.__projectionES] = [dim_red_compute.compute(self.atk.explain[self.__explanation], 2, False, n_neighbors, MN_ratio, FP_ratio), dim_red_compute.compute(self.atk.explain[self.__explanation], 3, False, n_neighbors, MN_ratio, FP_ratio)]\nout_loading2.layout.visibility = \"hidden\"\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\nvalidate_params_proj_ES.on_event(\"click\", change_params_ES)\ndef reset_param_ES(*b):\nout_loading2.layout.visibility = \"visible\"\ndim_red_compute = compute.DimensionalityReductionChooser(method=\"PaCMAP\")\nself.dim_red[\"ES\"][self.__explanation][self.__projectionES] = [dim_red_compute.compute(self.atk.explain[self.__explanation], 2), dim_red_compute.compute(self.atk.explain[self.__explanation], 3)]\nout_loading2.layout.visibility = \"hidden\"\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\nreset_params_proj_ES.on_event(\"click\", reset_param_ES)\n# allows you to choose the color of the points\n# y, y hat, residuals, current selection, regions, unselected points, automatic clustering\nradio_buttons_for_color_choice = gui_elements.color_choice()\ndef function_change_color(*args, opacity: bool = True):\n# allows you to change the color of the points when you click on the buttons\ncolor = None\nscale = True\nto_modify = True\nif radio_buttons_for_color_choice.v_model == \"y\":\ncolor = self.atk.dataset.y\nelif radio_buttons_for_color_choice.v_model == \"y^\":\ncolor = self.atk.dataset.y_pred\nelif radio_buttons_for_color_choice.v_model == \"Selec actuelle\":\nscale = False\ncolor = [\"grey\"] * len(self.atk.dataset.X)\nfor i in range(len(self.selection.indexes)):\ncolor[self.selection.indexes[i]] = \"blue\"\nelif radio_buttons_for_color_choice.v_model == \"R\u00e9sidus\":\ncolor = self.atk.dataset.y - self.atk.dataset.y_pred\ncolor = [abs(i) for i in color]\nelif radio_buttons_for_color_choice.v_model == \"R\u00e9gions\":\nscale = False\ncolor = [0] * len(self.atk.dataset.X)\nfor i in range(len(self.atk.dataset.X)):\nfor j in range(len(self.atk.regions)):\nif i in self.atk.regions[j].indexes:\ncolor[i] = j + 1\nelif radio_buttons_for_color_choice.v_model == \"Non selec\":\nscale = False\ncolor = [\"red\"] * len(self.atk.dataset.X)\nif len(self.atk.regions) &gt; 0:\nfor i in range(len(self.atk.dataset.X)):\nfor j in range(len(self.atk.regions)):\nif i in self.atk.regions[j].indexes:\ncolor[i] = \"grey\"\nelif radio_buttons_for_color_choice.v_model == \"Clustering auto\":\ncolor = self.__labels_automatic_clustering\nto_modify = False\nscale = False\nwith self.fig1.batch_update():\nself.fig1.data[0].marker.color = color\nif color is not None:\nself.fig1.data[0].customdata= color\nelse:\nself.fig1.data[0].customdata= [None]*len(self.atk.dataset.X)\nif opacity:\nself.fig1.data[0].marker.opacity = 1\nwith self.fig2.batch_update():\nself.fig2.data[0].marker.color = color\nif opacity:\nself.fig2.data[0].marker.opacity = 1\nif color is not None:\nself.fig2.data[0].customdata= color\nelse:\nself.fig2.data[0].customdata= [None]*len(self.atk.dataset.X)\nwith self.fig1_3D.batch_update():\nself.fig1_3D.data[0].marker.color = color\nif color is not None:\nself.fig1_3D.data[0].customdata= color\nelse:\nself.fig1_3D.data[0].customdata= [None]*len(self.atk.dataset.X)\nwith self.fig2_3D.batch_update():\nself.fig2_3D.data[0].marker.color = color\nif color is not None:\nself.fig2_3D.data[0].customdata= color\nelse:\nself.fig2_3D.data[0].customdata= [None]*len(self.atk.dataset.X)\nif scale:\nself.fig1.update_traces(marker=dict(showscale=True))\nself.fig1_3D.update_traces(marker=dict(showscale=True))\nself.fig1.data[0].marker.colorscale = \"Viridis\"\nself.fig1_3D.data[0].marker.colorscale = \"Viridis\"\nself.fig2.data[0].marker.colorscale = \"Viridis\"\nself.fig2_3D.data[0].marker.colorscale = \"Viridis\"\nelse:\nself.fig1.update_traces(marker=dict(showscale=False))\nself.fig1_3D.update_traces(marker=dict(showscale=False))\nif to_modify:\nself.fig1.data[0].marker.colorscale = \"Plasma\"\nself.fig1_3D.data[0].marker.colorscale = \"Plasma\"\nself.fig2.data[0].marker.colorscale = \"Plasma\"\nself.fig2_3D.data[0].marker.colorscale = \"Plasma\"\nelse:\nself.fig1.data[0].marker.colorscale = \"Viridis\"\nself.fig1_3D.data[0].marker.colorscale = \"Viridis\"\nself.fig2.data[0].marker.colorscale = \"Viridis\"\nself.fig2_3D.data[0].marker.colorscale = \"Viridis\"\nradio_buttons_for_color_choice.on_event(\"change\", function_change_color)\n# marker 1 is the marker of figure 1\nmarker1 = dict(\ncolor=self.atk.dataset.y,\ncolorscale=\"Viridis\",\ncolorbar=dict(\ntitle=\"y\",\nthickness=20,\n),\n)\n# marker 2 is the marker of figure 2 (without colorbar therefore)\nmarker2 = dict(color=self.atk.dataset.y, colorscale=\"Viridis\")\nbarre_menu, fig_size, bouton_save = gui_elements.create_menu_bar()\n# for the part on backups\ninit_len_saves = deepcopy(len(self.atk.saves))\ndef init_save(save):\ntext_regions = \"There is no backup\"\nif len(save) &gt; 0:\ntext_regions = str(len(save)) + \" save(s) found\"\ntable_save = []\nfor i in range(len(save)):\nnew_or_not = \"Imported\"\nif i &gt; init_len_saves:\nnew_or_not = \"Created\"\ntable_save.append(\n[\ni + 1,\nsave[i][\"name\"],\nnew_or_not,\nlen(save[i][\"regions\"]),\n]\n)\ntable_save = pd.DataFrame(\ntable_save,\ncolumns=[\n\"Save #\",\n\"Name\",\n\"Origin\",\n\"Number of regions\",\n],\n)\ncolumns = [\n{\"text\": c, \"sortable\": True, \"value\": c} for c in table_save.columns\n]\ntable_save = v.DataTable(\nv_model=[],\nshow_select=True,\nsingle_select=True,\nheaders=columns,\nitems=table_save.to_dict(\"records\"),\nitem_value=\"Save #\",\nitem_key=\"Save #\",\n)\nreturn [table_save, text_regions]\n# the table that contains the backups\nself.__table_save = init_save(self.atk.saves)[0]\n# initialize the save menu !\ndialogue_save, card_save, delete_save, name_save, visualize_chosen_save, new_save = gui_elements.dialog_save(bouton_save, init_save(self.atk.saves)[1], self.__table_save, self.atk)\n# save a backup\ndef delete_save_function(*args):\nif self.__table_save.v_model == []:\nreturn\nself.__table_save = card_save.children[1]\nindex = self.__table_save.v_model[0][\"Save #\"] - 1\nself.atk.saves.pop(index)\nself.__table_save, text = init_save(self.atk.saves)\ncard_save.children = [text, self.__table_save] + card_save.children[\n2:\n]\ndelete_save.on_event(\"click\", delete_save_function)\n# to view a backup\ndef function_visu_save(*args):\nself.__table_save = card_save.children[1]\nif len(self.__table_save.v_model) == 0:\nreturn\nindex = self.__table_save.v_model[0][\"Save #\"] - 1\nself.atk.regions = [element for element in self.atk.saves[index][\"regions\"]]\ncolor = deepcopy(self.atk.saves[index][\"labels\"])\nself.__color_regions = deepcopy(color)\nwith self.fig1.batch_update():\nself.fig1.data[0].marker.color = color\nself.fig1.data[0].marker.opacity = 1\nwith self.fig2.batch_update():\nself.fig2.data[0].marker.color = color\nself.fig2.data[0].marker.opacity = 1\nwith self.fig1_3D.batch_update():\nself.fig1_3D.data[0].marker.color = color\nwith self.fig2_3D.batch_update():\nself.fig2_3D.data[0].marker.color = color\nradio_buttons_for_color_choice.v_model = \"R\u00e9gions\"\nself.fig1.update_traces(marker=dict(showscale=False))\nself.fig2.update_traces(marker=dict(showscale=False))\nfunction_new_region()\nvisualize_chosen_save.on_event(\"click\", function_visu_save)\n# create a new savegame with the current regions\ndef function_new_save(*args):\nif len(name_save.v_model) == 0 or len(name_save.v_model) &gt; 25:\nraise Exception(\"The name of the save must be between 1 and 25 characters !\")\nsave1 = {\"regions\": self.atk.regions, \"labels\": self.__color_regions,\"name\": name_save.v_model}\nsave = {key: value[:] for key, value in save1.items()}\nself.atk.saves.append(save)\nself.__table_save, text_region = init_save(self.atk.saves)\ncard_save.children = [text_region, self.__table_save] + card_save.children[2:]\nnew_save.on_event(\"click\", function_new_save)\n# value space graph\nself.fig1 = go.FigureWidget(\ndata=go.Scatter(x=[1], y=[1], mode=\"markers\", marker=marker1, customdata=marker1[\"color\"], hovertemplate = '%{customdata:.3f}')\n)\n# to remove the plotly logo\nself.fig1._config = self.fig1._config | {\"displaylogo\": False}\n# border size\nM = 40\nself.fig1.update_layout(margin=dict(l=M, r=M, t=0, b=M), width=int(fig_size.v_model))\nself.fig1.update_layout(dragmode=\"lasso\")\n# grapbique de l'espace des explications\nself.fig2 = go.FigureWidget(\ndata=go.Scatter(x=[1], y=[1], mode=\"markers\", marker=marker2, customdata=marker2[\"color\"], hovertemplate = '%{customdata:.3f}')\n)\nself.fig2.update_layout(margin=dict(l=M, r=M, t=0, b=M), width=int(fig_size.v_model))\nself.fig2.update_layout(dragmode=\"lasso\")\nself.fig2._config = self.fig2._config | {\"displaylogo\": False}\n# two checkboxes to choose the projection dimension of figures 1 and 2\ndimension_projection = v.Switch(\nclass_=\"ml-3 mr-2\",\nv_model=False,\nlabel=\"\",\n)\ndimension_projection_text = v.Row(\nclass_=\"ma-3\",\nchildren=[\nv.Icon(children=[\"mdi-numeric-2-box\"]),\nv.Icon(children=[\"mdi-alpha-d-box\"]),\ndimension_projection,\nv.Icon(children=[\"mdi-numeric-3-box\"]),\nv.Icon(children=[\"mdi-alpha-d-box\"]),\n],\n)\ndimension_projection_text = add_tooltip(\ndimension_projection_text, \"Dimension of the projection\"\n)\ndef function_dimension_projection(*args):\nif dimension_projection.v_model:\nfig_2D_ou_3D.children = [fig1_3D_and_text, fig2_3D_and_text]\nelse:\nfig_2D_ou_3D.children = [fig1_and_text, fig2_and_text]\ndimension_projection.on_event(\"change\", function_dimension_projection)\n# marker 3D is the marker of figure 1 in 3D\nmarker_3D = dict(\ncolor=self.atk.dataset.y,\ncolorscale=\"Viridis\",\ncolorbar=dict(\nthickness=20,\n),\nsize=3,\n)\n# marker 3D_2 is the marker of figure 2 in 3D (without the colorbar therefore!)\nmarker_3D_2 = dict(color=self.atk.dataset.y, colorscale=\"Viridis\", size=3)\nself.fig1_3D = go.FigureWidget(\ndata=go.Scatter3d(\nx=[1], y=[1], z=[1], mode=\"markers\", marker=marker_3D,  customdata=marker_3D[\"color\"], hovertemplate = '%{customdata:.3f}'\n)\n)\nself.fig1_3D.update_layout(\nmargin=dict(l=M, r=M, t=0, b=M),\nwidth=int(fig_size.v_model),\nscene=dict(aspectmode=\"cube\"),\ntemplate=\"none\",\n)\nself.fig1_3D._config = self.fig1_3D._config | {\"displaylogo\": False}\nself.fig2_3D = go.FigureWidget(\ndata=go.Scatter3d(\nx=[1], y=[1], z=[1], mode=\"markers\", marker=marker_3D_2, customdata=marker_3D_2[\"color\"], hovertemplate = '%{customdata:.3f}'\n)\n)\nself.fig2_3D.update_layout(\nmargin=dict(l=M, r=M, t=0, b=M),\nwidth=int(fig_size.v_model),\nscene=dict(aspectmode=\"cube\"),\ntemplate=\"none\",\n)\nself.fig2_3D._config = self.fig2_3D._config | {\"displaylogo\": False}\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\n# text that indicate spaces for better understanding\ntextVS = widgets.HTML(\"&lt;h3&gt;Values Space&lt;h3&gt;\")\ntextES = widgets.HTML(\"&lt;h3&gt;Explanatory Space&lt;h3&gt;\")\n# we display the figures and the text above!\nfig1_and_text = gui_elements.figure_and_text(self.fig1, textVS)\nfig2_and_text = gui_elements.figure_and_text(self.fig2, textES)\nfig1_3D_and_text = gui_elements.figure_and_text(self.fig1_3D, textVS)\nfig2_3D_and_text = gui_elements.figure_and_text(self.fig2_3D, textES)\n# HBox which allows you to choose between 2D and 3D figures by changing its children parameter!\nfig_2D_ou_3D = widgets.HBox([fig1_and_text, fig2_and_text])\n# allows to update graphs 1 &amp; 2 according to the chosen projection\ndef update_scatter(*args):\nself.__projectionVS = deepcopy(dropdown_for_VS.v_model)\nself.__projectionES = deepcopy(dropdown_for_ES.v_model)\nif self.dim_red[\"VS\"][dropdown_for_VS.v_model] is None:\nout_loading1.layout.visibility = \"visible\"\ndim_red_compute = compute.DimensionalityReductionChooser(method=dropdown_for_VS.v_model)\nself.dim_red[\"VS\"][dropdown_for_VS.v_model] = [dim_red_compute.compute(self.atk.dataset.X_scaled, 2), dim_red_compute.compute(self.atk.dataset.X_scaled, 3)]\nout_loading1.layout.visibility = \"hidden\"\nif self.dim_red[\"ES\"][self.__explanation][dropdown_for_ES.v_model] is None:\nout_loading2.layout.visibility = \"visible\"\ndim_red_compute = compute.DimensionalityReductionChooser(method=dropdown_for_ES.v_model)\nself.dim_red[\"ES\"][self.__explanation][dropdown_for_ES.v_model] = [dim_red_compute.compute(self.atk.explain[self.__explanation], 2), dim_red_compute.compute(self.atk.explain[self.__explanation], 3)]\nout_loading2.layout.visibility = \"hidden\"\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\n# for the parameters of the projection\nif dropdown_for_VS.v_model == \"PaCMAP\":\nparam_VS.v_slots[0][\"children\"].disabled = False\nelse:\nparam_VS.v_slots[0][\"children\"].disabled = True\nif dropdown_for_ES.v_model == \"PaCMAP\":\nparam_ES.v_slots[0][\"children\"].disabled = False\nelse:\nparam_ES.v_slots[0][\"children\"].disabled = True\ndropdown_for_VS.v_model = self.__projectionVS\ndropdown_for_ES.v_model = self.__projectionES\n# we observe the changes in the values \u200b\u200bof the dropdowns to change the method of reduction\ndropdown_for_VS.on_event(\"change\", update_scatter)\ndropdown_for_ES.on_event(\"change\", update_scatter)\nself.__color_regions = [0] * len(self.atk.dataset.X)\n# definition of the table that will show the different results of the regions, with a stat of info about them\ntable_regions = widgets.Output()\n# definition of the text that will give information on the selection\ntext_base, text_base_debut, text_selec, card_selec, button_validate_skope, button_reset_skope = gui_elements.create_selection_card()\ntext_skope, text_skopeES, text_skopeVS, one_card_VS, one_card_ES = gui_elements.create_card_skope()\n# texts that will contain the information on the self.sub_models\nmods = gui_elements.create_slide_sub_models(self)\ndef change(widget, event, data, args: bool = True):\nif args == True:\nfor i in range(len(mods.children)):\nmods.children[i].children[0].color = \"white\"\nwidget.color = \"blue lighten-4\"\nfor i in range(len(mods.children)):\nif mods.children[i].children[0].color == \"blue lighten-4\":\nself.__model_index = i\nfor i in range(len(mods.children)):\nmods.children[i].children[0].on_event(\"click\", change)\nvalidate_one_region, supprimer_toutes_les_tuiles, selection = gui_elements.create_buttons_regions()\n# we define the sliders used to modify the histogram resulting from the skope\nslider_skope1, button_in_real_time_graph1, slider_text_comb1 = gui_elements.slider_skope()\nslider_skope2, button_in_real_time_graph2, slider_text_comb2 = gui_elements.slider_skope()\nslider_skope3, button_in_real_time_graph3, slider_text_comb3 = gui_elements.slider_skope()\n# if \"in real-time\" is checked, no need to validate the changes!\ndef update_validate1(*args):\nif button_in_real_time_graph1.v_model:\nvalidate_change_1.disabled = True\nelse:\nvalidate_change_1.disabled = False\nbutton_in_real_time_graph1.on_event(\"change\", update_validate1)\ndef update_validate2(*args):\nif button_in_real_time_graph2.value:\nvalidate_change_2.disabled = True\nelse:\nvalidate_change_2.disabled = False\nbutton_in_real_time_graph2.on_event(\"change\", update_validate2)\ndef update_validate3(*args):\nif button_in_real_time_graph3.v_model:\nvalidate_change_3.disabled = True\nelse:\nvalidate_change_3.disabled = False\nbutton_in_real_time_graph3.on_event(\"change\", update_validate3)\n# valid buttons definition changes:\ndef validate_change():\nwidget = v.Btn(\nclass_=\"ma-3\",\nchildren=[\nv.Icon(class_=\"mr-2\", children=[\"mdi-check\"]),\n\"Validate the changes\",\n],\n)\nreturn widget\nvalidate_change_1 = validate_change()\nvalidate_change_2 = validate_change()\nvalidate_change_3 = validate_change()\n# we wrap the validation button and the checkbox which allows you to view in real time\ntwo_end1 = widgets.HBox([validate_change_1, button_in_real_time_graph1])\ntwo_end2 = widgets.HBox([validate_change_2, button_in_real_time_graph2])\ntwo_end3 = widgets.HBox([validate_change_3, button_in_real_time_graph3])\n# we define the number of bars of the histogram\nnumber_of_bins_histograms = 50\n# we define the histograms\n[histogram1, histogram2, histogram3] = gui_elements.create_histograms(number_of_bins_histograms, fig_size.v_model)\nhistogram1 = deepcopy(histogram1)\nhistogram2 = deepcopy(histogram2)\nhistogram3 = deepcopy(histogram3)\nall_histograms = [histogram1, histogram2, histogram3]\n# definitions of the different color choices for the swarm\n[total_beeswarm_1, total_beeswarm_2, total_beeswarm_3] = gui_elements.create_beeswarms(self, self.__explanation, fig_size.v_model)\nchoice_color_beeswarm1 = total_beeswarm_1.children[0]\nchoice_color_beeswarm2 = total_beeswarm_2.children[0]\nchoice_color_beeswarm3 = total_beeswarm_3.children[0]\nbeeswarm1 = total_beeswarm_1.children[1]\nbeeswarm2 = total_beeswarm_2.children[1]\nbeeswarm3 = total_beeswarm_3.children[1]\n# update the beeswarm plots\ndef change_color_beeswarm_shap1(*args):\nif choice_color_beeswarm1.children[1].v_model == False:\nmarker = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[0][2])[1]\nbeeswarm1.data[0].marker = marker\nbeeswarm1.update_traces(marker=dict(showscale=True))\nelse:\nmodifie_all_histograms(\nslider_skope1.v_model[0]  , slider_skope1.v_model[1]  , 0\n)\nbeeswarm1.update_traces(marker=dict(showscale=False))\nchoice_color_beeswarm1.children[1].on_event(\n\"change\", change_color_beeswarm_shap1\n)\ndef change_color_beeswarm_shap2(*args):\nif choice_color_beeswarm2.children[1].v_model == False:\nmarker = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[1][2])[1]\nbeeswarm2.data[0].marker = marker\nbeeswarm2.update_traces(marker=dict(showscale=True))\nelse:\nmodifie_all_histograms(\nslider_skope2.v_model[0]  , slider_skope2.v_model[1]  , 1\n)\nbeeswarm2.update_traces(marker=dict(showscale=False))\nchoice_color_beeswarm2.children[1].on_event(\n\"change\", change_color_beeswarm_shap2\n)\ndef change_color_beeswarm_shap3(*args):\nif choice_color_beeswarm3.children[1].v_model == False:\nmarker = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[2][2])[1]\nbeeswarm3.data[0].marker = marker\nbeeswarm3.update_traces(marker=dict(showscale=True))\nelse:\nmodifie_all_histograms(\nslider_skope3.v_model[0]  , slider_skope3.v_model[1]  , 2\n)\nbeeswarm3.update_traces(marker=dict(showscale=False))\nchoice_color_beeswarm3.children[1].on_event(\n\"change\", change_color_beeswarm_shap3\n)\nall_beeswarms_total = [total_beeswarm_1, total_beeswarm_2, total_beeswarm_3]\nall_beeswarms = [beeswarm1, beeswarm2, beeswarm3]\nall_color_choosers_beeswarms = [\nchoice_color_beeswarm1,\nchoice_color_beeswarm2,\nchoice_color_beeswarm3,\n]\n# set of elements that contain histograms and sliders\nall_widgets_slider_histo1 = widgets.VBox([slider_text_comb1, histogram1, two_end1])\nall_widgets_slider_histo2 = widgets.VBox([slider_text_comb2, histogram2, two_end2])\nall_widgets_slider_histo3 = widgets.VBox([slider_text_comb3, histogram3, two_end3])\n# definition of buttons to delete features (disabled for the first 3 for the moment)\nb_delete_skope1 = gui_elements.button_delete_skope()\nb_delete_skope2 = gui_elements.button_delete_skope()\nb_delete_skope3 = gui_elements.button_delete_skope()\n# checkbow to know if the feature is continuous or not\nis_continuous_1 = v.Checkbox(v_model=True, label=\"is continuous?\")\nis_continuous_2 = v.Checkbox(v_model=True, label=\"is continuous?\")\nis_continuous_3 = v.Checkbox(v_model=True, label=\"is continuous?\")\n# the right side of the features : button to delete the feature from the rules + checkbox \"is continuous?\"\nright_side_1 = v.Col(children=[b_delete_skope1, is_continuous_1], class_=\"d-flex flex-column align-center justify-center\")\nright_side_2 = v.Col(children=[b_delete_skope2, is_continuous_2], class_=\"d-flex flex-column align-center justify-center\")\nright_side_3 = v.Col(children=[b_delete_skope3, is_continuous_3], class_=\"d-flex flex-column align-center justify-center\")\nself.__all_widgets_class_1 = gui_elements.create_class_selector(self, self.atk.dataset.X.columns[0])\nself.__all_widgets_class_2 = gui_elements.create_class_selector(self, self.atk.dataset.X.columns[0])\nself.__all_widgets_class_3 = gui_elements.create_class_selector(self, self.atk.dataset.X.columns[0])\n# when teh user checks the fact that this feature \ndef change_continuous1(widget, event, data):\nif widget.v_model == True and widget == right_side_1.children[1]:\nin_accordion1.children = [all_widgets_slider_histo1] + list(in_accordion1.children[1:])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == self.selection.rules[0][2] and i-count != 0:\nself.selection.rules.pop(i-count)\ncount += 1\nself.selection.rules[0][0] = slider_skope1.v_model[0]\nself.selection.rules[0][4] = slider_skope1.v_model[1]\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nelse:\nin_accordion1.children = [self.__all_widgets_class_1] + list(in_accordion1.children[1:])\nl = []\nfor i in range(len(self.__all_widgets_class_1.children[2].children)):\nif self.__all_widgets_class_1.children[2].children[i].v_model:\nl.append(int(self.__all_widgets_class_1.children[2].children[i].label))\nif len(l) == 0:\nwidget.v_model = True\nreturn\ncolumn = deepcopy(self.selection.rules[0][2])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == column:\nself.selection.rules.pop(i-count)\ncount += 1\ncroissant = 0\nfor ele in l:\nself.selection.rules.insert(0+croissant, [ele-0.5, '&lt;=', column, '&lt;=', ele+0.5])\ncroissant += 1\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules), is_class=True)\nupdate_all_graphs()\ndef change_continuous2(widget, event, data):\nfeatures = [self.selection.rules[i][2] for i in range(len(self.selection.rules))]\nthe_set = []\nfor i in range(len(features)):\nif features[i] not in the_set:\nthe_set.append(features[i])\nindex = features.index(the_set[1])\nif widget.v_model and widget == right_side_2.children[1]:\nin_accordion2.children = [all_widgets_slider_histo2] + list(in_accordion2.children[1:])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == self.selection.rules[index][2] and i-count != index:\nself.selection.rules.pop(i-count)\ncount += 1\nself.selection.rules[index][0] = slider_skope2.v_model[0]\nself.selection.rules[index][4] = slider_skope2.v_model[1]\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nelse:\nin_accordion2.children = [self.__all_widgets_class_2] + list(in_accordion2.children[1:])\nl = []\nfor i in range(len(self.__all_widgets_class_2.children[2].children)):\nif self.__all_widgets_class_2.children[2].children[i].v_model:\nl.append(int(self.__all_widgets_class_2.children[2].children[i].label))\nif len(l) == 0:\nwidget.v_model = True\nreturn\ncolumn = deepcopy(self.selection.rules[index][2])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == column:\nself.selection.rules.pop(i-count)\ncount += 1\ncroissant = 0\nfor ele in l:\nself.selection.rules.insert(index+croissant, [ele-0.5, '&lt;=', column, '&lt;=', ele+0.5])\ncroissant += 1\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules), is_class=True)\nupdate_all_graphs()\ndef change_continuous3(widget, event, data):\nfeatures = [self.selection.rules[i][2] for i in range(len(self.selection.rules))]\nthe_set = []\nfor i in range(len(features)):\nif features[i] not in the_set:\nthe_set.append(features[i])\nindex = features.index(the_set[2])\nif widget.v_model and widget == right_side_3.children[1]:\nin_accordion3.children = [all_widgets_slider_histo3] + list(in_accordion3.children[1:])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == self.selection.rules[index][2] and i-count != index:\nself.selection.rules.pop(i-count)\ncount += 1\nself.selection.rules[index][0] = slider_skope3.v_model[0]\nself.selection.rules[index][4] = slider_skope3.v_model[1]\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nelse:\nin_accordion3.children = [self.__all_widgets_class_3] + list(in_accordion3.children[1:])\nl = []\nfor i in range(len(self.__all_widgets_class_3.children[2].children)):\nif self.__all_widgets_class_3.children[2].children[i].v_model:\nl.append(int(self.__all_widgets_class_3.children[2].children[i].label))\nif len(l) == 0:\nwidget.v_model = True\nreturn\ncolumn = deepcopy(self.selection.rules[index][2])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == column:\nself.selection.rules.pop(i-count)\ncount += 1\ncroissant = 0\nfor ele in l:\nself.selection.rules.insert(index+croissant, [ele-0.5, '&lt;=', column, '&lt;=', ele+0.5])\ncroissant += 1\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules), is_class=True)\nupdate_all_graphs()\n# the \"is continuous\" checkbox\nright_side_1.children[1].on_event(\"change\", change_continuous1)\nright_side_2.children[1].on_event(\"change\", change_continuous2)\nright_side_3.children[1].on_event(\"change\", change_continuous3)\nin_accordion1 = widgets.HBox(\n[all_widgets_slider_histo1, total_beeswarm_1, right_side_1],\nlayout=Layout(align_items=\"center\"),\n)\nin_accordion2 = widgets.HBox(\n[all_widgets_slider_histo2, total_beeswarm_2, right_side_2],\nlayout=Layout(align_items=\"center\"),\n)\nin_accordion3 = widgets.HBox(\n[all_widgets_slider_histo3, total_beeswarm_3, right_side_3],\nlayout=Layout(align_items=\"center\"),\n)\n# we define several accordions in this way to be able to open several at the same time\nin_accordion1_n = gui_elements.accordion_skope(\"X1\", in_accordion1)\nin_accordion2_n = gui_elements.accordion_skope(\"X2\", in_accordion2)\nin_accordion3_n = gui_elements.accordion_skope(\"X3\", in_accordion3)\naccordion_skope = widgets.VBox(\nchildren=[in_accordion1_n, in_accordion2_n, in_accordion3_n],\nlayout=Layout(width=\"100%\", height=\"auto\"),\n)\n# allows you to take the set of rules and modify the graph so that it responds to everything!\ndef update_all_graphs():\nself.selection.state = Potato.REFINED_SKR\n\"\"\"\n        new_tuile = self.atk.dataset.X[\n            (self.atk.dataset.X[self.selection.rules[0][2]] &gt;= self.selection.rules[0][0])\n            &amp; (self.atk.dataset.X[self.selection.rules[0][2]] &lt;= self.selection.rules[0][4])\n        ].index\n        for i in range(1, len(self.selection.rules)):\n            X_temp = self.atk.dataset.X[\n                (self.atk.dataset.X[self.selection.rules[i][2]] &gt;= self.selection.rules[i][0])\n                &amp; (self.atk.dataset.X[self.selection.rules[i][2]] &lt;= self.selection.rules[i][4])\n            ].index\n            new_tuile = [g for g in new_tuile if g in X_temp]\n        \"\"\"\nnew_tuile = self.selection.applyRules(to_return=True)\ny_shape_skope = []\ny_color_skope = []\ny_opa_skope = []\nfor i in range(len(self.atk.dataset.X)):\nif i in new_tuile:\ny_shape_skope.append(\"circle\")\ny_color_skope.append(\"blue\")\ny_opa_skope.append(0.5)\nelse:\ny_shape_skope.append(\"cross\")\ny_color_skope.append(\"grey\")\ny_opa_skope.append(0.5)\nwith self.fig1.batch_update():\nself.fig1.data[0].marker.color = y_color_skope\nwith self.fig2.batch_update():\nself.fig2.data[0].marker.color = y_color_skope\nwith self.fig1_3D.batch_update():\nself.fig1_3D.data[0].marker.color = y_color_skope\nwith self.fig2_3D.batch_update():\nself.fig2_3D.data[0].marker.color = y_color_skope\n# allows to modify all the histograms according to the rules\ndef modifie_all_histograms(value_min, value_max, index):\nnew_list_tout = self.atk.dataset.X.index[\nself.atk.dataset.X[self.selection.rules[index][2]].between(value_min, value_max)\n].tolist()\nfor i in range(len(self.selection.rules)):\nmin = self.selection.rules[i][0]\nmax = self.selection.rules[i][4]\nif i != index:\nnew_list_temp = self.atk.dataset.X.index[\nself.atk.dataset.X[self.selection.rules[i][2]].between(min, max)\n].tolist()\nnew_list_tout = [g for g in new_list_tout if g in new_list_temp]\nif self.selection.indexes_from_map is not None:\nnew_list_tout = [g for g in new_list_tout if g in self.selection.indexes_from_map]\nfor i in range(len(self.selection.rules)):\nwith all_histograms[i].batch_update():\nall_histograms[i].data[2].x = self.atk.dataset.X[self.selection.rules[i][2]][new_list_tout]\nif all_color_choosers_beeswarms[i].children[1].v_model:\nwith all_beeswarms[i].batch_update():\ny_color = [0] * len(self.atk.explain[self.__explanation])\nif i == index:\nindexs = self.atk.dataset.X.index[\nself.atk.dataset.X[self.selection.rules[i][2]].between(value_min, value_max)\n].tolist()\nelse:\nindexs = self.atk.dataset.X.index[\nself.atk.dataset.X[self.selection.rules[i][2]].between(\nself.selection.rules[i][0], self.selection.rules[i][4]\n)\n].tolist()\nfor j in range(len(self.atk.explain[self.__explanation])):\nif j in new_list_tout:\ny_color[j] = \"blue\"\nelif j in indexs:\ny_color[j] = \"#85afcb\"\nelse:\ny_color[j] = \"grey\"\nall_beeswarms[i].data[0].marker.color = y_color\n# when the value of a slider is modified, the histograms and graphs are modified\ndef on_value_change_skope1(widget, event, data):\nif widget.__class__.__name__ == \"RangeSlider\":\nslider_text_comb1.children[0].v_model = slider_skope1.v_model[0]\nslider_text_comb1.children[2].v_model = slider_skope1.v_model[1]\nelse :\nif slider_text_comb1.children[0].v_model == '' or slider_text_comb1.children[2].v_model == '':\nreturn\nelse:\nslider_skope1.v_model = [float(slider_text_comb1.children[0].v_model), float(slider_text_comb1.children[2].v_model)]\nnew_list = [\ng\nfor g in list(self.atk.dataset.X[self.selection.rules[0][2]].values)\nif g &gt;= slider_skope1.v_model[0]\nand g &lt;= slider_skope1.v_model[1]\n]\nwith histogram1.batch_update():\nhistogram1.data[1].x = new_list\nif self.__activate_histograms:\nmodifie_all_histograms(\nslider_skope1.v_model[0], slider_skope1.v_model[1], 0\n)\nif button_in_real_time_graph1.v_model:\n#self.selection.rules[0][0] = float(deepcopy(slider_skope1.v_model[0]))\n#self.selection.rules[0][4] = float(deepcopy(slider_skope1.v_model[1]))\nself.selection.rules[0][0] = float(deepcopy(slider_skope1.v_model[0]))\nself.selection.rules[0][4] = float(deepcopy(slider_skope1.v_model[1]))\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\ndef on_value_change_skope2(widget, event, data):\nif widget.__class__.__name__ == \"RangeSlider\":\nslider_text_comb2.children[0].v_model = slider_skope2.v_model[0]  \nslider_text_comb2.children[2].v_model = slider_skope2.v_model[1]  \nnew_list = [\ng\nfor g in list(self.atk.dataset.X[self.selection.rules[1][2]].values)\nif g &gt;= slider_skope2.v_model[0]  \nand g &lt;= slider_skope2.v_model[1]  \n]\nwith histogram2.batch_update():\nhistogram2.data[1].x = new_list\nif self.__activate_histograms:\nmodifie_all_histograms(\nslider_skope2.v_model[0]  , slider_skope2.v_model[1]  , 1\n)\nif button_in_real_time_graph2.v_model:\nself.selection.rules[1][0] = float(deepcopy(slider_skope2.v_model[0]  ))\nself.selection.rules[1][4] = float(deepcopy(slider_skope2.v_model[1]  ))\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\ndef on_value_change_skope3(widget, event, data):\nif widget.__class__.__name__ == \"RangeSlider\":\nslider_text_comb3.children[0].v_model = slider_skope3.v_model[0]  \nslider_text_comb3.children[2].v_model = slider_skope3.v_model[1]  \nnew_list = [\ng\nfor g in list(self.atk.dataset.X[self.selection.rules[2][2]].values)\nif g &gt;= slider_skope3.v_model[0]  \nand g &lt;= slider_skope3.v_model[1]  \n]\nwith histogram3.batch_update():\nhistogram3.data[1].x = new_list\nif self.__activate_histograms:\nmodifie_all_histograms(\nslider_skope3.v_model[0]  , slider_skope3.v_model[1]  , 2\n)\nif button_in_real_time_graph3.v_model:\nself.selection.rules[2][0] = float(deepcopy(slider_skope3.v_model[0]  ))\nself.selection.rules[2][4] = float(deepcopy(slider_skope3.v_model[1]  ))\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\ndef liste_to_string_skope(liste, is_class=False):\nchaine = \"\"\nfor rule in liste:\nfor i in range(len(rule)):\nif type(rule[i]) == float:\nchaine += str(np.round(float(rule[i]), 2))\nelif rule[i] is None:\nchaine += \"None\"\nelif type(rule[i]) == list:\nchaine+=\"{\"\nchaine += str(rule[i][0])\nfor j in range(1, len(rule[i])):\nchaine += \",\" + str(rule[i][j])\nchaine+=\"}\"\nelse:\nchaine += str(rule[i])\nchaine += \" \"\nreturn chaine\n# cwhen the user validates the updates he makes on a rule\ndef function_change_validate_1(*change):\na = deepcopy(float(slider_skope1.v_model[0]))\nb = deepcopy(float(slider_skope1.v_model[1]))\nself.selection.rules[0][0] = a\nself.selection.rules[0][4] = b\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nfunction_scores_models(None)\ndef function_change_validate_2(*change):\nself.selection.rules[1][0] = float(slider_skope2.v_model[0])\nself.selection.rules[1][4] = float(slider_skope2.v_model[1])\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nfunction_scores_models(None)\ndef function_change_validate_3(*change):\nself.selection.rules[2][0] = float(slider_skope3.v_model[0])\nself.selection.rules[2][4] = float(slider_skope3.v_model[1])\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nfunction_scores_models(None)\nvalidate_change_1.on_event(\"click\", function_change_validate_1)\nvalidate_change_2.on_event(\"click\", function_change_validate_2)\nvalidate_change_3.on_event(\"click\", function_change_validate_3)\ndef rules_to_indexs():\nliste_bool = [True] * len(self.atk.dataset.X)\nfor i in range(len(self.atk.dataset.X)):\nfor j in range(len(self.selection.rules)):\ncolumn = list(self.atk.dataset.X.columns).index(self.selection.rules[j][2])\nif (\nself.selection.rules[j][0] &gt; self.atk.dataset.X.iloc[i, column]\nor self.atk.dataset.X.iloc[i, column] &gt; self.selection.rules[j][4]\n):\nliste_bool[i] = False\ntemp = [i for i in range(len(self.atk.dataset.X)) if liste_bool[i]]\nreturn temp\ndef function_scores_models(temp):\nif type(temp) == type(None):\ntemp = rules_to_indexs()\nresult_models = function_models(self.atk.dataset.X.iloc[temp, :], self.atk.dataset.y.iloc[temp], self.sub_models)\nscore_tot = []\nfor i in range(len(self.sub_models)):\nscore_tot.append(compute.function_score(self.atk.dataset.y.iloc[temp], result_models[i][-2]))\nscore_init = compute.function_score(self.atk.dataset.y.iloc[temp], self.atk.dataset.y_pred[temp])\nif score_init == 0:\nl_compar = [\"/\"] * len(self.sub_models)\nelse:\nl_compar = [\nround(100 * (score_init - score_tot[i]) / score_init, 1)\nfor i in range(len(self.sub_models))\n]\nself.__score_sub_models = []\nfor i in range(len(self.sub_models)):\nself.__score_sub_models.append(\n[\nscore_tot[i],\nscore_init,\nl_compar[i],\n]\n)\n# to generate a string for the scores\n# TODO: different score for the classification! Recall/precision!\ndef string_for_score(i):\nif score_tot[i] == 0:\nreturn (\n\"MSE = \"\n+ str(score_tot[i])\n+ \" (against \"\n+ str(score_init)\n+ \", +\"\n+ \"\u221e\"\n+ \"%)\"\n)\nelse:\nif round(100 * (score_init - score_tot[i]) / score_init, 1) &gt; 0:\nreturn (\n\"MSE = \"\n+ str(score_tot[i])\n+ \" (against \"\n+ str(score_init)\n+ \", +\"\n+ str(\nround(100 * (score_init - score_tot[i]) / score_init, 1)\n)\n+ \"%)\"\n)\nelse:\nreturn (\n\"MSE = \"\n+ str(score_tot[i])\n+ \" (against \"\n+ str(score_init)\n+ \", \"\n+ str(\nround(100 * (score_init - score_tot[i]) / score_init, 1)\n)\n+ \"%)\"\n)\nfor i in range(len(self.sub_models)):\nmods.children[i].children[0].children[1].children = string_for_score(i)\n# when you click on the skope-rules button\ndef function_validation_skope(*sender):\nloading_models.class_ = \"d-flex\"\nself.__activate_histograms = True\nif self.selection.y_train == None:\ntext_skopeVS.children[1].children = [\nwidgets.HTML(\"Please select points\")\n]\ntext_skopeES.children[1].children = [\nwidgets.HTML(\"Please select points\")\n]\nelif 0 not in self.selection.y_train or 1 not in self.selection.y_train:\ntext_skopeVS.children[1].children = [\nwidgets.HTML(\"You can't choose everything/nothing !\")\n]\ntext_skopeES.children[1].children = [\nwidgets.HTML(\"You can't choose everything/nothing !\")\n]\nelse:\n# skope calculation for X\nself.selection.applySkope(self.__explanation, 0.2, 0.2)\nprint(self.selection.rules)\n# if no rule for one of the two, nothing is displayed\nif self.selection.success == False:\ntext_skopeVS.children[1].children = [\nwidgets.HTML(\"No rule found\")\n]\ntext_skopeES.children[1].children = [\nwidgets.HTML(\"No rule found\")\n]\n# otherwise we display\nelse:\n#chaine_carac = transform_string(skope_rules_clf.rules_[0])\ntext_skopeVS.children[0].children[3].children = [\n\"p = \"\n+ str(self.selection.score[0])\n+ \"%\"\n+ \" r = \"\n+ str(self.selection.score[1])\n+ \"%\"\n+ \" ext. of the tree = \"\n+ str(self.selection.score[2])\n]\n# there we find the values \u200b\u200bof the skope to use them for the sliders\ncolumns_rules = [self.selection.rules[i][2] for i in range(len(self.selection.rules))]\nnew_columns_rules = []\nfor i in range(len(columns_rules)):\nif columns_rules[i] not in new_columns_rules:\nnew_columns_rules.append(columns_rules[i])\ncolumns_rules = new_columns_rules\nself.__other_columns = [g for g in self.atk.dataset.X.columns if g not in columns_rules]\nwidget_list_add_skope.items = self.__other_columns\nwidget_list_add_skope.v_model = self.__other_columns[0]\nself.selection.rules = self.selection.rules\none_card_VS.children = gui_elements.generate_rule_card(\nliste_to_string_skope(self.selection.rules)\n)\n[new_y, marker] = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[0][2])\nbeeswarm1.data[0].y = deepcopy(new_y)\nbeeswarm1.data[0].x = self.atk.explain[self.__explanation][columns_rules[0] + \"_shap\"]\nbeeswarm1.data[0].marker = marker\nall_histograms = [histogram1]\nif len(set([self.selection.rules[i][2] for i in range(len(self.selection.rules))])) &gt; 1:\nall_histograms = [histogram1, histogram2]\n[new_y, marker] = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[1][2])\nbeeswarm2.data[0].y = deepcopy(new_y)\nbeeswarm2.data[0].x = self.atk.explain[self.__explanation][columns_rules[1] + \"_shap\"]\nbeeswarm2.data[0].marker = marker\nif len(set([self.selection.rules[i][2] for i in range(len(self.selection.rules))])) &gt; 2:\nall_histograms = [histogram1, histogram2, histogram3]\n[new_y, marker] = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[2][2])\nbeeswarm3.data[0].y = deepcopy(new_y)\nbeeswarm3.data[0].x = self.atk.explain[self.__explanation][columns_rules[2] + \"_shap\"]\nbeeswarm3.data[0].marker = marker\ny_shape_skope = []\ny_color_skope = []\ny_opa_skope = []\nfor i in range(len(self.atk.dataset.X)):\nif i in self.selection.indexes:\ny_shape_skope.append(\"circle\")\ny_color_skope.append(\"blue\")\ny_opa_skope.append(0.5)\nelse:\ny_shape_skope.append(\"cross\")\ny_color_skope.append(\"grey\")\ny_opa_skope.append(0.5)\nradio_buttons_for_color_choice.v_model = \"Selec actuelle\"\nfunction_change_color(None)\naccordion_skope.children = [\nin_accordion1_n,\n]\nin_accordion1_n.children[0].children[0].children = (\n\"X1 (\" + columns_rules[0].replace(\"_\", \" \") + \")\"\n)\nif len(columns_rules) &gt; 1:\naccordion_skope.children = [\nin_accordion1_n,\nin_accordion2_n,\n]\nin_accordion2_n.children[0].children[0].children = (\n\"X2 (\" + columns_rules[1].replace(\"_\", \" \") + \")\"\n)\nif len(columns_rules) &gt; 2:\naccordion_skope.children = [\nin_accordion1_n,\nin_accordion2_n,\nin_accordion3_n,\n]\nin_accordion3_n.children[0].children[0].children = (\n\"X3 (\" + columns_rules[2].replace(\"_\", \" \") + \")\"\n)\nself.__all_widgets_class_1 = gui_elements.create_class_selector(self, columns_rules[0], self.selection.rules[0][0], self.selection.rules[0][4], fig_size=fig_size.v_model)\nif len(columns_rules) &gt; 1:\nself.__all_widgets_class_2 = gui_elements.create_class_selector(self, columns_rules[1], self.selection.rules[1][0], self.selection.rules[1][4], fig_size=fig_size.v_model)\nif len(columns_rules) &gt; 2:\nself.__all_widgets_class_3 = gui_elements.create_class_selector(self, columns_rules[2], self.selection.rules[2][0], self.selection.rules[2][4], fig_size=fig_size.v_model)\nfor ii in range(len(self.__all_widgets_class_1.children[2].children)):\nself.__all_widgets_class_1.children[2].children[ii].on_event(\"change\", change_continuous1)\nfor ii in range(len(self.__all_widgets_class_2.children[2].children)):\nself.__all_widgets_class_2.children[2].children[ii].on_event(\"change\", change_continuous2)\nfor ii in range(len(self.__all_widgets_class_3.children[2].children)):\nself.__all_widgets_class_3.children[2].children[ii].on_event(\"change\", change_continuous3)\nif self.atk.dataset.lat in columns_rules and self.atk.dataset.long in columns_rules:\nbutton_add_map.disabled = False\nelse:\nbutton_add_map.disabled = True\nslider_skope1.min = -10e10\nslider_skope1.max = 10e10\nslider_skope2.min = -10e10\nslider_skope2.max = 10e10\nslider_skope3.min = -10e10\nslider_skope3.max = 10e10\nslider_skope1.max = max(self.atk.dataset.X[columns_rules[0]])\nslider_skope1.min = min(self.atk.dataset.X[columns_rules[0]])\nslider_skope1.v_model = [self.selection.rules[0][0], self.selection.rules[0][-1]]\n[slider_text_comb1.children[0].v_model, slider_text_comb1.children[2].v_model] = [slider_skope1.v_model[0], slider_skope1.v_model[1]]\nif len(self.selection.rules) &gt; 1 :\nslider_skope2.max = max(self.atk.dataset.X[columns_rules[1]])\nslider_skope2.min = min(self.atk.dataset.X[columns_rules[1]])\nslider_skope2.v_model = [self.selection.rules[1][0], self.selection.rules[1][-1]]\n[slider_text_comb2.children[0].v_model, slider_text_comb2.children[2].v_model] = [slider_skope2.v_model[0],slider_skope2.v_model[1]]\nif len(self.selection.rules) &gt; 2:\nslider_skope3.max = max(self.atk.dataset.X[columns_rules[2]])\nslider_skope3.min = min(self.atk.dataset.X[columns_rules[2]])\nslider_skope3.v_model = [self.selection.rules[2][0], self.selection.rules[2][-1]]\n[\nslider_text_comb3.children[0].v_model,\nslider_text_comb3.children[2].v_model,\n] = [\nslider_skope3.v_model[0],\nslider_skope3.v_model[1],\n]\nwith histogram1.batch_update():\nhistogram1.data[0].x = list(self.atk.dataset.X[columns_rules[0]])\ndf_respect1 = self.selection.respectOneRule(0)\nhistogram1.data[1].x = list(df_respect1[columns_rules[0]])\nif len(set([self.selection.rules[i][2] for i in range(len(self.selection.rules))])) &gt; 1:\nwith histogram2.batch_update():\nhistogram2.data[0].x = list(self.atk.dataset.X[columns_rules[1]])\ndf_respect2 = self.selection.respectOneRule(1)\nhistogram2.data[1].x = list(df_respect2[columns_rules[1]])\nif len(set([self.selection.rules[i][2] for i in range(len(self.selection.rules))])) &gt; 2:\nwith histogram3.batch_update():\nhistogram3.data[0].x = list(self.atk.dataset.X[columns_rules[2]])\ndf_respect3 = self.selection.respectOneRule(2)\nhistogram3.data[1].x = list(df_respect3[columns_rules[2]])\nmodifie_all_histograms(\nslider_skope1.v_model[0], slider_skope1.v_model[1], 0\n)\ntext_skopeES.children[0].children[3].children = [\n# str(skope_rules_clf.rules_[0])\n# + \"\\n\"\n\"p = \"\n+ str(self.selection.score_exp[0])\n+ \"%\"\n+ \" r = \"\n+ str(self.selection.score_exp[1])\n+ \"%\"\n+ \" ext. of the tree =\"\n+ str(self.selection.score_exp[2])\n]\none_card_ES.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules_exp))\nfunction_scores_models(self.selection.indexes)\nin_accordion1_n.children[0].disabled = False\nin_accordion2_n.children[0].disabled = False\nin_accordion3_n.children[0].disabled = False\nslider_skope1.on_event(\"input\", on_value_change_skope1)\nslider_skope2.on_event(\"input\", on_value_change_skope2)\nslider_skope3.on_event(\"input\", on_value_change_skope3)\nslider_text_comb1.children[0].on_event(\"input\", on_value_change_skope1)\nslider_text_comb1.children[2].on_event(\"input\", on_value_change_skope1)\nloading_models.class_ = \"d-none\"\nself.__save_rules = deepcopy(self.selection.rules)\nfunction_change_color(None)\ndef reset_skope(*b):\nself.selection.rules = self.__save_rules\nfunction_validation_skope(None)\nfunction_scores_models(None)\nbutton_reset_skope.on_event(\"click\", reset_skope)\n# here to see the values \u200b\u200bof the selected points (VS and ES)\nout_selec = v.Layout(style_=\"min-width: 47%; max-width: 47%\", children=[v.Html(tag=\"h4\", children=[\"Select points on the figure to see their values \u200b\u200bhere\"])])\nout_selec_SHAP = v.Layout(style_=\"min-width: 47%; max-width: 47%\", children=[v.Html(tag=\"h4\", children=[\"Select points on the figure to see their SHAP values \u200b\u200bhere\"])])\nout_selec_all = v.Alert(\nmax_height=\"400px\",\nstyle_=\"overflow: auto\",\nelevation=\"0\",\nchildren=[\nv.Row(class_='d-flex flex-row justify-space-between', children=[out_selec, v.Divider(class_=\"ma-2\", vertical=True), out_selec_SHAP]),\n],\n)\n# to see the data of the current selection\nout_accordion = v.ExpansionPanels(\nclass_=\"ma-2\",\nchildren=[\nv.ExpansionPanel(\nchildren=[\nv.ExpansionPanelHeader(children=[\"Data selected\"]),\nv.ExpansionPanelContent(children=[out_selec_all]),\n]\n)\n],\n)\nfind_clusters = v.Btn(\nclass_=\"ma-1 mt-2 mb-0\",\nelevation=\"2\",\nchildren=[v.Icon(children=[\"mdi-magnify\"]), \"Find clusters\"],\n)\nslider_clusters = v.Slider(\nstyle_=\"width : 30%\",\nclass_=\"ma-3 mb-0\",\nmin=2,\nmax=20,\nstep=1,\nv_model=3,\ndisabled=True,\n)\ntext_slider_cluster = v.Html(\ntag=\"h3\",\nclass_=\"ma-3 mb-0\",\nchildren=[\"Number of clusters \" + str(slider_clusters.v_model)],\n)\ndef fonct_text_clusters(*b):\ntext_slider_cluster.children = [\n\"Number of clusters \" + str(slider_clusters.v_model)\n]\nslider_clusters.on_event(\"input\", fonct_text_clusters)\ncheck_number_of_clusters = v.Checkbox(\nv_model=True, label=\"Optimal number of clusters :\", class_=\"ma-3\"\n)\ndef bool_nb_opti(*b):\nslider_clusters.disabled = check_number_of_clusters.v_model\ncheck_number_of_clusters.on_event(\"change\", bool_nb_opti)\npart_for_clusters = v.Layout(\nclass_=\"d-flex flex-row\",\nchildren=[\nfind_clusters,\ncheck_number_of_clusters,\nslider_clusters,\ntext_slider_cluster,\n],\n)\nnew_df = pd.DataFrame([], columns=[\"Region #\", \"Number of points\"])\ncolumns = [{\"text\": c, \"sortable\": True, \"value\": c} for c in new_df.columns]\nresults_clusters_table = v.DataTable(\nclass_=\"w-100\",\nstyle_=\"width : 100%\",\nv_model=[],\nshow_select=False,\nheaders=columns,\nitems=new_df.to_dict(\"records\"),\nitem_value=\"Region #\",\nitem_key=\"Region #\",\nhide_default_footer=True,\n)\nresults_clusters = v.Row(\nchildren=[\nv.Layout(\nclass_=\"flex-grow-0 flex-shrink-0\",\nchildren=[v.Btn(class_=\"d-none\", elevation=0, disabled=True)],\n),\nv.Layout(\nclass_=\"flex-grow-1 flex-shrink-0\",\nchildren=[results_clusters_table],\n),\n],\n)\n# allows you to make dyadic clustering\ndef function_clusters(*b):\nloading_clusters.class_ = \"d-flex\"\nif check_number_of_clusters.v_model:\nresult = function_auto_clustering(self.atk.dataset.X_scaled, self.atk.explain[self.__explanation], 3, True)\nelse:\nnb_clusters = slider_clusters.v_model\nresult = function_auto_clustering(self.atk.dataset.X_scaled, self.atk.explain[self.__explanation], nb_clusters, False)\nself.__result_dyadic_clustering = result\nlabels = result[1]\nself.__labels_automatic_clustering = labels\nwith self.fig1.batch_update():\nself.fig1.data[0].marker.color = labels\nself.fig1.update_traces(marker=dict(showscale=False))\nwith self.fig2.batch_update():\nself.fig2.data[0].marker.color = labels\nwith self.fig1_3D.batch_update():\nself.fig1_3D.data[0].marker.color = labels\nself.fig1_3D.update_traces(marker=dict(showscale=False))\nwith self.fig2_3D.batch_update():\nself.fig2_3D.data[0].marker.color = labels\nlabels_regions = result[0]\nnew_df = []\nfor i in range(len(labels_regions)):\nnew_df.append(\n[\ni + 1,\nlen(labels_regions[i]),\nstr(round(len(labels_regions[i]) / len(self.atk.dataset.X) * 100, 2)) + \"%\",\n]\n)\nnew_df = pd.DataFrame(\nnew_df,\ncolumns=[\"Region #\", \"Number of points\", \"Percentage of the dataset\"],\n)\ndata = new_df.to_dict(\"records\")\ncolumns = [\n{\"text\": c, \"sortable\": False, \"value\": c} for c in new_df.columns\n]\nresults_clusters_table = v.DataTable(\nclass_=\"w-100\",\nstyle_=\"width : 100%\",\nshow_select=False,\nsingle_select=True,\nv_model=[],\nheaders=columns,\nitems=data,\nitem_value=\"Region #\",\nitem_key=\"Region #\",\nhide_default_footer=True,\n)\nall_chips = []\nall_radio = []\nN_stages = len(labels_regions)\nMultip = 100\ndebut = 0\nfin = (N_stages * Multip - 1) * (1 + 1 / (N_stages - 1))\npas = (N_stages * Multip - 1) / (N_stages - 1)\nscale_colors = np.arange(debut, fin, pas)\na = 0\nfor i in scale_colors:\ncolor = sns.color_palette(\"viridis\", N_stages * Multip).as_hex()[\nround(i)\n]\nall_chips.append(v.Chip(class_=\"rounded-circle\", color=color))\nall_radio.append(v.Radio(class_=\"mt-4\", value=str(a)))\na += 1\nall_radio[-1].class_ = \"mt-4 mb-0 pb-0\"\npart_for_radio = v.RadioGroup(\nv_model=None,\nclass_=\"mt-10 ml-7\",\nstyle_=\"width : 10%\",\nchildren=all_radio,\n)\npart_for_chips = v.Col(\nclass_=\"mt-10 mb-2 ml-0 d-flex flex-column justify-space-between\",\nstyle_=\"width : 10%\",\nchildren=all_chips,\n)\nresults_clusters = v.Row(\nchildren=[\nv.Layout(\nclass_=\"flex-grow-0 flex-shrink-0\", children=[part_for_radio]\n),\nv.Layout(\nclass_=\"flex-grow-0 flex-shrink-0\", children=[part_for_chips]\n),\nv.Layout(\nclass_=\"flex-grow-1 flex-shrink-0\",\nchildren=[results_clusters_table],\n),\n],\n)\npart_for_selection.children = part_for_selection.children[:-1] + [\nresults_clusters\n]\nradio_buttons_for_color_choice.v_model = \"Clustering auto\"\npart_for_selection.children[-1].children[0].children[0].on_event(\n\"change\", function_choice_cluster\n)\nloading_clusters.class_ = \"d-none\"\nreturn N_stages\n# when we select a region created by the automatic dyadic clustering\ndef function_choice_cluster(widget, event, data):\nresult = self.__result_dyadic_clustering\nlabels = result[1]\nindex = part_for_selection.children[-1].children[0].children[0].v_model\nliste = [i for i, d in enumerate(labels) if d == float(index)]\nfunction_lasso_selection(None, None, None, liste)\nradio_buttons_for_color_choice.v_model = \"Clustering auto\"\nfunction_change_color(opacity=False)\nfind_clusters.on_event(\"click\", function_clusters)\n# function which is called as soon as the points are selected (step 1)\ndef function_lasso_selection(trace, points, selector, *args):\nif len(args) &gt; 0:\nliste = args[0]\nles_points = liste\nelse:\nles_points = points.point_inds\nself.selection = Potato(self.atk, les_points)\nself.selection.state = Potato.LASSO\nif len(les_points) == 0:\ncard_selec.children[0].children[1].children = \"0 point !\"\ntext_selec.value = text_base_debut\nreturn\ncard_selec.children[0].children[1].children = (\nstr(len(les_points))\n+ \" points selected (\"\n+ str(round(len(les_points) / len(self.atk.dataset.X) * 100, 2))\n+ \"% of the overall)\"\n)\ntext_selec.value = (\ntext_base\n+ str(len(les_points))\n+ \" points selected (\"\n+ str(round(len(les_points) / len(self.atk.dataset.X) * 100, 2))\n+ \"% of the overall)\"\n)\nopa = []\nfor i in range(len(self.fig2.data[0].x)):\nif i in les_points:\nopa.append(1)\nelse:\nopa.append(0.1)\nwith self.fig2.batch_update():\nself.fig2.data[0].marker.opacity = opa\nwith self.fig1.batch_update():\nself.fig1.data[0].marker.opacity = opa\nX_train = self.atk.dataset.X.copy()\nX_mean = (\npd.DataFrame(\nX_train.iloc[self.selection.indexes, :].mean(axis=0).values.reshape(1, -1),\ncolumns=X_train.columns,\n)\n.round(2)\n.rename(index={0: \"Mean of the selection\"})\n)\nX_mean_tot = (\npd.DataFrame(\nX_train.mean(axis=0).values.reshape(1, -1), columns=X_train.columns\n)\n.round(2)\n.rename(index={0: \"Mean of the whole dataset\"})\n)\nX_mean = pd.concat([X_mean, X_mean_tot], axis=0)\nSHAP_mean = (\npd.DataFrame(\nself.atk.explain[self.__explanation].iloc[self.selection.indexes, :]\n.mean(axis=0)\n.values.reshape(1, -1),\ncolumns=self.atk.explain[self.__explanation].columns,\n)\n.round(2)\n.rename(index={0: \"Mean of the selection\"})\n)\nSHAP_mean_tot = (\npd.DataFrame(\nself.atk.explain[self.__explanation].mean(axis=0).values.reshape(1, -1),\ncolumns=self.atk.explain[self.__explanation].columns,\n)\n.round(2)\n.rename(index={0: \"Mean of the whole dataset\"})\n)\nSHAP_mean = pd.concat([SHAP_mean, SHAP_mean_tot], axis=0)\nX_mean.insert(loc=0, column=' ', value=[\"Mean of the selection\", \"Mean of the whole dataset\"])\ndata = X_mean.to_dict(\"records\")\ncolumns = [\n{\"text\": c, \"sortable\": True, \"value\": c} for c in X_mean.columns\n]\nout_selec_table_means = v.DataTable(\nv_model=[],\nshow_select=False,\nheaders=columns.copy(),\nitems=data.copy(),\nhide_default_footer=True,\ndisable_sort=True,\n)\ndata = X_train.iloc[self.selection.indexes, :].round(3).to_dict(\"records\")\ncolumns = [\n{\"text\": c, \"sortable\": True, \"value\": c} for c in X_train.columns\n]\nout_selec_table = v.DataTable(\nv_model=[],\nshow_select=False,\nheaders=columns.copy(),\nitems=data.copy(),\n)\nout_selec.children = [v.Col(class_= \"d-flex flex-column justify-center align-center\", children=[\nv.Html(tag=\"h3\", children=[\"Values Space\"]),\nout_selec_table_means,\nv.Divider(class_=\"ma-6\"),\nv.Html(tag=\"h4\", children=[\"Entire dataset:\"], class_=\"mb-2\"),\nout_selec_table\n])]\nSHAP_mean.insert(loc=0, column=' ', value=[\"Mean of the selection\", \"Mean of the whole dataset\"])\ndata = SHAP_mean.to_dict(\"records\")\ncolumns = [\n{\"text\": c, \"sortable\": True, \"value\": c} for c in SHAP_mean.columns\n]\nout_selec_table_means = v.DataTable(\nv_model=[],\nshow_select=False,\nheaders=columns.copy(),\nitems=data.copy(),\nhide_default_footer=True,\ndisable_sort=True,\n)\ndata = self.atk.explain[self.__explanation].iloc[self.selection.indexes, :].round(3).to_dict(\"records\")\ncolumns = [\n{\"text\": c, \"sortable\": True, \"value\": c} for c in self.atk.explain[self.__explanation].columns\n]\nout_selec_table = v.DataTable(\nv_model=[],\nshow_select=False,\nheaders=columns.copy(),\nitems=data.copy(),\n)\nout_selec_SHAP.children = [v.Col(class_=\"d-flex flex-column justify-center align-center\", children=[\nv.Html(tag=\"h3\", children=[\"Explanatory Space\"]),\nout_selec_table_means,\nv.Divider(class_=\"ma-6\"),\nv.Html(tag=\"h4\", children=[\"Entire dataset:\"], class_=\"mb-2\"),\nout_selec_table\n])]\n# function that is called when validating a tile to add it to the set of regions\ndef function_new_region(*args):\nif len(args) == 0:\npass\nelif self.selection in self.atk.regions:\nprint(\"AntakIA WARNING: this region is already in the set of regions\")\nelse:\nself.selection.state = Potato.REGION\nif self.__model_index == None:\nname_model = None\nscore_model = [1,1,1]\nelse:\nname_model = self.sub_models[self.__model_index].__class__.__name__\nscore_model = self.__score_sub_models[self.__model_index]\nif self.selection.rules == None :\nreturn\nself.selection.applyRules()\nnew_tuile = deepcopy(self.selection.getIndexes())\nself.selection.sub_model[\"name\"], self.selection.sub_model[\"score\"] = name_model, score_model\n# here we will force so that all the points of the new tile belong only to it: we will modify the existing tiles\nself.atk.regions = conflict_handler(self.atk.regions, new_tuile)\nself.selection.setIndexes(new_tuile)\nself.atk.newRegion(self.selection)\nself.__color_regions=[0]*len(self.atk.dataset.X)\nfor i in range(len(self.__color_regions)):\nfor j in range(len(self.atk.regions)):\nif i in self.atk.regions[j].indexes:\nself.__color_regions[i] = j+1\nbreak\ntoute_somme = 0\ntemp = []\nscore_tot = 0\nscore_tot_glob = 0\nautre_toute_somme = 0\nfor i in range(len(self.atk.regions)):\nif self.atk.regions[i].sub_model[\"score\"] == None:\ntemp.append(\n[\ni + 1,\nlen(self.atk.regions[i]),\nnp.round(len(self.atk.regions[i]) / len(self.atk.dataset.X) * 100, 2),\n\"/\",\n\"/\",\n\"/\",\n\"/\",\n]\n)\nelse:\ntemp.append(\n[\ni + 1,\nlen(self.atk.regions[i]),\nnp.round(len(self.atk.regions[i]) / len(self.atk.dataset.X) * 100, 2),\nself.atk.regions[i].sub_model[\"model\"],\nself.atk.regions[i].sub_model[\"score\"][0],\nself.atk.regions[i].sub_model[\"score\"][1],\nstr(self.atk.regions[i].sub_model[\"score\"][2]) + \"%\",\n]\n)\nscore_tot += self.atk.regions[i].sub_model[\"score\"][0] * len(self.atk.regions[i])\nscore_tot_glob += self.atk.regions[i].sub_model[\"score\"][1] * len(\nself.atk.regions[i]\n)\nautre_toute_somme += len(self.atk.regions[i])\ntoute_somme += len(self.atk.regions[i])\nif autre_toute_somme == 0:\nscore_tot = \"/\"\nscore_tot_glob = \"/\"\npercent = \"/\"\nelse:\nscore_tot = round(score_tot / autre_toute_somme, 3)\nscore_tot_glob = round(score_tot_glob / autre_toute_somme, 3)\npercent = (\nstr(round(100 * (score_tot_glob - score_tot) / score_tot_glob, 1))\n+ \"%\"\n)\ntemp.append(\n[\n\"Total\",\ntoute_somme,\nnp.round(toute_somme / len(self.atk.dataset.X) * 100, 2),\n\"/\",\nscore_tot,\nscore_tot_glob,\npercent,\n]\n)\nnew_df = pd.DataFrame(\ntemp,\ncolumns=[\n\"Region #\",\n\"Number of points\",\n\"% of the dataset\",\n\"Model\",\n\"Score of the sub-model (MSE)\",\n\"Score of the global model (MSE)\",\n\"Gain in MSE\",\n],\n)\nwith table_regions:\nclear_output()\ndata = new_df[:-1].to_dict(\"records\")\ntotal = new_df[-1:].iloc[:, 1:].to_dict(\"records\")\ncolumns = [\n{\"text\": c, \"sortable\": True, \"value\": c} for c in new_df.columns\n]\ncolumns_total = [\n{\"text\": c, \"sortable\": True, \"value\": c}\nfor c in new_df.columns[1:]\n]\ntable_donnes = v.DataTable(\nv_model=[],\nshow_select=True,\nheaders=columns,\nitems=data,\nitem_value=\"Region #\",\nitem_key=\"Region #\",\n)\ntable_total = v.DataTable(\nv_model=[],\nheaders=columns_total,\nitems=total,\nhide_default_footer=True,\n)\nensemble_tables = v.Layout(\nclass_=\"d-flex flex-column\",\nchildren=[\ntable_donnes,\nv.Divider(class_=\"mt-7 mb-4\"),\nv.Html(tag=\"h2\", children=[\"Review of the regions :\"]),\ntable_total,\n],\n)\ndef function_suppression_tuiles(*b):\nif table_donnes.v_model == []:\nreturn\ntaille = len(table_donnes.v_model)\na = 0\nfor i in range(taille):\nindex = table_donnes.v_model[i][\"Region #\"] - 1\nself.atk.regions.pop(index - a)\nfunction_new_region()\na += 1\nradio_buttons_for_color_choice.v_model = \"R\u00e9gions\"\nfunction_change_color()\nsupprimer_toutes_les_tuiles.on_event(\n\"click\", function_suppression_tuiles\n)\ndisplay(ensemble_tables)\nvalidate_one_region.on_event(\"click\", function_new_region)\nbutton_validate_skope.on_event(\"click\", function_validation_skope)\nself.fig1.data[0].on_selection(function_lasso_selection)\nself.fig2.data[0].on_selection(function_lasso_selection)\ndef function_fig_size(*args):\nwith self.fig1.batch_update():\nself.fig1.layout.width = int(fig_size.v_model)\nwith self.fig2.batch_update():\nself.fig2.layout.width = int(fig_size.v_model)\nwith self.fig1_3D.batch_update():\nself.fig1_3D.layout.width = int(fig_size.v_model)\nwith self.fig2_3D.batch_update():\nself.fig2_3D.layout.width = int(fig_size.v_model)\nfor i in range(len(all_histograms)):\nwith all_histograms[i].batch_update():\nall_histograms[i].layout.width = 0.9 * int(fig_size.v_model)\nwith all_beeswarms[i].batch_update():\nall_beeswarms[i].layout.width = 0.9 * int(fig_size.v_model)\nfig_size.on_event(\"input\", function_fig_size)\nbutton_add_skope = v.Btn(\nclass_=\"ma-4 pa-2 mb-1\",\nchildren=[v.Icon(children=[\"mdi-plus\"]), \"Add a rule\"],\n)\nwidget_list_add_skope = v.Select(\nclass_=\"mr-3 mb-0\",\nitems=[\"/\"],\nv_model=\"/\",\nstyle_=\"max-width : 15%\",\n)\nbutton_add_map = v.Btn(\nclass_=\"ma-4 pa-2 mb-1\",\nchildren=[v.Icon(class_=\"mr-4\", children=[\"mdi-map\"]), \"Display the map\"],\ncolor=\"white\",\ndisabled=True,\n)\ndef function_display_map(widget, event, data):\nif widget.color == \"white\":\npart_map.class_= \"d-flex justify-space-around ma-0 pa-0\"\nwidget.color = \"error\"\nwidget.children =  [widget.children[0]] + [\"Hide the map\"]\nself.__save_lat_rule = [self.selection.rules[i] for i in range(len(self.selection.rules)) if self.selection.rules[i][2] == self.atk.dataset.lat]\nself.__save_long_rule = [self.selection.rules[i] for i in range(len(self.selection.rules)) if self.selection.rules[i][2] == self.atk.dataset.long]\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == self.atk.dataset.lat or self.selection.rules[i-count][2] == self.atk.dataset.long:\nself.selection.rules.pop(i-count)\ncount += 1\nfor i in range(len(accordion_skope.children)):\nif accordion_skope.children[i].children[0].children[0].children[0][4:-1] in [self.atk.dataset.lat, self.atk.dataset.long]:\naccordion_skope.children[i].disabled = True\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nelse:\nself.selection.setIndexesFromMap(None)\nwidget.color = \"white\"\npart_map.class_= \"d-none ma-0 pa-0\"\nwidget.children =  [widget.children[0]] + [\"Display the map\"]\nself.selection.rules = self.selection.rules + self.__save_lat_rule + self.__save_long_rule\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nfor i in range(len(accordion_skope.children)):\naccordion_skope.children[i].disabled = False\nbutton_add_map.on_event(\"click\", function_display_map)\nadd_group = v.Row(children=[button_add_skope, widget_list_add_skope, v.Spacer(), button_add_map])\n# function called when we add a feature to the rules. We instanciate the exact same things than from the previous features\n# (beeswarms, histograms, etc...)\ndef function_add_skope(*b):\nnew_rule = [0] * 5\ncolumn = widget_list_add_skope.v_model\nif self.__other_columns == None:\nreturn\nself.__other_columns = [a for a in self.__other_columns if a != column]\nnew_rule[2] = column\nnew_rule[0] = round(min(list(self.atk.dataset.X[column].values)), 1)\nnew_rule[1] = \"&lt;=\"\nnew_rule[3] = \"&lt;=\"\nnew_rule[4] = round(max(list(self.atk.dataset.X[column].values)), 1)\nself.selection.rules.append(new_rule)\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nnew_validate_change, new_slider_skope, new_histogram = gui_elements.create_new_feature_rule(self, new_rule, column, number_of_bins_histograms, fig_size.v_model)\nall_histograms.append(new_histogram)\ndef new_function_change_validate(*change):\nii = -1\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i][2] == column_2:\nii = int(i)\na = deepcopy(float(new_slider_skope.v_model[0]  ))\nb = deepcopy(float(new_slider_skope.v_model[1]  ))\nself.selection.rules[ii][0] = a\nself.selection.rules[ii][4] = b\nself.selection.rules[ii][0] = a\nself.selection.rules[ii][4] = b\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nfunction_scores_models(None)\nnew_validate_change.on_event(\"click\", new_function_change_validate)\nnew_button_in_real_time_graph = v.Checkbox(\nv_model=False, label=\"Real-time updates on the graphs\", class_=\"ma-3\"\n)\nnew_slider_text_comb = v.Layout(\nchildren=[\nv.TextField(\nstyle_=\"max-width:100px\",\nv_model=new_slider_skope.v_model[0]  ,\nhide_details=True,\ntype=\"number\",\ndensity=\"compact\",\n),\nnew_slider_skope,\nv.TextField(\nstyle_=\"max-width:100px\",\nv_model=new_slider_skope.v_model[1]  ,\nhide_details=True,\ntype=\"number\",\ndensity=\"compact\",\n),\n],\n)\ndef new_update_validate(*args):\nif new_button_in_real_time_graph.v_model:\nnew_validate_change.disabled = True\nelse:\nnew_validate_change.disabled = False\nnew_button_in_real_time_graph.on_event(\"change\", new_update_validate)\nnew_two_end = widgets.HBox([new_validate_change, new_button_in_real_time_graph])\nnew_all_widgets_slider_histo = widgets.VBox(\n[new_slider_text_comb, new_histogram, new_two_end]\n)\ncolumn_shap = column + \"_shap\"\ny_histo_shap = [0] * len(self.atk.explain[self.__explanation])\nnew_beeswarm = go.FigureWidget(\ndata=[go.Scatter(x=self.atk.explain[self.__explanation][column_shap], y=y_histo_shap, mode=\"markers\")]\n)\nnew_beeswarm.update_layout(\nmargin=dict(l=0, r=0, t=0, b=0),\nheight=200,\nwidth=0.9 * int(fig_size.v_model),\n)\nnew_beeswarm.update_yaxes(visible=False, showticklabels=False)\n[new_y, marker] = compute.function_beeswarm_shap(self, self.__explanation, column)\nnew_beeswarm.data[0].y = new_y\nnew_beeswarm.data[0].x = self.atk.explain[self.__explanation][column_shap]\nnew_beeswarm.data[0].marker = marker\nnew_choice_color_beeswarm = v.Row(\nclass_=\"pt-3 mt-0 ml-4\",\nchildren=[\n\"Value of Xi\",\nv.Switch(\nclass_=\"ml-3 mr-2 mt-0 pt-0\",\nv_model=False,\nlabel=\"\",\n),\n\"Current selection\",\n],\n)\ndef new_change_color_beeswarm_shap(*args):\nif new_choice_color_beeswarm.children[1].v_model == False:\nmarker = compute.function_beeswarm_shap(self, self.__explanation, self.selection.rules[len(self.selection.rules) - 1][2])[1]\nnew_beeswarm.data[0].marker = marker\nnew_beeswarm.update_traces(marker=dict(showscale=True))\nelse:\nmodifie_all_histograms(\nnew_slider_skope.v_model[0]  ,\nnew_slider_skope.v_model[1]  ,\n0,\n)\nnew_beeswarm.update_traces(marker=dict(showscale=False))\nnew_choice_color_beeswarm.children[1].on_event(\n\"change\", new_change_color_beeswarm_shap\n)\nnew_beeswarm_tot = widgets.VBox([new_choice_color_beeswarm, new_beeswarm])\nnew_beeswarm_tot.layout.margin = \"0px 0px 0px 20px\"\nall_beeswarms_total.append(new_beeswarm_tot)\nif not check_beeswarm.v_model:\nnew_beeswarm_tot.layout.display = \"none\"\nall_beeswarms.append(new_beeswarm)\nall_color_choosers_beeswarms.append(new_choice_color_beeswarm)\nwidget_list_add_skope.items = self.__other_columns\nwidget_list_add_skope.v_model = self.__other_columns[0]\nnew_b_delete_skope = v.Btn(\ncolor=\"error\",\nclass_=\"ma-2 ml-4 pa-1\",\nelevation=\"3\",\nicon=True,\nchildren=[v.Icon(children=[\"mdi-delete\"])],\n)\ndef new_delete_skope(*b):\ncolumn_2 = new_slider_skope.label\nii = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i][2] == column_2:\nii = i\nbreak\nall_beeswarms_total.pop(ii)\nall_histograms.pop(ii)\nself.selection.rules.pop(ii)\nall_beeswarms.pop(ii)\nall_color_choosers_beeswarms.pop(ii)\nself.__other_columns = [column_2] + self.__other_columns\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nwidget_list_add_skope.items = self.__other_columns\nwidget_list_add_skope.v_model = self.__other_columns[0]\naccordion_skope.children = [\na for a in accordion_skope.children if a != new_in_accordion_n\n]\nfor i in range(ii, len([accordion_skope.children[a] for a in range(len(accordion_skope.children)) if accordion_skope.children[a].disabled == False])):\ncol = \"X\" + str(i + 1) + \" (\" + self.selection.rules[i][2] + \")\"\naccordion_skope.children[i].children[0].children[0].children = [col]\nif widget_list_add_skope.v_model in [self.atk.dataset.lat, self.atk.dataset.long]:\nif self.atk.dataset.lat in [self.selection.rules[i][2] for i in range(len(self.selection.rules))] and self.atk.dataset.long in [self.selection.rules[i][2] for i in range(len(self.selection.rules))]:\nbutton_add_map.disabled = False\nelse :\nbutton_add_map.disabled = True\nupdate_all_graphs()\nnew_b_delete_skope.on_event(\"click\", new_delete_skope)\nis_continuous_new = v.Checkbox(v_model=True, label=\"is continuous?\")\nright_side_new = v.Col(children=[new_b_delete_skope, is_continuous_new], class_=\"d-flex flex-column align-center justify-center\")\nall_widgets_class_new = gui_elements.create_class_selector(self, self.selection.rules[-1][2], min=min(list(self.atk.dataset.X[new_slider_skope.label].values)), max=max(list(self.atk.dataset.X[new_slider_skope.label].values)), fig_size=fig_size.v_model)\ndef change_continuous_new(widget, event, data):\ncolumn_2 = new_slider_skope.label\nindex = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i][2] == column_2:\nindex = i\nbreak\nif widget.v_model == True and widget == right_side_new.children[1]:\nnew_in_accordion.children = [new_all_widgets_slider_histo] + list(new_in_accordion.children[1:])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == self.selection.rules[index][2] and i-count != index:\nself.selection.rules.pop(i-count)\ncount += 1\nself.selection.rules[index][0] = new_slider_skope.v_model[0]\nself.selection.rules[index][4] = new_slider_skope.v_model[1]\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nelse:\nnew_in_accordion.children = [all_widgets_class_new] + list(new_in_accordion.children[1:])\nl = []\nfor i in range(len(all_widgets_class_new.children[2].children)):\nif all_widgets_class_new.children[2].children[i].v_model:\nl.append(int(all_widgets_class_new.children[2].children[i].label))\nif len(l) == 0:\nwidget.v_model = True\nreturn\ncolumn = deepcopy(self.selection.rules[index][2])\ncount = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i-count][2] == column:\nself.selection.rules.pop(i-count)\ncount += 1\ncroissant = 0\nfor ele in l:\nself.selection.rules.insert(index+croissant, [ele-0.5, '&lt;=', column, '&lt;=', ele+0.5])\ncroissant += 1\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules), is_class=True)\nupdate_all_graphs()\nright_side_new.children[1].on_event(\"change\", change_continuous_new)\nfor ii in range(len(all_widgets_class_new.children[2].children)):\nall_widgets_class_new.children[2].children[ii].on_event(\"change\", change_continuous_new)\nnew_in_accordion = widgets.HBox(\n[new_all_widgets_slider_histo, new_beeswarm_tot, right_side_new],\nlayout=Layout(align_items=\"center\"),\n)\nnew_in_accordion_n = v.ExpansionPanels(\nclass_=\"ma-2 mb-1\",\nchildren=[\nv.ExpansionPanel(\nchildren=[\nv.ExpansionPanelHeader(children=[\"Xn\"]),\nv.ExpansionPanelContent(children=[new_in_accordion]),\n]\n)\n],\n)\naccordion_skope.children = [*accordion_skope.children, new_in_accordion_n]\nname_colcol = \"X\" + str(len(accordion_skope.children)) + \" (\" + column + \")\"\naccordion_skope.children[-1].children[0].children[0].children = name_colcol\nwith new_histogram.batch_update():\nnew_list = [\ng\nfor g in list(self.atk.dataset.X[column].values)\nif g &gt;= new_slider_skope.v_model[0]  \nand g &lt;= new_slider_skope.v_model[1]  \n]\nnew_histogram.data[1].x = new_list\ncolumn_2 = new_slider_skope.label\nnew_list_rule = self.atk.dataset.X.index[\nself.atk.dataset.X[column_2].between(\nnew_slider_skope.v_model[0]  ,\nnew_slider_skope.v_model[1]  ,\n)\n].tolist()\nnew_list_tout = new_list_rule.copy()\nfor i in range(1, len(self.selection.rules)):\nnew_list_temp = self.atk.dataset.X.index[\nself.atk.dataset.X[self.selection.rules[i][2]].between(\nself.selection.rules[i][0], self.selection.rules[i][4]\n)\n].tolist()\nnew_list_tout = [g for g in new_list_tout if g in new_list_temp]\nnew_list_tout_new = self.atk.dataset.X[column_2][new_list_tout]\nnew_histogram.data[2].x = new_list_tout_new\ndef new_on_value_change_skope(*b1):\nnew_slider_text_comb.children[0].v_model = (\nnew_slider_skope.v_model[0]  \n)\nnew_slider_text_comb.children[2].v_model = (\nnew_slider_skope.v_model[1]  \n)\ncolumn_2 = new_slider_skope.label\nii = 0\nfor i in range(len(self.selection.rules)):\nif self.selection.rules[i][2] == column_2:\nii = i\nbreak\nnew_list = [\ng\nfor g in list(self.atk.dataset.X[column_2].values)\nif g &gt;= new_slider_skope.v_model[0]  \nand g &lt;= new_slider_skope.v_model[1]  \n]\nwith new_histogram.batch_update():\nnew_histogram.data[1].x = new_list\nif self.__activate_histograms:\nmodifie_all_histograms(\nnew_slider_skope.v_model[0]  ,\nnew_slider_skope.v_model[1]  ,\nii,\n)\nif new_button_in_real_time_graph.v_model:\nself.selection.rules[ii - 1][0] = float(\ndeepcopy(new_slider_skope.v_model[0]  )\n)\nself.selection.rules[ii - 1][4] = float(\ndeepcopy(new_slider_skope.v_model[1]  )\n)\none_card_VS.children = gui_elements.generate_rule_card(\nliste_to_string_skope(self.selection.rules)\n)\nupdate_all_graphs()\nnew_slider_skope.on_event(\"input\", new_on_value_change_skope)\nif new_slider_skope.label in [self.atk.dataset.lat, self.atk.dataset.long]:\nif self.atk.dataset.lat in [self.selection.rules[i][2] for i in range(len(self.selection.rules))] and self.atk.dataset.long in [self.selection.rules[i][2] for i in range(len(self.selection.rules))]:\nbutton_add_map.disabled = False\nelse :\nbutton_add_map.disabled = True\nfunction_new_region()\nbutton_add_skope.on_event(\"click\", function_add_skope)\nparam_VS = gui_elements.create_settings_card(params_proj_VS, \"Settings of the projection in the Values Space\")\nparam_ES = gui_elements.create_settings_card(params_proj_ES, \"Settings of the projection in the Explanatory Space\")\nprojVS_and_load = widgets.HBox(\n[\ndropdown_for_VS,\nv.Layout(children=[param_VS]),\nout_loading1,\n]\n)\nprojES_and_load = widgets.HBox(\n[\ndropdown_for_ES,\nv.Layout(children=[param_ES]),\nout_loading2,\n]\n)\nbouton_reset_opa = v.Btn(\nicon=True,\nchildren=[v.Icon(children=[\"mdi-opacity\"])],\nclass_=\"ma-2 ml-6 pa-3\",\nelevation=\"3\",\n)\nbouton_reset_opa.children = [\nadd_tooltip(\nbouton_reset_opa.children[0],\n\"Reset the opacity of the points\",\n)\n]\ndef function_reset_opa(*args):\nwith self.fig1.batch_update():\nself.fig1.data[0].marker.opacity = 1\nwith self.fig2.batch_update():\nself.fig2.data[0].marker.opacity = 1\nbouton_reset_opa.on_event(\"click\", function_reset_opa)\nitems = [{'text': \"Imported\", 'disabled': True},\n{'text': \"SHAP\", 'disabled': True},\n{'text': \"LIME\", 'disabled': True}]\nfor item in items:\nif self.atk.explain[item['text']] is not None:\nitem_default = item['text']\nitem['disabled'] = False\nchoose_explanation = v.Select(\nlabel=\"Explainability method\",\nitems=items,\nv_model=item_default,\nclass_=\"ma-2 mt-1 ml-6\",\nstyle_=\"width: 150px\",\ndisabled = False,\n)\ndef function_choose_explanation(widget, event, data):\nself.__explanation = data\nexp_val = self.atk.explain[data]\nif self.dim_red['ES'][self.__explanation][self.__projectionES] == None:\nout_loading2.layout.visibility = \"visible\"\ndim_red = compute.DimensionalityReductionChooser(method=dropdown_for_ES.v_model)\nself.dim_red['ES'][self.__explanation][self.__projectionES] = [dim_red.compute(exp_val, 2), dim_red.compute(exp_val, 3)]\nout_loading2.layout.visibility = \"hidden\"\ncompute.update_figures(self, self.__explanation, self.__projectionVS, self.__projectionES)\nchoose_explanation.on_event(\"change\", function_choose_explanation)\nnew_prog_SHAP = gui_elements.prog_other(\"SHAP\")\nnew_prog_LIME = gui_elements.prog_other(\"LIME\")\nif self.__calculus == True:\nif self.__explanation == \"SHAP\":\nnew_prog_SHAP.children[1].v_model = 100\nnew_prog_SHAP.children[2].v_model = \"Computations already done !\"\nnew_prog_SHAP.children[-1].disabled = True\nelif self.__explanation == \"LIME\":\nnew_prog_LIME.children[1].v_model = 100\nnew_prog_LIME.children[2].v_model = \"Computations already done !\"\nnew_prog_LIME.children[-1].disabled = True\ndef function_validation_explanation(widget, event, data):\nif widget.v_model == \"SHAP\":\nself.__compute_SHAP = compute.computationSHAP(self.atk.dataset.X, self.atk.dataset.X_all, self.atk.dataset.model)\nwidgets.jslink((new_prog_SHAP.children[1], \"v_model\"), (self.__compute_SHAP.progress_widget, \"v_model\"))\nwidgets.jslink((new_prog_SHAP.children[2], \"v_model\"), (self.__compute_SHAP.text_widget, \"v_model\"))\nwidgets.jslink((new_prog_SHAP.children[-1], \"color\"), (self.__compute_SHAP.done_widget, \"v_model\"))\nself.__compute_SHAP.compute_in_thread()\nnew_prog_SHAP.children[-1].disabled = True\nif widget.v_model == \"LIME\":\nself.__compute_LIME = compute.computationLIME(self.atk.dataset.X, self.atk.dataset.X_all, self.atk.dataset.model)\nwidgets.jslink((new_prog_LIME.children[1], \"v_model\"), (self.__compute_LIME.progress_widget, \"v_model\"))\nwidgets.jslink((new_prog_LIME.children[2], \"v_model\"), (self.__compute_LIME.text_widget, \"v_model\"))\nwidgets.jslink((new_prog_LIME.children[-1], \"color\"), (self.__compute_LIME.done_widget, \"v_model\"))\nself.__compute_LIME.compute_in_thread()\nnew_prog_LIME.children[-1].disabled = True\ndef when_SHAP_computation_is_done(*args):\nself.atk.explain[\"SHAP\"] = self.__compute_SHAP.value\nitems = choose_explanation.items.copy()\nfor item in items:\nif item['text'] == \"SHAP\":\nitem['disabled'] = False\nchoose_explanation.items = items.copy() + [{'text': \"Update\", 'disabled': False}]\nchoose_explanation.items = choose_explanation.items[:-1]\ndef when_LIME_computation_is_done(*args):\nself.atk.explain[\"LIME\"] = self.__compute_LIME.value\nitems = choose_explanation.items.copy()\nfor item in items:\nif item['text'] == \"LIME\":\nitem['disabled'] = False\nchoose_explanation.items = items.copy() + [{'text': \"Update\", 'disabled': False}]\nchoose_explanation.items = choose_explanation.items[:-1]\nnew_prog_SHAP.children[-1].observe(when_SHAP_computation_is_done, \"color\")\nnew_prog_LIME.children[-1].observe(when_LIME_computation_is_done, \"color\")\nnew_prog_SHAP.children[-1].on_event(\"click\", function_validation_explanation)\nnew_prog_LIME.children[-1].on_event(\"click\", function_validation_explanation)\ntime_computing = gui_elements.time_computing(new_prog_SHAP, new_prog_LIME)\nwidgets.jslink(\n(time_computing.children[0], \"v_model\"), (time_computing.children[1].children[0], \"v_model\")\n)\nchoose_computing = v.Menu(\nv_slots=[\n{\n\"name\": \"activator\",\n\"variable\": \"props\",\n\"children\": v.Btn(\nv_on=\"props.on\",\nicon=True,\nsize=\"x-large\",\nchildren=[add_tooltip(v.Icon(children=[\"mdi-timer-sand\"], size=\"large\"), \"Time of computing\")],\nclass_=\"ma-2 pa-3\",\nelevation=\"3\",\n),\n}\n],\nchildren=[\nv.Card(\nclass_=\"pa-4\",\nrounded=True,\nchildren=[time_computing],\nmin_width=\"500\",\n)\n],\nv_model=False,\nclose_on_content_click=False,\noffset_y=True,\n)\ntop_of_the_UI_all_buttons = widgets.HBox(\n[\ndimension_projection_text,\nv.Layout(\nclass_=\"pa-2 ma-2\",\nelevation=\"3\",\nchildren=[\nadd_tooltip(\nv.Icon(\nchildren=[\"mdi-format-color-fill\"],\nclass_=\"mt-n5 mr-4\"\n),\n\"Color of the points\",\n),\nradio_buttons_for_color_choice,\nbouton_reset_opa,\nchoose_explanation,\nchoose_computing,\n],\n),\nv.Layout(class_=\"mt-3\", children=[projVS_and_load, projES_and_load]),\n],\nlayout=Layout(\nwidth=\"100%\",\ndisplay=\"flex\",\nflex_flow=\"row\",\njustify_content=\"space-around\",\n),\n)\nfigures = widgets.VBox([fig_2D_ou_3D], layout=Layout(width=\"100%\"))\ncheck_beeswarm = v.Checkbox(\nv_model=True,\nlabel=\"Show Shapley's beeswarm plots\",\nclass_=\"ma-1 mr-3\",\n)\ndef function_check_beeswarm(*b):\nif not check_beeswarm.v_model:\nfor i in range(len(all_beeswarms_total)):\nall_beeswarms_total[i].layout.display = \"none\"\nelse:\nfor i in range(len(all_beeswarms_total)):\nall_beeswarms_total[i].layout.display = \"block\"\ncheck_beeswarm.on_event(\"change\", function_check_beeswarm)\nbuttons_skope = v.Layout(\nclass_=\"d-flex flex-row\",\nchildren=[\nbutton_validate_skope,\nbutton_reset_skope,\nv.Spacer(),\ncheck_beeswarm,\n],\n)\ntwo_buttons = widgets.VBox([buttons_skope, text_skope])\nbouton_magic = v.Btn(\nclass_=\"ma-3\",\nchildren=[\nv.Icon(children=[\"mdi-creation\"], class_=\"mr-3\"),\n\"Magic button\",\n],\n)\npart_for_magic = v.Layout(\nclass_=\"d-flex flex-row justify-center align-center\",\nchildren=[\nv.Spacer(),\nbouton_magic,\nv.Checkbox(v_model=True, label=\"Demonstration mode\", class_=\"ma-4\"),\nv.TextField(\nclass_=\"shrink\",\ntype=\"number\",\nlabel=\"Time between the steps (ds)\",\nv_model=10,\n),\nv.Spacer(),\n],\n)\ndef function_checkbox_magic(*args):\nif part_for_magic.children[2].v_model:\npart_for_magic.children[3].disabled = False\nelse:\npart_for_magic.children[3].disabled = True\npart_for_magic.children[2].on_event(\"change\", function_checkbox_magic)\ndef find_best_score():\na = 1000\nfor i in range(len(self.__score_sub_models)):\nscore = self.__score_sub_models[i][0]\nif score &lt; a:\na = score\nindex = i\nreturn index\ndef function_bouton_magic(*args):\ndemo = part_for_magic.children[2].v_model\nif demo == False:\nstages.children[0].v_model = 3\nN_stages = function_clusters(None)\nif demo:\ntempo = int(part_for_magic.children[3].v_model) / 10\nif tempo &lt; 0:\ntempo = 0\nelse:\ntempo = 0\ntime.sleep(tempo)\nfor i in range(N_stages):\npart_for_selection.children[-1].children[0].children[0].v_model = str(i)\nfunction_choice_cluster(None, None, None)\ntime.sleep(tempo)\nif demo:\nstages.children[0].v_model = 1\ntime.sleep(tempo)\nfunction_validation_skope(None)\ntime.sleep(tempo)\nif demo:\nstages.children[0].v_model = 2\ntime.sleep(tempo)\nindex = find_best_score()\nmods.children[index].children[0].color = \"blue lighten-4\"\nchange(None, None, None, False)\ntime.sleep(tempo)\nmods.children[index].children[0].color = \"white\"\nif demo:\nstages.children[0].v_model = 3\ntime.sleep(tempo)\nfunction_new_region(None)\ntime.sleep(tempo)\nif i != N_stages - 1:\nif demo:\nstages.children[0].v_model = 0\ntime.sleep(tempo)\nradio_buttons_for_color_choice.v_model = \"R\u00e9gions\"\nfunction_change_color(None)\n#map plotly\nmap_select = go.FigureWidget(\ndata=go.Scatter(x=[1], y=[1], mode=\"markers\", marker=marker1, customdata=marker1[\"color\"], hovertemplate = '%{customdata:.3f}')\n)\nmap_select.update_layout(dragmode=\"lasso\")\n# instanciate the map, with longitude and latitude\nif self.atk.dataset.lat is not None and self.atk.dataset.long is not None:\ndf = self.atk.dataset.X\ndata=go.Scattergeo(\nlon = df[self.atk.dataset.long],\nlat = df[self.atk.dataset.lat],\nmode = 'markers',\nmarker_color = self.atk.dataset.y,\n)\nmap_select = go.FigureWidget(\ndata=data\n)\nlat_center = max(df[self.atk.dataset.lat]) - (max(df[self.atk.dataset.lat]) - min(df[self.atk.dataset.lat]))/2\nlong_center = max(df[self.atk.dataset.long]) - (max(df[self.atk.dataset.long]) - min(df[self.atk.dataset.long]))/2\nmap_select.update_layout(\nmargin={\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0},\n#geo_scope=\"world\",\nheight=300,\nwidth=900,\ngeo=dict(\ncenter=dict(\nlat=lat_center,\nlon=long_center\n),\nprojection_scale=5,\nshowland = True,\n)\n)\nmap_text_selection = v.Card(\nstyle_=\"width: 30%\",\nclass_=\"ma-5\",\nchildren=[\nv.CardTitle(children=[\"Selection on the map\"]),\nv.CardText(\nchildren=[\nv.Html(\ntag=\"div\",\nchildren=[\"No selection\"],\n)\n]\n),\n],\n)\ndef change_text_map(trace, points, selector):\nmap_text_selection.children[1].children[0].children = [\"Number of entries selected: \" + str(len(points.point_inds))]\nself.selection.setIndexesFromMap(points.point_inds)\none_card_VS.children = gui_elements.generate_rule_card(liste_to_string_skope(self.selection.rules))\nupdate_all_graphs()\nmap_select.data[0].on_selection(change_text_map)\npart_map = v.Layout(\nclass_=\"d-none ma-0 pa-0\",\nchildren=[map_select, map_text_selection]\n)\nbouton_magic.on_event(\"click\", function_bouton_magic)\nloading_clusters = v.ProgressLinear(\nindeterminate=True, class_=\"ma-3\", style_=\"width : 100%\"\n)\nloading_clusters.class_ = \"d-none\"\npart_for_selection = v.Col(\nchildren=[\ncard_selec,\nout_accordion,\npart_for_clusters,\nloading_clusters,\nresults_clusters,\n]\n)\nloading_models = v.ProgressLinear(\nindeterminate=True,\nclass_=\"my-0 mx-15\",\nstyle_=\"width: 100%;\",\ncolor=\"primary\",\nheight=\"5\",\n)\nloading_models.class_ = \"d-none\"\npart_for_skope = v.Col(children=[two_buttons, accordion_skope, add_group, part_map])\npart_for_modele = widgets.VBox([loading_models, mods])\npart_for_toutes_regions = widgets.VBox([selection, table_regions])\nstages = v.Card(\nclass_=\"w-100 pa-3 ma-3\",\nelevation=\"3\",\nchildren=[\nv.Tabs(\nclass_=\"w-100\",\nv_model=\"tabs\",\nchildren=[\nv.Tab(value=\"one\", children=[\"1. Current selection\"]),\nv.Tab(value=\"two\", children=[\"2. Selection adjustment\"]),\nv.Tab(value=\"three\", children=[\"3. Choice of the sub-model\"]),\nv.Tab(value=\"four\", children=[\"4. Overview of the regions\"]),\n],\n),\nv.CardText(\nclass_=\"w-100\",\nchildren=[\nv.Window(\nclass_=\"w-100\",\nv_model=\"tabs\",\nchildren=[\nv.WindowItem(value=0, children=[part_for_selection]),\nv.WindowItem(value=1, children=[part_for_skope]),\nv.WindowItem(value=2, children=[part_for_modele]),\nv.WindowItem(value=3, children=[part_for_toutes_regions]),\n],\n)\n],\n),\n],\n)\nwidgets.jslink(\n(stages.children[0], \"v_model\"), (stages.children[1].children[0], \"v_model\")\n)\npart_for_data = widgets.VBox(\n[\nbarre_menu,\ndialogue_save,\ntop_of_the_UI_all_buttons,\nfigures,\nstages,\npart_for_magic,\n],\nlayout=Layout(width=\"100%\"),\n)\ndisplay(part_for_data)\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.GUI.getSelection","title":"<code>getSelection()</code>","text":"<p>Function that returns the current selection.</p> <p>Returns:</p> Type Description <code>Potato object</code> <p>The current selection.</p> Source code in <code>antakia/gui.py</code> <pre><code>def getSelection(self):\n\"\"\"Function that returns the current selection.\n    Returns\n    -------\n    Potato object\n        The current selection.\n    \"\"\"\nreturn self.selection\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.GUI.getSubModels","title":"<code>getSubModels()</code>","text":"<p>Function that returns the list of sub-models.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of sub-models.</p> Source code in <code>antakia/gui.py</code> <pre><code>def getSubModels(self):\n\"\"\"Function that returns the list of sub-models.\n    Returns\n    -------\n    list\n        The list of sub-models.\n    \"\"\"\nreturn self.sub_models\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.GUI.setSubModel","title":"<code>setSubModel(sub_models)</code>","text":"<p>Function that sets the list of sub-models.</p> <p>Parameters:</p> Name Type Description Default <code>sub_models</code> <code>list</code> <p>The new list of sub-models.</p> required Source code in <code>antakia/gui.py</code> <pre><code>def setSubModel(self, sub_models):\n\"\"\"Function that sets the list of sub-models.\n    Parameters\n    ----------\n    sub_models : list\n        The new list of sub-models.\n    \"\"\"\nself.sub_models = sub_models\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato","title":"<code>Potato(atk, array=[], json_path=None)</code>","text":"<p>A Potato object! A Potato is a selection of points from the dataset, on wich the user can apply a surrogate-model.</p> <p>Attributes:</p> Name Type Description <code>atk</code> <code>AntakIA object</code> <p>The AntakIA object linked to the potato.</p> <code>indexes</code> <code>list</code> <p>The list of the indexes of the points in the dataset.</p> <code>dataset</code> <code>Dataset object</code> <p>The Dataset object containing the data of the selection.</p> <code>data</code> <code>pandas dataframe</code> <p>The dataframe containing the data of the selection.</p> <code>y</code> <code>list</code> <p>The list of the target values of the selection.</p> <code>sub_model</code> <code>model object</code> <p>The surrogate-model of the selection. Could be None.</p> <code>rules</code> <code>list</code> <p>The list of the rules that defines the selection.</p> <code>score</code> <code>tuple</code> <p>The score of the surrogate-model. Is the following format : (precision, recall, extract of the tree).</p> <code>rules_exp</code> <code>list</code> <p>The list of the rules that defines the selection in the explanation space.</p> <code>score_exp</code> <code>tuple</code> <p>The score of the surrogate-model in the explanation space. Is the following format : (precision, recall, extract of the tree).</p> <code>success</code> <code>bool</code> <p>True if the rules have been found, False otherwise.</p> <code>y_train</code> <code>list</code> <p>The list of the target values of the dataset.</p> <code>explain</code> <code>dict</code> <p>The dict containing the explanations of the selection. Is the following format : {\"Imported\": imported explanations, \"SHAP\": SHAP explanations, \"LIME\": LIME explanations}.</p> <code>state</code> <code>int</code> <p>The state of the potato.</p> <p>Parameters:</p> Name Type Description Default <code>atk</code> <code>AntakIA object</code> <p>The AntakIA object linked to the potato.</p> required <code>array</code> <code>list</code> <p>The list of the indexes of the points in the dataset.</p> <code>[]</code> <code>json_path</code> <code>str</code> <p>The name of the json file containing the indexes of the points in the dataset.</p> <code>None</code> Source code in <code>antakia/potato.py</code> <pre><code>def __init__(self,  atk, array:list = [], json_path: str = None) -&gt; None:\n\"\"\"\n    Constructor of the class Potato.\n    Parameters\n    ----------\n    atk : AntakIA object\n        The AntakIA object linked to the potato.\n    array : list\n        The list of the indexes of the points in the dataset.\n    json_path : str\n        The name of the json file containing the indexes of the points in the dataset.\n    \"\"\"\nimport antakia\nif not isinstance(atk, antakia.AntakIA):\nraise ValueError(\"You must provide an AntakIA object\")\nself.atk = atk\nself.state = Potato.UNKNOWN\nif json_path is not None and array != []:\nraise ValueError(\"You can't provide a list and a json file\")\nif json_path is not None:\nself.state = Potato.JSON\nif json_path[-5:] != \".json\":\njson_path += \".json\"\nfileObject = open(json_path, \"r\")\njsonContent = fileObject.read()\nself.indexes = JSON.loads(jsonContent)\nelse :\nself.indexes = array\nself.dataset = atk.dataset\nif self.dataset.X is not None:\nself.data = self.dataset.X.iloc[self.indexes]\nelse :\nself.data = None\nif self.dataset.y is not None:\nself.y = self.dataset.y.iloc[self.indexes]\nelse :\nself.y = None\nself.sub_model = {\"model\": None, \"score\": None}\nself.rules = None\nself.score = None\nself.rules_exp = None\nself.score_exp = None\nself.success = None\nself.y_train = []\nfor i in range(len(self.dataset.X)):\nif i in self.indexes:\nself.y_train.append(1)\nelse :\nself.y_train.append(0)\nself.indexes_from_map = None\nself.explain = {\"Imported\": None, \"SHAP\": None, \"LIME\": None}\nif self.atk.explain[\"Imported\"] is not None:\nself.explain[\"Imported\"] = self.atk.explain[\"Imported\"].iloc[self.indexes]\nif self.atk.explain[\"SHAP\"] is not None:\nself.explain[\"SHAP\"] = self.atk.explain[\"SHAP\"].iloc[self.indexes]\nif self.atk.explain[\"LIME\"] is not None:\nself.explain[\"LIME\"] = self.atk.explain[\"LIME\"].iloc[self.indexes]\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.__len__","title":"<code>__len__()</code>","text":"<p>The length of the potato.</p> <p>Returns:</p> Type Description <code>int</code> <p>The length of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"\n    The length of the potato.\n    Returns\n    -------\n    int\n        The length of the potato.\n    \"\"\"\nreturn len(self.indexes)\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.applyRules","title":"<code>applyRules(to_return=False)</code>","text":"<p>Function that applies the rules to the dataset, in order to create a new selection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from antakia import AntakIA, Dataset, Potato\n&gt;&gt;&gt; X = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns = [\"col1\", \"col2\", \"col3\"], index = [1, 3, 4])\n&gt;&gt;&gt; atk = AntakIA(Dataset(X, model))\n&gt;&gt;&gt; potato = Potato(indexes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], atk)\n&gt;&gt;&gt; potato.rules = [[0, \"&lt;=\", \"col1\", \"&lt;=\", 9], [3, \"&lt;=\", \"col2\", \"&lt;=\", 8]]\n&gt;&gt;&gt; potato.applyRules()\n&gt;&gt;&gt; potato.indexes\n[3, 4] # only the two last points respect the rules !\n</code></pre> Source code in <code>antakia/potato.py</code> <pre><code>def applyRules(self, to_return:bool=False):\n\"\"\"\n    Function that applies the rules to the dataset, in order to create a new selection.\n    Examples\n    --------\n    &gt;&gt;&gt; from antakia import AntakIA, Dataset, Potato\n    &gt;&gt;&gt; X = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns = [\"col1\", \"col2\", \"col3\"], index = [1, 3, 4])\n    &gt;&gt;&gt; atk = AntakIA(Dataset(X, model))\n    &gt;&gt;&gt; potato = Potato(indexes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], atk)\n    &gt;&gt;&gt; potato.rules = [[0, \"&lt;=\", \"col1\", \"&lt;=\", 9], [3, \"&lt;=\", \"col2\", \"&lt;=\", 8]]\n    &gt;&gt;&gt; potato.applyRules()\n    &gt;&gt;&gt; potato.indexes\n    [3, 4] # only the two last points respect the rules !\n    \"\"\"\nself.state = Potato.SKR\n\"\"\"\n    rules = self.rules\n    df = self.dataset.X\n    for i in range(len(rules)):\n        regle1 = \"df.loc[\" + str(rules[i][0]) + rules[i][1] + \"df['\" + rules[i][2] + \"']]\"\n        regle2 = \"df.loc[\" + \"df['\" + rules[i][2] + \"']\" + rules[i][3] + str(rules[i][4]) + \"]\"\n        df = eval(regle1)\n        df = eval(regle2)\n    self.data = df\n    self.setIndexes(df.index)\n    \"\"\"\nsolo_features = list(set([self.rules[i][2] for i in range(len(self.rules))]))\nnombre_features_rules = []\nfor i in range(len(solo_features)):\nnombre_features_rules.append([])\nfor i in range(len(self.rules)):\nnombre_features_rules[solo_features.index(self.rules[i][2])].append(self.rules[i])\nnouvelle_tuile = self.atk.dataset.X.index\nfor i in range(len(nombre_features_rules)):\nnouvelle_tuile_temp = []\nfor j in range(len(nombre_features_rules[i])):\nX_temp = self.atk.dataset.X[\n(self.atk.dataset.X[nombre_features_rules[i][j][2]] &gt;= nombre_features_rules[i][j][0])\n&amp; (self.atk.dataset.X[nombre_features_rules[i][j][2]] &lt;= nombre_features_rules[i][j][4])\n].index\nnouvelle_tuile_temp = list(nouvelle_tuile_temp) + list(X_temp)\nnouvelle_tuile_temp = list(set(nouvelle_tuile_temp))\nnouvelle_tuile = [g for g in nouvelle_tuile if g in nouvelle_tuile_temp]\nif self.indexes_from_map is not None:\nnouvelle_tuile = [g for g in nouvelle_tuile if g in self.indexes_from_map]\nif to_return:\nreturn nouvelle_tuile\nself.setIndexes(nouvelle_tuile)\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.applySkope","title":"<code>applySkope(explanation, p=0.7, r=0.7)</code>","text":"<p>Function that applies the skope-rules algorithm to the dataset, in order to create a new selection. Must be connected to the AntakIA object (for the explanation space).</p> <p>Parameters:</p> Name Type Description Default <code>explanation</code> <code>str</code> <p>The name of the explanation to use.</p> required <code>p</code> <code>float = 0.7</code> <p>The minimum precision of the rules.</p> <code>0.7</code> <code>r</code> <code>float = 0.7</code> <p>The minimum recall of the rules.</p> <code>0.7</code> Source code in <code>antakia/potato.py</code> <pre><code>def applySkope(self, explanation, p:float = 0.7, r:float = 0.7):\n\"\"\"\n    Function that applies the skope-rules algorithm to the dataset, in order to create a new selection.\n    Must be connected to the AntakIA object (for the explanation space).\n    Parameters\n    ----------\n    explanation : str\n        The name of the explanation to use.\n    p : float = 0.7\n        The minimum precision of the rules.\n    r : float = 0.7\n        The minimum recall of the rules.\n    \"\"\"\nif self.atk.explain[explanation] is None:\nraise ValueError(\"You must provide a valid explanation space\")\ny_train = np.zeros(len(self.dataset.X))\ny_train[self.indexes] = 1\nskope_rules_clf = SkopeRules(\nfeature_names=self.dataset.X.columns,\nrandom_state=42,\nn_estimators=5,\nrecall_min=r,\nprecision_min=p,\nmax_depth_duplication=0,\nmax_samples=1.0,\nmax_depth=3,\n)\nskope_rules_clf.fit(self.dataset.X, y_train)\nskope_rules_clf_exp = SkopeRules(\nfeature_names=self.atk.explain[explanation].columns,\nrandom_state=42,\nn_estimators=5,\nrecall_min=r,\nprecision_min=p,\nmax_depth_duplication=0,\nmax_samples=1.0,\nmax_depth=3,\n)\nskope_rules_clf_exp.fit(self.atk.explain[explanation], y_train)\nif skope_rules_clf.rules_ == [] or skope_rules_clf_exp.rules_ == []:\nself.rules, self.score_skope, self.rules_exp, self.score_skope_exp = None, None, None, None\nself.success = False\nself.__error_message(\"No rules found for this precision and recall\")\nelse :\nself.rules, self.score = self.__transform_rules(skope_rules_clf.rules_, self.dataset.X)\nself.rules_exp, self.score_exp = self.__transform_rules(skope_rules_clf_exp.rules_, self.atk.explain[explanation])\nself.checkForDuplicates()\nself.applyRules()\nself.success = True\nself.state = Potato.SKR\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.checkForDuplicates","title":"<code>checkForDuplicates()</code>","text":"<p>Function that checks if there are duplicates in the rules. A duplicate is a rule that has the same feature as another rule, but with a different threshold.</p> Source code in <code>antakia/potato.py</code> <pre><code>def checkForDuplicates(self):\n\"\"\"\n    Function that checks if there are duplicates in the rules.\n    A duplicate is a rule that has the same feature as another rule, but with a different threshold.\n    \"\"\"\nfeatures = [self.rules[i][2] for i in range(len(self.rules))]\nfeatures_alone = list(set(features))\nif len(features) == len(features_alone):\nreturn\nelse :\nfor feature in features:\nif features.count(feature) &gt; 1:\na=0\nfor i in range(len(self.rules)):\nmin_feature = -10e99\nmax_feature = 10e99\nif self.rules[i-a][2] == feature:\nif self.rules[i-a][0] &gt; min_feature:\nmin_feature = self.rules[i-a][0]\nif self.rules[i-a][4] &lt; max_feature:\nmax_feature = self.rules[i-a][4]\nself.rules.pop(i-a)\na+=1\nself.rules.append([min_feature, \"&lt;=\", feature, \"&lt;=\", max_feature])\n# same thing for the explanation space\nfeatures = [self.rules_exp[i][2] for i in range(len(self.rules_exp))]\nfeatures_alone = list(set(features))\nif len(features) == len(features_alone):\nreturn\nelse :\nfor feature in features:\nif features.count(feature) &gt; 1:\na=0\nfor i in range(len(self.rules_exp)):\nmin_feature = -10e99\nmax_feature = 10e99\nif self.rules_exp[i-a][2] == feature:\nif self.rules_exp[i-a][0] &gt; min_feature:\nmin_feature = self.rules_exp[i-a][0]\nif self.rules_exp[i-a][4] &lt; max_feature:\nmax_feature = self.rules_exp[i-a][4]\nself.rules_exp.pop(i-a)\na+=1\nself.rules_exp.append([min_feature, \"&lt;=\", feature, \"&lt;=\", max_feature])\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.getESdata","title":"<code>getESdata(explanation='Imported')</code>","text":"<p>Function that returns the data of the potato in the explanation space.</p> <p>Parameters:</p> Name Type Description Default <code>explanation</code> <code>str</code> <p>The name of the explanation space.</p> <code>'Imported'</code> <p>Returns:</p> Type Description <code>pandas dataframe</code> <p>The data of the potato in the explanation space.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getESdata(self, explanation=\"Imported\") -&gt; list:\n\"\"\"\n    Function that returns the data of the potato in the explanation space.\n    Parameters\n    ----------\n    explanation : str\n        The name of the explanation space.\n    Returns\n    -------\n    pandas dataframe\n        The data of the potato in the explanation space.\n    \"\"\"\nreturn self.explain[explanation]\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.getESrules","title":"<code>getESrules()</code>","text":"<p>Function that returns the rules of the potato in the explanation space.</p> <p>Returns:</p> Type Description <code>list</code> <p>The rules of the potato in the explanation space.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getESrules(self):\n\"\"\"\n    Function that returns the rules of the potato in the explanation space.\n    Returns\n    -------\n    list\n        The rules of the potato in the explanation space.\n    \"\"\"\nreturn self.rules_exp\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.getESscore","title":"<code>getESscore()</code>","text":"<p>Function that returns the score of the potato in the explanation space.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>The score of the potato in the explanation space.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getESscore(self):\n\"\"\"\n    Function that returns the score of the potato in the explanation space.\n    Returns\n    -------\n    tuple\n        The score of the potato in the explanation space.\n    \"\"\"\nreturn self.score_exp\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.getIndexes","title":"<code>getIndexes()</code>","text":"<p>Function that returns the indexes of the potato.</p> <p>Returns:</p> Type Description <code>list</code> <p>The indexes of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getIndexes(self) -&gt; list:\n\"\"\"\n    Function that returns the indexes of the potato.\n    Returns\n    -------\n    list\n        The indexes of the potato.\n    \"\"\"\nreturn self.indexes\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.getSubModel","title":"<code>getSubModel()</code>","text":"<p>Function that returns the sub-model of the potato.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The sub-model of the potato. Is the following format : {\"model\": model object, \"score\": score of the model}.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getSubModel(self):\n\"\"\"\n    Function that returns the sub-model of the potato.\n    Returns\n    -------\n    dict\n        The sub-model of the potato. Is the following format : {\"model\": model object, \"score\": score of the model}.\n    \"\"\"\nreturn self.sub_model\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.getVSdata","title":"<code>getVSdata()</code>","text":"<p>Function that returns the data of the potato.</p> <p>Returns:</p> Type Description <code>pandas dataframe</code> <p>The data of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getVSdata(self) -&gt; pd.DataFrame:\n\"\"\"\n    Function that returns the data of the potato.\n    Returns\n    -------\n    pandas dataframe\n        The data of the potato.\n    \"\"\"\nreturn self.data\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.getVSrules","title":"<code>getVSrules()</code>","text":"<p>Function that returns the rules of the potato.</p> <p>Returns:</p> Type Description <code>list</code> <p>The rules of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getVSrules(self):\n\"\"\"\n    Function that returns the rules of the potato.\n    Returns\n    -------\n    list\n        The rules of the potato.\n    \"\"\"\nreturn self.rules\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.getVSscore","title":"<code>getVSscore()</code>","text":"<p>Function that returns the score of the potato.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>The score of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def getVSscore(self):\n\"\"\"\n    Function that returns the score of the potato.\n    Returns\n    -------\n    tuple\n        The score of the potato.\n    \"\"\"\nreturn self.score\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.printRules","title":"<code>printRules()</code>","text":"<p>Function that prints the rules of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def printRules(self):\n\"\"\"\n    Function that prints the rules of the potato.\n    \"\"\"\nif self.rules is None:\nprint(\"No rules\")\nelse :\nself.pretty_print(self.rules, ch3 = '-', ch2=\" \")\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.respectOneRule","title":"<code>respectOneRule(index)</code>","text":"<p>Function that returns the points of the dataset that respect only one rule of the list of rules.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the rule to respect.</p> required <p>Returns:</p> Type Description <code>pandas dataframe</code> <p>The dataframe containing the points of the dataset that respect only one rule of the list of rules.</p> Source code in <code>antakia/potato.py</code> <pre><code>def respectOneRule(self, index:int):\n\"\"\"\n    Function that returns the points of the dataset that respect only one rule of the list of rules.\n    Parameters\n    ----------\n    index : int\n        The index of the rule to respect.\n    Returns\n    -------\n    pandas dataframe\n        The dataframe containing the points of the dataset that respect only one rule of the list of rules.\n    \"\"\"\nrules = self.rules\ndf = deepcopy(self.dataset.X)\nregle1 = \"df.loc[\" + str(rules[index][0]) + rules[index][1] + \"df['\" + rules[index][2] + \"']]\"\nregle2 = \"df.loc[\" + \"df['\" + rules[index][2] + \"']\" + rules[index][3] + str(rules[index][4]) + \"]\"\ndf = eval(regle1)\ndf = eval(regle2)\nreturn df\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.setIndexes","title":"<code>setIndexes(indexes)</code>","text":"<p>Function that sets the indexes of the potato.</p> <p>Parameters:</p> Name Type Description Default <code>indexes</code> <code>list</code> <p>The new indexes of the potato.</p> required Source code in <code>antakia/potato.py</code> <pre><code>def setIndexes(self, indexes:list) -&gt; None:\n\"\"\"\n    Function that sets the indexes of the potato.\n    Parameters\n    ----------\n    indexes : list\n        The new indexes of the potato.\n    \"\"\"\nself.indexes = indexes\nself.data = self.dataset.X.iloc[self.indexes]\nself.y = self.dataset.y.iloc[self.indexes]\nself.y_train = []\nfor i in range(len(self.dataset.X)):\nif i in self.indexes:\nself.y_train.append(1)\nelse :\nself.y_train.append(0)\nself.state = Potato.LASSO\nself.success = None\nself.explain = {\"Imported\": None, \"SHAP\": None, \"LIME\": None}\nif self.atk.explain[\"Imported\"] is not None:\nself.explain[\"Imported\"] = self.atk.explain[\"Imported\"].iloc[self.indexes]\nif self.atk.explain[\"SHAP\"] is not None:\nself.explain[\"SHAP\"] = self.atk.explain[\"SHAP\"].iloc[self.indexes]\nif self.atk.explain[\"LIME\"] is not None:\nself.explain[\"LIME\"] = self.atk.explain[\"LIME\"].iloc[self.indexes]\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.setIndexesFromMap","title":"<code>setIndexesFromMap(indexes)</code>","text":"<p>Function that sets the indexes of the potato from a map.</p> <p>Parameters:</p> Name Type Description Default <code>indexes</code> <code>list</code> <p>The new indexes of the potato.</p> required Source code in <code>antakia/potato.py</code> <pre><code>def setIndexesFromMap(self, indexes:list) -&gt; None:\n\"\"\"\n    Function that sets the indexes of the potato from a map.\n    Parameters\n    ----------\n    indexes : list\n        The new indexes of the potato.\n    \"\"\"\nself.indexes_from_map = indexes\nself.applyRules()\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.setSubModel","title":"<code>setSubModel(model)</code>","text":"<p>Function that sets the sub-model of the potato.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>model object</code> <p>The new sub-model of the potato.</p> required Source code in <code>antakia/potato.py</code> <pre><code>def setSubModel(self, model) -&gt; None:\n\"\"\"\n    Function that sets the sub-model of the potato.\n    Parameters\n    ----------\n    model : model object\n        The new sub-model of the potato.\n    \"\"\"\nself.sub_model[\"model\"] = model\nmodel.fit(self.data, self.y)\nself.sub_model[\"score\"] = model.score(self.data, self.y)\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.size","title":"<code>size()</code>","text":"<p>Function that returns the shape of the potato.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>The shape of the potato.</p> Source code in <code>antakia/potato.py</code> <pre><code>def size(self) -&gt; int:\n\"\"\"\n    Function that returns the shape of the potato.\n    Returns\n    -------\n    tuple\n        The shape of the potato.\n    \"\"\"\nreturn len(self.indexes)\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.stateToSring","title":"<code>stateToSring()</code>","text":"<p>Returns the state of the potato</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the state</p> Source code in <code>antakia/potato.py</code> <pre><code>def stateToSring(self)-&gt; str :\n\"\"\"\n    Returns the state of the potato\n    Returns\n    -------\n    str\n        The name of the state\n    \"\"\"\nif self.state == Potato.UNKNOWN : return \"unknown\"\nelif self.state == Potato.LASSO : return \"lasso\"\nelif self.state == Potato.SKR : return \"skope ruled\"\nelif self.state == Potato.REFINED_SKR : return \"refined skope rules\"\nelif self.state == Potato.REGION : return \"region\"\nelif self.state == Potato.JSON : return \"json importation\"\nelse : raise ValueError(\"unknown state for a potato\")\n</code></pre>"},{"location":"documentation/utils/#antakia.utils.Potato.toJson","title":"<code>toJson()</code>","text":"<p>Function that returns the potato in the form of a json file.</p> <p>Returns:</p> Type Description <code>json</code> <p>The potato in the form of a json file.</p> Source code in <code>antakia/potato.py</code> <pre><code>def toJson(self):\n\"\"\"\n    Function that returns the potato in the form of a json file.\n    Returns\n    -------\n    json\n        The potato in the form of a json file.\n    \"\"\"\nreturn {\"indexes\": self.indexes, \"state\": self.state, \"rules\": self.rules, \"score\": self.score, \"rules_exp\": self.rules_exp, \"score_exp\": self.score_exp, \"sub_model\": self.sub_model, \"success\": self.success}\n</code></pre>"}]}